// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Lwt_sequence
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Empty = [248, "Lwt_sequence.Empty", runtime.caml_fresh_oo_id(0)];
   function get(node){return node[3];}
   function set(node, data){node[3] = data; return 0;}
   function remove(node){
    var
     _k_ = node[4],
     _l_ =
       _k_
        ? (node[4] = 0, node[1][2] = node[2], node[2][1] = node[1], 0)
        : _k_;
    return _l_;
   }
   function create(param){
    var seq = [];
    runtime.caml_update_dummy(seq, [0, seq, seq]);
    return seq;
   }
   function clear(seq){seq[1] = seq; seq[2] = seq; return 0;}
   function is_empty(seq){return seq[2] === seq ? 1 : 0;}
   function length(seq){
    var curr$1 = seq[2], curr = curr$1, len = 0;
    for(;;){
     if(curr === seq) return len;
     var len$0 = len + 1 | 0, curr$0 = curr[2];
     curr = curr$0;
     len = len$0;
    }
   }
   function add_l(data, seq){
    var node = [0, seq, seq[2], data, 1];
    seq[2][1] = node;
    seq[2] = node;
    return node;
   }
   function add_r(data, seq){
    var node = [0, seq[1], seq, data, 1];
    seq[1][2] = node;
    seq[1] = node;
    return node;
   }
   function take_l(seq){
    if(is_empty(seq)) throw caml_maybe_attach_backtrace(Empty, 1);
    var node = seq[2];
    remove(node);
    return node[3];
   }
   function take_r(seq){
    if(is_empty(seq)) throw caml_maybe_attach_backtrace(Empty, 1);
    var node = seq[1];
    remove(node);
    return node[3];
   }
   function take_opt_l(seq){
    if(is_empty(seq)) return 0;
    var node = seq[2];
    remove(node);
    return [0, node[3]];
   }
   function take_opt_r(seq){
    if(is_empty(seq)) return 0;
    var node = seq[1];
    remove(node);
    return [0, node[3]];
   }
   function transfer_l(s1, s2){
    s2[2][1] = s1[1];
    s1[1][2] = s2[2];
    s2[2] = s1[2];
    s1[2][1] = s2;
    s1[1] = s1;
    s1[2] = s1;
    return 0;
   }
   function transfer_r(s1, s2){
    s2[1][2] = s1[2];
    s1[2][1] = s2[1];
    s2[1] = s1[1];
    s1[1][2] = s2;
    s1[1] = s1;
    s1[2] = s1;
    return 0;
   }
   function iter_l(f, seq){
    var curr$1 = seq[2], curr = curr$1;
    for(;;){
     var _j_ = curr !== seq ? 1 : 0;
     if(! _j_) return _j_;
     if(curr[4]) caml_call1(f, curr[3]);
     var curr$0 = curr[2];
     curr = curr$0;
    }
   }
   function iter_r(f, seq){
    var curr$1 = seq[1], curr = curr$1;
    for(;;){
     var _i_ = curr !== seq ? 1 : 0;
     if(! _i_) return _i_;
     if(curr[4]) caml_call1(f, curr[3]);
     var curr$0 = curr[1];
     curr = curr$0;
    }
   }
   function iter_node_l(f, seq){
    var curr$1 = seq[2], curr = curr$1;
    for(;;){
     var _h_ = curr !== seq ? 1 : 0;
     if(! _h_) return _h_;
     if(curr[4]) caml_call1(f, curr);
     var curr$0 = curr[2];
     curr = curr$0;
    }
   }
   function iter_node_r(f, seq){
    var curr$1 = seq[1], curr = curr$1;
    for(;;){
     var _g_ = curr !== seq ? 1 : 0;
     if(! _g_) return _g_;
     if(curr[4]) caml_call1(f, curr);
     var curr$0 = curr[1];
     curr = curr$0;
    }
   }
   function fold_l(f, seq, acc){
    var curr$2 = seq[2], curr = curr$2, acc$0 = acc;
    for(;;){
     if(curr === seq) return acc$0;
     if(curr[4]){
      var acc$1 = caml_call2(f, curr[3], acc$0), curr$0 = curr[2];
      curr = curr$0;
      acc$0 = acc$1;
     }
     else{var curr$1 = curr[2]; curr = curr$1;}
    }
   }
   function fold_r(f, seq, acc){
    var curr$2 = seq[1], curr = curr$2, acc$0 = acc;
    for(;;){
     if(curr === seq) return acc$0;
     if(curr[4]){
      var acc$1 = caml_call2(f, curr[3], acc$0), curr$0 = curr[1];
      curr = curr$0;
      acc$0 = acc$1;
     }
     else{var curr$1 = curr[1]; curr = curr$1;}
    }
   }
   function find_node_l(f, seq){
    var curr$2 = seq[2], curr = curr$2;
    for(;;){
     if(curr === seq) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(curr[4]){
      if(caml_call1(f, curr[3])) return curr;
      var curr$0 = curr[2];
      curr = curr$0;
     }
     else{var curr$1 = curr[2]; curr = curr$1;}
    }
   }
   function find_node_r(f, seq){
    var curr$2 = seq[1], curr = curr$2;
    for(;;){
     if(curr === seq) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(curr[4]){
      if(caml_call1(f, curr[3])) return curr;
      var curr$0 = curr[1];
      curr = curr$0;
     }
     else{var curr$1 = curr[1]; curr = curr$1;}
    }
   }
   function find_node_opt_l(f, seq){
    try{var _e_ = [0, find_node_l(f, seq)]; return _e_;}
    catch(_f_){
     var _d_ = caml_wrap_exception(_f_);
     if(_d_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function find_node_opt_r(f, seq){
    try{var _b_ = [0, find_node_r(f, seq)]; return _b_;}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   var
    Lwt_sequence =
      [0,
       get,
       set,
       remove,
       create,
       clear,
       is_empty,
       length,
       add_l,
       add_r,
       Empty,
       take_l,
       take_r,
       take_opt_l,
       take_opt_r,
       transfer_l,
       transfer_r,
       iter_l,
       iter_r,
       iter_node_l,
       iter_node_r,
       fold_l,
       fold_r,
       find_node_opt_l,
       find_node_opt_r,
       find_node_l,
       find_node_r];
   runtime.caml_register_global(2, Lwt_sequence, "Lwt_sequence");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt
//# unitInfo: Requires: Assert_failure, CamlinternalLazy, Lwt_sequence, Stdlib, Stdlib__Array, Stdlib__List, Stdlib__Map, Stdlib__Printexc, Stdlib__Printf, Stdlib__Queue, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Lwt = "Lwt.",
    cst_Lwt_s = "Lwt.%s",
    cst_src_core_lwt_ml = "src/core/lwt.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) === 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Map = global_data.Stdlib__Map,
    compare = runtime.caml_compare,
    Storage_map = caml_call1(Stdlib_Map[1], [0, compare]);
   function state_of_result(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var exn = param[1];
    return [1, exn];
   }
   function underlying(p){
    var match = p[1];
    switch(match[0]){
      case 0:
       return p;
      case 1:
       return p;
      case 2:
       return p;
      default:
       var p2 = match[1], p1 = underlying(p2);
       if(1 - (p1 === p2 ? 1 : 0)) p[1] = [3, p1];
       return p1;
    }
   }
   function handle_all(param){return 1;}
   function handle_all_except_runtime(param){
    return param === Stdlib[9] ? 0 : param === Stdlib[10] ? 0 : 1;
   }
   var v = [0, handle_all];
   function set(f){v[1] = f; return 0;}
   function run(e){return caml_call1(v[1], e);}
   var next_key_id = [0, 0];
   function new_key(param){
    var id = next_key_id[1];
    next_key_id[1] = id + 1 | 0;
    return [0, id, 0];
   }
   var
    current_storage = [0, Storage_map[1]],
    _a_ = [0, cst_src_core_lwt_ml, 980, 23],
    _b_ = [0, cst_src_core_lwt_ml, 981, 22],
    cst_Fatal_error_exception = "Fatal error: exception ";
   function get(key){
    if(! caml_call2(Storage_map[3], key[1], current_storage[1])) return 0;
    var refresh = caml_call2(Storage_map[28], key[1], current_storage[1]);
    caml_call1(refresh, 0);
    var value = key[2];
    key[2] = 0;
    return value;
   }
   function with_value(key, value, f){
    if(value)
     var
      refresh = function(param){key[2] = value; return 0;},
      new_storage =
        caml_call3(Storage_map[4], key[1], refresh, current_storage[1]);
    else
     var new_storage = caml_call2(Storage_map[7], key[1], current_storage[1]);
    var saved_storage = current_storage[1];
    current_storage[1] = new_storage;
    try{
     var result = caml_call1(f, 0);
     current_storage[1] = saved_storage;
     return result;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     current_storage[1] = saved_storage;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function concat_regular_callbacks(l1, l2){
    return typeof l1 === "number"
            ? l2
            : typeof l2 === "number" ? l1 : [0, l1, l2];
   }
   function clean_up_callback_cells(callbacks){
    if(typeof callbacks !== "number")
     switch(callbacks[0]){
       case 0:
        var
         l2 = callbacks[2],
         l1 = callbacks[1],
         l1$0 = clean_up_callback_cells(l1),
         l2$0 = clean_up_callback_cells(l2);
        return concat_regular_callbacks(l1$0, l2$0);
       case 2:
        if(! callbacks[1][1]) return 0; break;
     }
    return callbacks;
   }
   function clear_explicitly_removable_cal(cell, ps){
    cell[1] = 0;
    return caml_call1
            (caml_call1
              (Stdlib_List[17],
               function(p){
                var match = underlying(p)[1];
                switch(match[0]){
                  case 1:
                   return 0;
                  case 2:
                   var callbacks = match[1], _aW_ = callbacks[1];
                   if(typeof _aW_ !== "number" && 2 === _aW_[0]){callbacks[1] = 0; return 0;}
                   var cleanups_deferred = callbacks[4] + 1 | 0;
                   return 42 < cleanups_deferred
                           ? (callbacks
                              [4]
                             = 0,
                             callbacks[1] = clean_up_callback_cells(callbacks[1]),
                             0)
                           : (callbacks[4] = cleanups_deferred, 0);
                  default: return 0;
                }
               }),
             ps);
   }
   function add_regular_callback_list_node(callbacks, node){
    var
     existing = callbacks[1],
     node$0 = typeof existing === "number" ? node : [0, node, existing];
    callbacks[1] = node$0;
    return 0;
   }
   function add_implicitly_removed_callbac(callbacks, f){
    return add_regular_callback_list_node(callbacks, [1, f]);
   }
   function add_explicitly_removable_callb(ps, f){
    var
     cell = [],
     self_removing_callback_wrapper =
       function _aV_(_aU_){return _aV_.fun(_aU_);};
    caml_update_dummy(cell, [0, [0, self_removing_callback_wrapper]]);
    caml_update_dummy
     (self_removing_callback_wrapper,
      function(result){
       clear_explicitly_removable_cal(cell, ps);
       return caml_call1(f, result);
      });
    var node = [2, cell];
    caml_call1
     (caml_call1
       (Stdlib_List[17],
        function(p){
         var match = underlying(p)[1];
         switch(match[0]){
           case 1:
            throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
           case 2:
            var callbacks = match[1];
            return add_regular_callback_list_node(callbacks, node);
           default:
            throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
         }
        }),
      ps);
    return cell;
   }
   function add_explicitly_removable_callb$0(ps, f){add_explicitly_removable_callb(ps, f);
   }
   function add_cancel_callback(callbacks, f){
    var
     node = [1, current_storage[1], f],
     node$0 =
       typeof callbacks[2] === "number" ? node : [0, node, callbacks[2]];
    callbacks[2] = node$0;
    return 0;
   }
   var
    async_exception_hook =
      [0,
       function(exn){
        caml_call1(Stdlib[49], cst_Fatal_error_exception);
        var _aT_ = caml_call1(Stdlib_Printexc[1], exn);
        caml_call1(Stdlib[49], _aT_);
        caml_call1(Stdlib[48], 10);
        caml_call1(Stdlib_Printexc[5], Stdlib[40]);
        caml_call1(Stdlib[63], Stdlib[40]);
        return caml_call1(Stdlib[99], 2);
       }];
   function handle_with_async_exception_ho(f, v){
    try{var _aS_ = caml_call1(f, v); return _aS_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return caml_call1(async_exception_hook[1], exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var
    Canceled =
      [248, "Lwt.Resolution_loop.Canceled", runtime.caml_fresh_oo_id(0)];
   function run_callbacks(callbacks, result){
    if(1 === result[0])
     var _aR_ = result[1] === Canceled ? 1 : 0, is_canceled = _aR_;
    else
     var is_canceled = 0;
    if(is_canceled){
     var
      fs = callbacks[2],
      iter_callback_list$2 =
        function(counter, fs, rest){
         var fs$0 = fs, rest$0 = rest;
         for(;;){
          if(typeof fs$0 === "number"){
           if(counter >= 50)
            return caml_trampoline_return(iter_list$0, [0, rest$0]);
           var counter$0 = counter + 1 | 0;
           return iter_list$0(counter$0, rest$0);
          }
          switch(fs$0[0]){
            case 0:
             var fs$1 = fs$0[2], fs$2 = fs$0[1], rest$1 = [0, fs$1, rest$0];
             fs$0 = fs$2;
             rest$0 = rest$1;
             break;
            case 1:
             var f = fs$0[2], storage = fs$0[1];
             current_storage[1] = storage;
             handle_with_async_exception_ho(f, 0);
             if(counter >= 50)
              return caml_trampoline_return(iter_list$0, [0, rest$0]);
             var counter$1 = counter + 1 | 0;
             return iter_list$0(counter$1, rest$0);
            default:
             var node = fs$0[1];
             caml_call1(Lwt_sequence[3], node);
             if(counter >= 50)
              return caml_trampoline_return(iter_list$0, [0, rest$0]);
             var counter$2 = counter + 1 | 0;
             return iter_list$0(counter$2, rest$0);
          }
         }
        },
      iter_callback_list =
        function(fs, rest){
         return caml_trampoline(iter_callback_list$2(0, fs, rest));
        },
      iter_list$0 =
        function(counter, rest){
         if(! rest) return;
         var rest$0 = rest[2], fs = rest[1];
         if(counter >= 50)
          return caml_trampoline_return(iter_callback_list$2, [0, fs, rest$0]);
         var counter$0 = counter + 1 | 0;
         return iter_callback_list$2(counter$0, fs, rest$0);
        };
     iter_callback_list(fs, 0);
    }
    var fs$0 = callbacks[1];
    function iter_callback_list$1(counter, fs, rest){
     var fs$0 = fs, rest$0 = rest;
     for(;;){
      if(typeof fs$0 === "number"){
       if(counter >= 50)
        return caml_trampoline_return(iter_list, [0, rest$0]);
       var counter$0 = counter + 1 | 0;
       return iter_list(counter$0, rest$0);
      }
      switch(fs$0[0]){
        case 0:
         var fs$1 = fs$0[2], fs$2 = fs$0[1], rest$1 = [0, fs$1, rest$0];
         fs$0 = fs$2;
         rest$0 = rest$1;
         break;
        case 1:
         var f = fs$0[1];
         caml_call1(f, result);
         if(counter >= 50)
          return caml_trampoline_return(iter_list, [0, rest$0]);
         var counter$1 = counter + 1 | 0;
         return iter_list(counter$1, rest$0);
        default:
         var match = fs$0[1][1];
         if(match){
          var f$0 = match[1];
          caml_call1(f$0, result);
          if(counter >= 50)
           return caml_trampoline_return(iter_list, [0, rest$0]);
          var counter$2 = counter + 1 | 0;
          return iter_list(counter$2, rest$0);
         }
         if(counter >= 50)
          return caml_trampoline_return(iter_list, [0, rest$0]);
         var counter$3 = counter + 1 | 0;
         return iter_list(counter$3, rest$0);
      }
     }
    }
    function iter_callback_list$0(fs, rest){
     return caml_trampoline(iter_callback_list$1(0, fs, rest));
    }
    function iter_list(counter, rest){
     if(! rest) return 0;
     var rest$0 = rest[2], fs = rest[1];
     if(counter >= 50)
      return caml_trampoline_return(iter_callback_list$1, [0, fs, rest$0]);
     var counter$0 = counter + 1 | 0;
     return iter_callback_list$1(counter$0, fs, rest$0);
    }
    return iter_callback_list$0(fs$0, 0);
   }
   var
    current_callback_nesting_depth = [0, 0],
    deferred_callbacks = caml_call1(Stdlib_Queue[2], 0),
    default_maximum_callback_nesti = 42,
    _c_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _d_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _e_ = [0, 0],
    cst_wakeup_result = "wakeup_result",
    cst_wakeup = "wakeup",
    cst_wakeup_exn = "wakeup_exn",
    _f_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _g_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _h_ = [0, 1],
    cst_wakeup_later_result = "wakeup_later_result",
    cst_wakeup_later = "wakeup_later",
    cst_wakeup_later_exn = "wakeup_later_exn",
    _i_ = [0, 0];
   function leave_resolution_loop(storage_snapshot){
    if(1 === current_callback_nesting_depth[1])
     for(;;){
      if(caml_call1(Stdlib_Queue[13], deferred_callbacks)) break;
      var
       match = caml_call1(Stdlib_Queue[7], deferred_callbacks),
       result = match[2],
       callbacks = match[1];
      run_callbacks(callbacks, result);
     }
    current_callback_nesting_depth[1] =
     current_callback_nesting_depth[1] - 1 | 0;
    current_storage[1] = storage_snapshot;
    return 0;
   }
   function run_in_resolution_loop(f){
    current_callback_nesting_depth[1] =
     current_callback_nesting_depth[1] + 1 | 0;
    var storage_snapshot = current_storage[1], result = caml_call1(f, 0);
    leave_resolution_loop(storage_snapshot);
    return result;
   }
   function abandon_wakeups(param){
    var _aQ_ = 0 !== current_callback_nesting_depth[1] ? 1 : 0;
    return _aQ_ ? leave_resolution_loop(Storage_map[1]) : _aQ_;
   }
   function run_callbacks_or_defer_them(opt, _aP_, callbacks, result){
    if(opt)
     var sth = opt[1], allow_deferring = sth;
    else
     var allow_deferring = 1;
    if(_aP_)
     var sth$0 = _aP_[1], maximum_callback_nesting_depth = sth$0;
    else
     var maximum_callback_nesting_depth = default_maximum_callback_nesti;
    var
     should_defer =
       allow_deferring
        ? maximum_callback_nesting_depth
          <= current_callback_nesting_depth[1]
          ? 1
          : 0
        : allow_deferring;
    return should_defer
            ? caml_call2
              (Stdlib_Queue[4], [0, callbacks, result], deferred_callbacks)
            : run_in_resolution_loop
              (function(param){return run_callbacks(callbacks, result);});
   }
   function resolve
   (allow_deferring, maximum_callback_nesting_depth, p, result){
    var callbacks = p[1][1];
    p[1] = result;
    run_callbacks_or_defer_them
     (allow_deferring, maximum_callback_nesting_depth, callbacks, result);
    return p;
   }
   function run_callback_or_defer_it(opt, f, if_deferred){
    if(opt)
     var sth = opt[1], run_immediately_and_ensure_tai = sth;
    else
     var run_immediately_and_ensure_tai = 0;
    if(run_immediately_and_ensure_tai) return caml_call1(f, 0);
    var should_defer = 42 <= current_callback_nesting_depth[1] ? 1 : 0;
    if(! should_defer)
     return run_in_resolution_loop(function(param){return caml_call1(f, 0);});
    var
     match = caml_call1(if_deferred, 0),
     deferred_result = match[3],
     deferred_callback = match[2],
     immediate_result = match[1],
     deferred_record = [0, [1, deferred_callback], 0, 0, 0];
    caml_call2
     (Stdlib_Queue[4],
      [0, deferred_record, deferred_result],
      deferred_callbacks);
    return immediate_result;
   }
   function wakeup_general(api_function_name, r, result){
    var p = underlying(r), _aO_ = p[1];
    switch(_aO_[0]){
      case 1:
       return _aO_[1] === Canceled
               ? 0
               : caml_call3
                 (Stdlib_Printf[10], Stdlib[1], _d_, api_function_name);
      case 2:
       var result$0 = state_of_result(result);
       resolve(_e_, 0, p, result$0);
       return 0;
      default:
       return caml_call3(Stdlib_Printf[10], Stdlib[1], _c_, api_function_name);
    }
   }
   function wakeup_result(r, result){
    return wakeup_general(cst_wakeup_result, r, result);
   }
   function wakeup(r, v){return wakeup_general(cst_wakeup, r, [0, v]);}
   function wakeup_exn(r, exn){
    return wakeup_general(cst_wakeup_exn, r, [1, exn]);
   }
   function wakeup_later_general(api_function_name, r, result){
    var p = underlying(r), _aN_ = p[1];
    switch(_aN_[0]){
      case 1:
       return _aN_[1] === Canceled
               ? 0
               : caml_call3
                 (Stdlib_Printf[10], Stdlib[1], _g_, api_function_name);
      case 2:
       var result$0 = state_of_result(result);
       resolve(0, _h_, p, result$0);
       return 0;
      default:
       return caml_call3(Stdlib_Printf[10], Stdlib[1], _f_, api_function_name);
    }
   }
   function wakeup_later_result(r, result){
    return wakeup_later_general(cst_wakeup_later_result, r, result);
   }
   function wakeup_later(r, v){
    return wakeup_later_general(cst_wakeup_later, r, [0, v]);
   }
   function wakeup_later_exn(r, exn){
    return wakeup_later_general(cst_wakeup_later_exn, r, [1, exn]);
   }
   function cancel(p){
    var canceled_result = [1, Canceled];
    function cancel_and_collect_callbacks(callbacks_accumulator, p){
     var p$0 = p;
     for(;;){
      var p$1 = underlying(p$0), match = p$1[1];
      switch(match[0]){
        case 1:
         return callbacks_accumulator;
        case 2:
         var callbacks = match[1], match$0 = callbacks[3];
         if(typeof match$0 === "number")
          return 0 === match$0
                  ? callbacks_accumulator
                  : (p$1
                     [1]
                    = canceled_result,
                    [0, callbacks, callbacks_accumulator]);
         if(0 !== match$0[0]){
          var ps = match$0[1];
          return caml_call3
                  (Stdlib_List[25],
                   cancel_and_collect_callbacks,
                   callbacks_accumulator,
                   ps);
         }
         var p$2 = match$0[1];
         p$0 = p$2;
         break;
        default: return callbacks_accumulator;
      }
     }
    }
    var callbacks = cancel_and_collect_callbacks(0, p);
    return caml_call1
            (caml_call1
              (Stdlib_List[17],
               function(param){
                return run_callbacks_or_defer_them
                        (_i_, 0, param, canceled_result);
               }),
             callbacks);
   }
   function return$0(v){return [0, [0, v]];}
   function of_result(result){return [0, state_of_result(result)];}
   function fail(exn){return [0, [1, exn]];}
   var return_unit = return$0(0), return_none = return$0(0);
   function return_some(x){return return$0([0, x]);}
   var
    return_nil = return$0(0),
    return_true = return$0(1),
    return_false = return$0(0),
    _j_ = [0, 0],
    _k_ = [0, 0],
    _l_ = [0, 0],
    _m_ = [0, 0],
    _n_ = [0, 0],
    _o_ = [0, 1],
    _p_ = [0, 0],
    _q_ = [0, 1],
    _r_ = [0, 0],
    _s_ = [0, 0],
    _t_ = [0, 1],
    _u_ = [0, 0],
    _v_ = [0, 1],
    _w_ = [0, 0],
    _x_ = [0, 1],
    _y_ = [0, 1],
    _z_ = [0, 1],
    _A_ = [0, 1],
    _B_ = [0, 1],
    _C_ = [0, 0],
    _D_ = [0, 1],
    _E_ = [0, 1],
    _F_ = [0, 1],
    _G_ = [0, 1],
    _H_ = [0, 1],
    _I_ = [0, 1],
    _J_ = [0, 1],
    _K_ = [0, 0],
    _L_ = [0, 0],
    _M_ = [0, cst_src_core_lwt_ml, 2651, 13],
    _N_ = [0, cst_src_core_lwt_ml, 2670, 24],
    _O_ = [0, cst_src_core_lwt_ml, 2709, 6],
    _P_ = [0, cst_src_core_lwt_ml, 2729, 6];
   function return_ok(x){return return$0([0, x]);}
   function return_error(x){return return$0([1, x]);}
   function fail_with(msg){return [0, [1, [0, Stdlib[7], msg]]];}
   function fail_invalid_arg(msg){return [0, [1, [0, Stdlib[6], msg]]];}
   function new_pending(how_to_cancel){
    var state = [2, [0, 0, 0, how_to_cancel, 0]];
    return [0, state];
   }
   function wait(param){var p = new_pending(0); return [0, p, p];}
   function task(param){var p = new_pending(1); return [0, p, p];}
   function add_task_r(sequence){
    var
     p = new_pending(1),
     node = caml_call2(Lwt_sequence[9], p, sequence),
     callbacks = p[1][1];
    callbacks[2] = [2, node];
    return p;
   }
   function add_task_l(sequence){
    var
     p = new_pending(1),
     node = caml_call2(Lwt_sequence[8], p, sequence),
     callbacks = p[1][1];
    callbacks[2] = [2, node];
    return p;
   }
   function protected$0(p_internal){
    switch(underlying(p_internal)[1][0]){
      case 1:
       return p_internal;
      case 2:
       var
        p = new_pending(1),
        callback =
          function(p_result){
           var p$0 = underlying(p);
           resolve(_j_, 0, p$0, p_result);
           return 0;
          },
        ps = [0, p_internal, 0],
        cell = add_explicitly_removable_callb(ps, callback),
        remove_the_callback =
          function(param){return clear_explicitly_removable_cal(cell, ps);},
        p_callbacks = p[1][1];
       add_cancel_callback(p_callbacks, remove_the_callback);
       return p;
      default: return p_internal;
    }
   }
   function no_cancel(p_internal){
    var match = underlying(p_internal)[1];
    switch(match[0]){
      case 1:
       return p_internal;
      case 2:
       var
        p_callbacks = match[1],
        p = new_pending(0),
        callback =
          function(p_result){
           var p$0 = underlying(p);
           resolve(_k_, 0, p$0, p_result);
           return 0;
          };
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p;
      default: return p_internal;
    }
   }
   function make_into_proxy(outer_promise, user_provided_promise){
    var p1 = underlying(user_provided_promise);
    if(p1 === outer_promise) return p1;
    var match = p1[1];
    switch(match[0]){
      case 1:
       return resolve(_m_, 0, outer_promise, p1[1]);
      case 2:
       var
        p_callbacks = match[1],
        outer_callbacks = outer_promise[1][1],
        regular_callbacks =
          concat_regular_callbacks(outer_callbacks[1], p_callbacks[1]),
        cleanups_deferred = outer_callbacks[4] + p_callbacks[4] | 0;
       if(42 < cleanups_deferred)
        var
         cleanups_deferred$0 = 0,
         regular_callbacks$0 = clean_up_callback_cells(regular_callbacks);
       else
        var
         cleanups_deferred$0 = cleanups_deferred,
         regular_callbacks$0 = regular_callbacks;
       var
        l2 = p_callbacks[2],
        l1 = outer_callbacks[2],
        cancel_callbacks =
          typeof l1 === "number"
           ? l2
           : typeof l2 === "number" ? l1 : [0, l1, l2];
       outer_callbacks[1] = regular_callbacks$0;
       outer_callbacks[2] = cancel_callbacks;
       outer_callbacks[4] = cleanups_deferred$0;
       outer_callbacks[3] = p_callbacks[3];
       var state = [3, outer_promise];
       p1[1] = state;
       return outer_promise;
      default: return resolve(_l_, 0, outer_promise, p1[1]);
    }
   }
   function symbol_bind(p, f){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var p$2 = underlying(p);
       resolve(_n_, 0, p$2, p_result);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aM_ = caml_call1(f, v), p$0 = _aM_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(exn);
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var result = p$0[1];
    switch(result[0]){
      case 1:
       return [0, result];
      case 2:
       var
        p_callbacks = result[1],
        match = create_result_promise_and_call(0),
        callback = match[2],
        p$1 = match[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = result[1];
       return run_callback_or_defer_it
               (_o_,
                function(param){return caml_call1(f, v);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function backtrace_bind(add_loc, p, f){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1], p$2 = underlying(p);
       resolve(_p_, 0, p$2, [1, caml_call1(add_loc, exn$0)]);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aL_ = caml_call1(f, v), p$0 = _aL_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(caml_call1(add_loc, exn));
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; return [0, [1, caml_call1(add_loc, exn)]];
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_q_,
                function(param){return caml_call1(f, v);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function symbol(f, p){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var p$1 = underlying(p);
       resolve(_s_, 0, p$1, p_result);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aK_ = [0, caml_call1(f, v)], p_result$0 = _aK_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p_result$0 = [1, exn];
      }
      var p$0 = underlying(p);
      resolve(_r_, 0, p$0, p_result$0);
      return 0;
     }
     return [0, p, callback];
    }
    var result = p$0[1];
    switch(result[0]){
      case 1:
       return [0, result];
      case 2:
       var
        p_callbacks = result[1],
        match = create_result_promise_and_call(0),
        callback = match[2],
        p$1 = match[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = result[1];
       return run_callback_or_defer_it
               (_t_,
                function(param){
                 try{var _aJ_ = [0, caml_call1(f, v)], _aI_ = _aJ_;}
                 catch(exn$0){
                  var exn = caml_wrap_exception(exn$0);
                  if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
                  var _aI_ = [1, exn];
                 }
                 return [0, _aI_];
                },
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function catch$0(f, h){
    try{var _aG_ = caml_call1(f, 0), p = _aG_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 !== p_result[0]){
       var p$0 = underlying(p);
       resolve(_u_, 0, p$0, p_result);
       return 0;
      }
      var exn = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aH_ = caml_call1(h, exn), p$1 = _aH_;}
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(! run(exn$0)) throw caml_maybe_attach_backtrace(exn$0, 0);
       var p$1 = fail(exn$0);
      }
      var p$2 = underlying(p);
      make_into_proxy(p$2, p$1);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return run_callback_or_defer_it
               (_v_,
                function(param){return caml_call1(h, exn$0);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default: return p$0;
    }
   }
   function backtrace_catch(add_loc, f, h){
    try{var _aE_ = caml_call1(f, 0), p = _aE_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 !== p_result[0]){
       var p$0 = underlying(p);
       resolve(_w_, 0, p$0, p_result);
       return 0;
      }
      var exn = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aF_ = caml_call1(h, exn), p$1 = _aF_;}
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(! run(exn$0)) throw caml_maybe_attach_backtrace(exn$0, 0);
       var p$1 = fail(caml_call1(add_loc, exn$0));
      }
      var p$2 = underlying(p);
      make_into_proxy(p$2, p$1);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return run_callback_or_defer_it
               (_x_,
                function(param){
                 return caml_call1(h, caml_call1(add_loc, exn$0));
                },
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default: return p$0;
    }
   }
   function try_bind(f$0, f, h){
    try{var _aB_ = caml_call1(f$0, 0), p = _aB_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1];
       current_storage[1] = saved_storage;
       try{var _aD_ = caml_call1(h, exn$0), p$2 = _aD_;}
       catch(exn){
        var exn$1 = caml_wrap_exception(exn);
        if(! run(exn$1)) throw caml_maybe_attach_backtrace(exn$1, 0);
        var p$2 = fail(exn$1);
       }
       var p$3 = underlying(p);
       make_into_proxy(p$3, p$2);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aC_ = caml_call1(f, v), p$0 = _aC_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(exn);
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return run_callback_or_defer_it
               (_z_,
                function(param){return caml_call1(h, exn$0);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_y_,
                function(param){return caml_call1(f, v);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function backtrace_try_bind(add_loc, f$0, f, h){
    try{var _ay_ = caml_call1(f$0, 0), p = _ay_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1];
       current_storage[1] = saved_storage;
       try{var _aA_ = caml_call1(h, exn$0), p$2 = _aA_;}
       catch(exn){
        var exn$1 = caml_wrap_exception(exn);
        if(! run(exn$1)) throw caml_maybe_attach_backtrace(exn$1, 0);
        var p$2 = fail(caml_call1(add_loc, exn$1));
       }
       var p$3 = underlying(p);
       make_into_proxy(p$3, p$2);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _az_ = caml_call1(f, v), p$0 = _az_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(caml_call1(add_loc, exn));
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return run_callback_or_defer_it
               (_B_,
                function(param){
                 return caml_call1(h, caml_call1(add_loc, exn$0));
                },
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_A_,
                function(param){return caml_call1(f, v);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function finalize(f$0, f){
    return try_bind
            (f$0,
             function(x){
              return symbol_bind
                      (caml_call1(f, 0), function(param){return return$0(x);});
             },
             function(e){
              return symbol_bind
                      (caml_call1(f, 0), function(param){return fail(e);});
             });
   }
   function backtrace_finalize(add_loc, f$0, f){
    return backtrace_try_bind
            (add_loc,
             f$0,
             function(x){
              return symbol_bind
                      (caml_call1(f, 0), function(param){return return$0(x);});
             },
             function(e){
              return symbol_bind
                      (caml_call1(f, 0),
                       function(param){return fail(caml_call1(add_loc, e));});
             });
   }
   function on_cancel(p, f){
    var p$0 = underlying(p), match = p$0[1];
    switch(match[0]){
      case 1:
       return match[1] === Canceled
               ? run_callback_or_defer_it
                 (_D_,
                  function(param){
                   return handle_with_async_exception_ho(f, 0);
                  },
                  function(param){
                   return [0,
                           0,
                           function(param){
                            return handle_with_async_exception_ho(f, 0);
                           },
                           _C_];
                  })
               : 0;
      case 2:
       var callbacks = match[1]; return add_cancel_callback(callbacks, f);
      default: return 0;
    }
   }
   function on_success(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 === result[0]) return 0;
      var v = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, v);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       return 0;
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_E_,
                function(param){return handle_with_async_exception_ho(f, v);},
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
    }
   }
   function on_failure(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 !== result[0]) return 0;
      var exn = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, exn);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn = match[1];
       return run_callback_or_defer_it
               (_F_,
                function(param){
                 return handle_with_async_exception_ho(f, exn);
                },
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function on_termination(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, 0);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       return run_callback_or_defer_it
               (_H_,
                function(param){return handle_with_async_exception_ho(f, 0);},
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       return run_callback_or_defer_it
               (_G_,
                function(param){return handle_with_async_exception_ho(f, 0);},
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
    }
   }
   function on_any(p, f, g){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 === result[0]){
       var exn = result[1];
       current_storage[1] = saved_storage;
       return handle_with_async_exception_ho(g, exn);
      }
      var v = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, v);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn = match[1];
       return run_callback_or_defer_it
               (_J_,
                function(param){
                 return handle_with_async_exception_ho(g, exn);
                },
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_I_,
                function(param){return handle_with_async_exception_ho(f, v);},
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
    }
   }
   function wrap_in_cancelable(p_internal){
    var p_underlying = underlying(p_internal);
    switch(p_underlying[1][0]){
      case 1:
       return p_internal;
      case 2:
       var match = task(0), r = match[2], p = match[1];
       on_cancel(p, function(param){return cancel(p_internal);});
       on_any
        (p_internal,
         function(_ax_){return wakeup(r, _ax_);},
         function(_aw_){return wakeup_exn(r, _aw_);});
       return p;
      default: return p_internal;
    }
   }
   function dont_wait(f, h){
    try{var _av_ = caml_call1(f, 0), p = _av_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1]; return caml_call1(h, exn$0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(h, exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function async(f){
    try{var _au_ = caml_call1(f, 0), p = _au_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return caml_call1(async_exception_hook[1], exn$0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(async_exception_hook[1], exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function ignore_result(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; throw caml_maybe_attach_backtrace(exn, 0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(async_exception_hook[1], exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function join(ps){
    var
     p = new_pending([1, ps]),
     number_pending_in_ps = [0, 0],
     join_result = [0, _K_];
    function callback(new_result){
     if(1 === new_result[0] && 1 !== join_result[1][0])
      join_result[1] = new_result;
     number_pending_in_ps[1] = number_pending_in_ps[1] - 1 | 0;
     var _ar_ = 0 === number_pending_in_ps[1] ? 1 : 0;
     if(_ar_){
      var p$0 = underlying(p), _as_ = join_result[1];
      resolve(_L_, 0, underlying(p$0), _as_);
      var _at_ = 0;
     }
     else
      var _at_ = _ar_;
     return _at_;
    }
    var ps$0 = ps;
    for(;;){
     if(! ps$0)
      return 0 === number_pending_in_ps[1] ? [0, join_result[1]] : p;
     var ps$1 = ps$0[2], p$0 = ps$0[1], p_result = underlying(p$0)[1];
     switch(p_result[0]){
       case 1:
        if(1 !== join_result[1][0]) join_result[1] = p_result;
        ps$0 = ps$1;
        break;
       case 2:
        var p_callbacks = p_result[1];
        number_pending_in_ps[1] = number_pending_in_ps[1] + 1 | 0;
        add_implicitly_removed_callbac(p_callbacks, callback);
        ps$0 = ps$1;
        break;
       default: ps$0 = ps$1;
     }
    }
   }
   function both(p1, p2){
    var
     pair = [0, 0, 0],
     p1$0 =
       symbol_bind(p1, function(v){pair[1] = [0, v]; return return_unit;}),
     p2$0 =
       symbol_bind(p2, function(v){pair[2] = [0, v]; return return_unit;});
    return symbol
            (function(param){
              var _aq_ = pair[1], match = pair[2];
              if(_aq_ && match){
               var v2 = match[1], v1 = _aq_[1];
               return [0, v1, v2];
              }
              throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
             },
             join([0, p1$0, [0, p2$0, 0]]));
   }
   function all(ps){
    if(! ps) return return_nil;
    var _ap_ = ps[2], x = ps[1];
    if(! _ap_) return symbol(function(y){return [0, y, 0];}, x);
    if(_ap_[2]){
     var vs = runtime.caml_make_vect(caml_call1(Stdlib_List[1], ps), 0);
     return symbol
             (function(param){
               var i$1 = vs.length - 2 | 0, i = i$1, acc = 0;
               for(;;){
                if(0 > i) return acc;
                var match = vs[1 + i];
                if(! match)
                 throw caml_maybe_attach_backtrace
                        ([0, Assert_failure, _N_], 1);
                var x = match[1], acc$0 = [0, x, acc], i$0 = i - 1 | 0;
                i = i$0;
                acc = acc$0;
               }
              },
              join
               (caml_call1
                 (caml_call1
                   (Stdlib_List[20],
                    function(index, p){
                     return symbol_bind
                             (p,
                              function(v){
                               runtime.caml_check_bound(vs, index)[1 + index] = [0, v];
                               return return_unit;
                              });
                    }),
                  ps)));
    }
    var y = _ap_[1];
    return symbol
            (function(param){
              var y = param[2], x = param[1];
              return [0, x, [0, y, 0]];
             },
             both(x, y));
   }
   function count_resolved_promises_in(ps){
    var total$1 = 0, ps$2 = ps;
    a:
    for(;;){
     if(! ps$2) return [0, total$1];
     var ps$3 = ps$2[2], p$0 = ps$2[1];
     switch(underlying(p$0)[1][0]){
       case 1:
        break a;
       case 2:
        ps$2 = ps$3; break;
       default: var total$2 = total$1 + 1 | 0; total$1 = total$2; ps$2 = ps$3;
     }
    }
    var
     rejected$1 = [0, p$0, 0],
     total = 1,
     rejected = rejected$1,
     ps$0 = ps$3;
    for(;;){
     if(! ps$0) return [1, [0, total, rejected]];
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        var rejected$0 = [0, p, rejected], total$0 = total + 1 | 0;
        total = total$0;
        rejected = rejected$0;
        ps$0 = ps$1;
        break;
       case 2:
        ps$0 = ps$1; break;
       default: ps$0 = ps$1;
     }
    }
   }
   function nth_resolved(ps, n){
    var ps$0 = ps, n$0 = n;
    for(;;){
     if(! ps$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _O_], 1);
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        if(0 >= n$0) return p;
        var n$2 = n$0 - 1 | 0;
        ps$0 = ps$1;
        n$0 = n$2;
        break;
       case 2:
        ps$0 = ps$1; break;
       default:
        if(0 >= n$0) return p; var n$1 = n$0 - 1 | 0; ps$0 = ps$1; n$0 = n$1;
     }
    }
   }
   function nth_resolved_and_cancel_pendin(ps, n){
    var ps$0 = ps, n$0 = n;
    for(;;){
     if(! ps$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        if(0 >= n$0){caml_call2(Stdlib_List[17], cancel, ps$1); return p;}
        var n$2 = n$0 - 1 | 0;
        ps$0 = ps$1;
        n$0 = n$2;
        break;
       case 2:
        cancel(p); ps$0 = ps$1; break;
       default:
        if(0 >= n$0){caml_call2(Stdlib_List[17], cancel, ps$1); return p;}
        var n$1 = n$0 - 1 | 0;
        ps$0 = ps$1;
        n$0 = n$1;
     }
    }
   }
   var
    prng =
      [246, function(_ao_){return caml_call1(Stdlib_Random[12][1], [0]);}],
    cst_Lwt_choose_would_return_a_ =
      "Lwt.choose [] would return a promise that is pending forever",
    _Q_ = [0, 0],
    cst_Lwt_pick_would_return_a_pr =
      "Lwt.pick [] would return a promise that is pending forever",
    _R_ = [0, 0],
    cst_Lwt_nchoose_would_return_a =
      "Lwt.nchoose [] would return a promise that is pending forever",
    _S_ = [0, 0],
    cst_Lwt_npick_would_return_a_p =
      "Lwt.npick [] would return a promise that is pending forever",
    _T_ = [0, 0],
    cst_Lwt_nchoose_split_would_re =
      "Lwt.nchoose_split [] would return a promise that is pending forever",
    _U_ = [0, 0],
    _V_ = [0, 0];
   function choose(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_choose_would_return_a_);
    var match = count_resolved_promises_in(ps);
    if(0 !== match[0]){
     var
      match$0 = match[1],
      ps$0 = match$0[2],
      n$0 = match$0[1],
      _am_ = caml_obj_tag(prng),
      _an_ =
        250 === _am_
         ? prng[1]
         : 246 === _am_ ? caml_call1(CamlinternalLazy[2], prng) : prng;
     return nth_resolved(ps$0, caml_call2(Stdlib_Random[12][5], _an_, n$0));
    }
    var n = match[1];
    if(0 === n){
     var
      p = new_pending([1, ps]),
      callback =
        function(result){
         var p$0 = underlying(p);
         resolve(_Q_, 0, p$0, result);
         return 0;
        };
     add_explicitly_removable_callb$0(ps, callback);
     return p;
    }
    if(1 === n) return nth_resolved(ps, 0);
    var
     _ak_ = caml_obj_tag(prng),
     _al_ =
       250 === _ak_
        ? prng[1]
        : 246 === _ak_ ? caml_call1(CamlinternalLazy[2], prng) : prng;
    return nth_resolved(ps, caml_call2(Stdlib_Random[12][5], _al_, n));
   }
   function pick(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_pick_would_return_a_pr);
    var match = count_resolved_promises_in(ps);
    if(0 !== match[0]){
     var match$0 = match[1], qs = match$0[2], n$0 = match$0[1];
     caml_call2(Stdlib_List[17], cancel, ps);
     var
      _ai_ = caml_obj_tag(prng),
      _aj_ =
        250 === _ai_
         ? prng[1]
         : 246 === _ai_ ? caml_call1(CamlinternalLazy[2], prng) : prng;
     return nth_resolved(qs, caml_call2(Stdlib_Random[12][5], _aj_, n$0));
    }
    var n = match[1];
    if(0 === n){
     var
      p = new_pending([1, ps]),
      callback =
        function(result){
         caml_call2(Stdlib_List[17], cancel, ps);
         var p$0 = underlying(p);
         resolve(_R_, 0, p$0, result);
         return 0;
        };
     add_explicitly_removable_callb$0(ps, callback);
     return p;
    }
    if(1 === n) return nth_resolved_and_cancel_pendin(ps, 0);
    var
     _ag_ = caml_obj_tag(prng),
     _ah_ =
       250 === _ag_
        ? prng[1]
        : 246 === _ag_ ? caml_call1(CamlinternalLazy[2], prng) : prng;
    return nth_resolved_and_cancel_pendin
            (ps, caml_call2(Stdlib_Random[12][5], _ah_, n));
   }
   function collect_fulfilled_promises_aft(results, ps){
    var results$0 = results, ps$0 = ps;
    for(;;){
     if(! ps$0) return [0, caml_call1(Stdlib_List[9], results$0)];
     var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
     switch(result[0]){
       case 1:
        return result;
       case 2:
        ps$0 = ps$1; break;
       default:
        var v = result[1], results$1 = [0, v, results$0];
        results$0 = results$1;
        ps$0 = ps$1;
     }
    }
   }
   function nchoose(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_nchoose_would_return_a);
    a:
    {
     b:
     {
      var ps$2 = ps;
      for(;;){
       if(! ps$2) break;
       var ps$3 = ps$2[2], p$0 = ps$2[1], result$0 = underlying(p$0)[1];
       switch(result$0[0]){
         case 1:
          var p$2 = [0, result$0]; break a;
         case 2:
          ps$2 = ps$3; break;
         default: break b;
       }
      }
      var
       p$1 = new_pending([1, ps]),
       callback =
         function(result){
          var
           p = underlying(p$1),
           result$0 = collect_fulfilled_promises_aft(0, ps);
          resolve(_S_, 0, p, result$0);
          return 0;
         };
      add_explicitly_removable_callb$0(ps, callback);
      var p$2 = p$1;
      break a;
     }
     var v$0 = result$0[1], acc$1 = [0, v$0, 0], acc = acc$1, ps$0 = ps$3;
     b:
     for(;;){
      if(! ps$0){var p$2 = return$0(caml_call1(Stdlib_List[9], acc)); break;}
      var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
      switch(result[0]){
        case 1:
         var p$2 = [0, result]; break b;
        case 2:
         ps$0 = ps$1; break;
        default:
         var v = result[1], acc$0 = [0, v, acc]; acc = acc$0; ps$0 = ps$1;
      }
     }
    }
    return p$2;
   }
   function npick(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_npick_would_return_a_p);
    a:
    {
     b:
     {
      var ps$2 = ps;
      for(;;){
       if(! ps$2) break;
       var ps$3 = ps$2[2], p$0 = ps$2[1], result$0 = underlying(p$0)[1];
       switch(result$0[0]){
         case 1:
          caml_call2(Stdlib_List[17], cancel, ps);
          var p$2 = [0, result$0];
          break a;
         case 2:
          ps$2 = ps$3; break;
         default: break b;
       }
      }
      var
       p$1 = new_pending([1, ps]),
       callback =
         function(result){
          var
           p = underlying(p$1),
           result$0 = collect_fulfilled_promises_aft(0, ps);
          caml_call2(Stdlib_List[17], cancel, ps);
          resolve(_T_, 0, p, result$0);
          return 0;
         };
      add_explicitly_removable_callb$0(ps, callback);
      var p$2 = p$1;
      break a;
     }
     var v$0 = result$0[1], acc$1 = [0, v$0, 0], acc = acc$1, ps$0 = ps$3;
     b:
     for(;;){
      if(! ps$0){
       caml_call2(Stdlib_List[17], cancel, ps);
       var p$2 = return$0(caml_call1(Stdlib_List[9], acc));
       break;
      }
      var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
      switch(result[0]){
        case 1:
         caml_call2(Stdlib_List[17], cancel, ps);
         var p$2 = [0, result];
         break b;
        case 2:
         ps$0 = ps$1; break;
        default:
         var v = result[1], acc$0 = [0, v, acc]; acc = acc$0; ps$0 = ps$1;
      }
     }
    }
    return p$2;
   }
   function nchoose_split(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_nchoose_split_would_re);
    a:
    {
     b:
     {
      var pending_acc = 0, ps$2 = ps;
      for(;;){
       if(! ps$2) break;
       var
        ps$3 = ps$2[2],
        p_internal$0 = ps$2[1],
        result$0 = underlying(p_internal$0)[1];
       switch(result$0[0]){
         case 1:
          var p$0 = [0, result$0]; break a;
         case 2:
          var pending_acc$0 = [0, p_internal$0, pending_acc];
          pending_acc = pending_acc$0;
          ps$2 = ps$3;
          break;
         default: break b;
       }
      }
      var
       p = new_pending([1, ps]),
       callback =
         function(result$0){
          var
           to_resolve = underlying(p),
           fulfilled = 0,
           pending = 0,
           ps$0 = ps;
          for(;;){
           if(ps$0){
            var
             ps$1 = ps$0[2],
             p_internal = ps$0[1],
             result = underlying(p_internal)[1];
            switch(result[0]){
              case 1:
               resolve(_U_, 0, to_resolve, result); break;
              case 2:
               var pending$0 = [0, p_internal, pending];
               pending = pending$0;
               ps$0 = ps$1;
               continue;
              default:
               var v = result[1], fulfilled$0 = [0, v, fulfilled];
               fulfilled = fulfilled$0;
               ps$0 = ps$1;
               continue;
            }
           }
           else{
            var _af_ = caml_call1(Stdlib_List[9], pending);
            resolve
             (_V_,
              0,
              to_resolve,
              [0, [0, caml_call1(Stdlib_List[9], fulfilled), _af_]]);
           }
           return 0;
          }
         };
      add_explicitly_removable_callb$0(ps, callback);
      var p$0 = p;
      break a;
     }
     var
      v$0 = result$0[1],
      results$1 = [0, v$0, 0],
      results = results$1,
      pending = pending_acc,
      ps$0 = ps$3;
     b:
     for(;;){
      if(! ps$0){
       var p$0 = return$0([0, caml_call1(Stdlib_List[9], results), pending]);
       break;
      }
      var
       ps$1 = ps$0[2],
       p_internal = ps$0[1],
       result = underlying(p_internal)[1];
      switch(result[0]){
        case 1:
         var p$0 = [0, result]; break b;
        case 2:
         var pending$0 = [0, p_internal, pending];
         pending = pending$0;
         ps$0 = ps$1;
         break;
        default:
         var v = result[1], results$0 = [0, v, results];
         results = results$0;
         ps$0 = ps$1;
      }
     }
    }
    return p$0;
   }
   function state(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; return [1, exn];
      case 2:
       return 0;
      default: var v = match[1]; return [0, v];
    }
   }
   function debug_state_is(expected_state, p){
    return return$0(runtime.caml_equal(state(p), expected_state));
   }
   function is_sleeping(p){
    switch(underlying(p)[1][0]){
      case 1:
       return 0;
      case 2:
       return 1;
      default: return 0;
    }
   }
   function poll(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var e = match[1]; throw caml_maybe_attach_backtrace(e, 0);
      case 2:
       return 0;
      default: var v = match[1]; return [0, v];
    }
   }
   function apply(f, x){
    try{var _ae_ = caml_call1(f, x); return _ae_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap(f){
    try{var _ad_ = return$0(caml_call1(f, 0)); return _ad_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap1(f, x1){
    try{var _ac_ = return$0(caml_call1(f, x1)); return _ac_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap2(f, x1, x2){
    try{var _ab_ = return$0(caml_call2(f, x1, x2)); return _ab_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap3(f, x1, x2, x3){
    try{var _aa_ = return$0(caml_call3(f, x1, x2, x3)); return _aa_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap4(f, x1, x2, x3, x4){
    try{var _$_ = return$0(caml_call4(f, x1, x2, x3, x4)); return _$_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap5(f, x1, x2, x3, x4, x5){
    try{var ___ = return$0(caml_call5(f, x1, x2, x3, x4, x5)); return ___;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap6(f, x1, x2, x3, x4, x5, x6){
    try{var _Z_ = return$0(caml_call6(f, x1, x2, x3, x4, x5, x6)); return _Z_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap7(f, x1, x2, x3, x4, x5, x6, x7){
    try{
     var _Y_ = return$0(caml_call7(f, x1, x2, x3, x4, x5, x6, x7));
     return _Y_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var
    pause_hook = [0, function(_X_){}],
    paused = caml_call1(Lwt_sequence[4], 0),
    _W_ = [0, 0];
   function pause(param){
    var p = add_task_r(paused);
    _W_[1]++;
    caml_call1(pause_hook[1], _W_[1]);
    return p;
   }
   function wakeup_paused(param){
    if(caml_call1(Lwt_sequence[6], paused)){_W_[1] = 0; return 0;}
    var tmp = caml_call1(Lwt_sequence[4], 0);
    caml_call2(Lwt_sequence[16], paused, tmp);
    _W_[1] = 0;
    return caml_call2
            (Lwt_sequence[17], function(r){return wakeup(r, 0);}, tmp);
   }
   function register_pause_notifier(f){pause_hook[1] = f; return 0;}
   function abandon_paused(param){
    caml_call1(Lwt_sequence[5], paused);
    _W_[1] = 0;
    return 0;
   }
   function paused_count(param){return _W_[1];}
   function map(t, f){return symbol(f, t);}
   function bind(t, f){return symbol_bind(t, f);}
   var
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, map, bind, both, Open_on_rhs],
    Let_syntax$0 = [0, Let_syntax];
   function symbol$0(f, p){return symbol_bind(p, f);}
   function symbol$1(p, f){return symbol(f, p);}
   function symbol$2(p$0, p){return join([0, p$0, [0, p, 0]]);}
   function symbol$3(p$0, p){return choose([0, p$0, [0, p, 0]]);}
   var Let_syntax$1 = Let_syntax$0[1];
   function let$0(x, f){return symbol(f, x);}
   var
    Syntax = [0, symbol_bind, both, let$0, both],
    Lwt =
      [0,
       wait,
       wakeup_later,
       wakeup_later_exn,
       return$0,
       fail,
       symbol_bind,
       catch$0,
       finalize,
       try_bind,
       dont_wait,
       async,
       async_exception_hook,
       both,
       join,
       all,
       pick,
       choose,
       npick,
       nchoose,
       nchoose_split,
       Canceled,
       task,
       cancel,
       on_cancel,
       protected$0,
       no_cancel,
       wrap_in_cancelable,
       symbol,
       on_success,
       on_failure,
       on_termination,
       on_any,
       [0,
        symbol_bind,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$0,
        symbol,
        Let_syntax$1],
       Let_syntax$0,
       Syntax,
       return_unit,
       return_none,
       return_nil,
       return_true,
       return_false,
       return_some,
       return_ok,
       return_error,
       fail_with,
       fail_invalid_arg,
       of_result,
       wakeup_later_result,
       state,
       new_key,
       get,
       with_value,
       wakeup,
       wakeup_exn,
       wakeup_result,
       add_task_r,
       add_task_l,
       pause,
       wakeup_paused,
       paused_count,
       register_pause_notifier,
       abandon_paused,
       wrap,
       wrap1,
       wrap2,
       wrap3,
       wrap4,
       wrap5,
       wrap6,
       wrap7,
       symbol_bind,
       symbol$1,
       symbol$3,
       symbol$2,
       symbol$0,
       symbol,
       is_sleeping,
       ignore_result,
       [0, handle_all, handle_all_except_runtime, set, run],
       poll,
       apply,
       backtrace_bind,
       backtrace_catch,
       backtrace_finalize,
       backtrace_try_bind,
       abandon_wakeups,
       debug_state_is];
   runtime.caml_register_global(71, Lwt, "Lwt");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_switch
//# unitInfo: Requires: Lwt, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Off = [248, "Lwt_switch.Off", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, [0, [0, 0]]];}
   function is_on(switch$0){return switch$0[1] ? 1 : 0;}
   function check(param){
    if(param && ! param[1][1]) throw caml_maybe_attach_backtrace(Off, 1);
    return 0;
   }
   function add_hook(switch$0, hook){
    if(! switch$0) return 0;
    var match = switch$0[1][1];
    if(! match) throw caml_maybe_attach_backtrace(Off, 1);
    var os = match[1];
    os[1] = [0, hook, os[1]];
    return 0;
   }
   function add_hook_or_exec(switch$0, hook){
    if(! switch$0) return Lwt[36];
    var match = switch$0[1][1];
    if(! match) return caml_call1(hook, 0);
    var os = match[1];
    os[1] = [0, hook, os[1]];
    return Lwt[36];
   }
   function turn_off(switch$0){
    var _a_ = switch$0[1];
    if(! _a_) return Lwt[36];
    var hooks = _a_[1][1];
    switch$0[1] = 0;
    var
     _b_ =
       caml_call2
        (Stdlib_List[19],
         function(hook){return caml_call2(Lwt[80], hook, 0);},
         hooks);
    return caml_call1(Lwt[14], _b_);
   }
   function with_switch(fn){
    var switch$0 = create(0);
    return caml_call2
            (Lwt[8],
             function(param){return caml_call1(fn, switch$0);},
             function(param){return turn_off(switch$0);});
   }
   var
    Lwt_switch =
      [0,
       create,
       with_switch,
       is_on,
       turn_off,
       Off,
       check,
       add_hook,
       add_hook_or_exec];
   runtime.caml_register_global(3, Lwt_switch, "Lwt_switch");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_seq
//# unitInfo: Requires: Lwt, Stdlib, Stdlib__List, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    return_nil = caml_call1(Lwt[4], 0),
    _h_ =
      [0,
       [11,
        "Lwt_seq.iter_n: max_concurrency must be > 0, ",
        [4, 0, 0, 0, [11, " given", 0]]],
       "Lwt_seq.iter_n: max_concurrency must be > 0, %d given"];
   function empty(param){return return_nil;}
   function return$0(x, param){return caml_call1(Lwt[4], [0, x, empty]);}
   function return_lwt(x, param){
    return caml_call2(Lwt[35][3], x, function(x){return [0, x, empty];});
   }
   function cons(x, t, param){return caml_call1(Lwt[4], [0, x, t]);}
   function cons_lwt(x, t, param){
    return caml_call2(Lwt[35][3], x, function(x){return [0, x, t];});
   }
   function _a_(seq1, seq2, param){
    var _ax_ = caml_call1(seq1, 0);
    return caml_call2
            (Lwt[33][1],
             _ax_,
             function(param){
              if(! param) return caml_call1(seq2, 0);
              var next = param[2], x = param[1];
              return caml_call1
                      (Lwt[4],
                       [0, x, function(_ay_){return _a_(next, seq2, _ay_);}]);
             });
   }
   function append(seq1, seq2, param){
    var _av_ = caml_call2(Lwt[80], seq1, 0);
    return caml_call2
            (Lwt[33][1],
             _av_,
             function(param){
              if(! param) return caml_call1(seq2, 0);
              var next = param[2], x = param[1];
              return caml_call1
                      (Lwt[4],
                       [0, x, function(_aw_){return _a_(next, seq2, _aw_);}]);
             });
   }
   function _b_(f, seq, param){
    var _at_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][2],
             _at_,
             function(param){
              if(! param) return 0;
              var next = param[2], x = param[1], x$0 = caml_call1(f, x);
              return [0, x$0, function(_au_){return _b_(f, next, _au_);}];
             });
   }
   function map(f, seq, param){
    var _ar_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][2],
             _ar_,
             function(param){
              if(! param) return 0;
              var next = param[2], x = param[1], x$0 = caml_call1(f, x);
              return [0, x$0, function(_as_){return _b_(f, next, _as_);}];
             });
   }
   function _c_(f, seq, param){
    var _ao_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _ao_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _ap_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][3],
                       _ap_,
                       function(x){
                        return [0, x, function(_aq_){return _c_(f, next, _aq_);}];
                       });
             });
   }
   function map_s(f, seq, param){
    var _al_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _al_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _am_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][3],
                       _am_,
                       function(x){
                        return [0, x, function(_an_){return _c_(f, next, _an_);}];
                       });
             });
   }
   function _d_(f, seq, param){
    var _aj_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _aj_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], x$0 = caml_call1(f, x);
              if(! x$0) return _d_(f, next, 0);
              var y = x$0[1];
              return caml_call1
                      (Lwt[4], [0, y, function(_ak_){return _d_(f, next, _ak_);}]);
             });
   }
   function filter_map(f, seq, param){
    var _ah_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _ah_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], x$0 = caml_call1(f, x);
              if(! x$0) return _d_(f, next, 0);
              var y = x$0[1];
              return caml_call1
                      (Lwt[4], [0, y, function(_ai_){return _d_(f, next, _ai_);}]);
             });
   }
   function _e_(f, seq, param){
    var _ae_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _ae_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _af_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1],
                       _af_,
                       function(x){
                        if(! x) return _e_(f, next, 0);
                        var y = x[1];
                        return caml_call1
                                (Lwt[4], [0, y, function(_ag_){return _e_(f, next, _ag_);}]);
                       });
             });
   }
   function filter_map_s(f, seq, param){
    var _ab_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _ab_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _ac_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1],
                       _ac_,
                       function(x){
                        if(! x) return _e_(f, next, 0);
                        var y = x[1];
                        return caml_call1
                                (Lwt[4], [0, y, function(_ad_){return _e_(f, next, _ad_);}]);
                       });
             });
   }
   function _f_(f, seq, param){
    var _$_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _$_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], ok = caml_call1(f, x);
              return ok
                      ? caml_call1
                        (Lwt[4], [0, x, function(_aa_){return _f_(f, next, _aa_);}])
                      : _f_(f, next, 0);
             });
   }
   function filter(f, seq, param){
    var _Z_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _Z_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], ok = caml_call1(f, x);
              return ok
                      ? caml_call1
                        (Lwt[4], [0, x, function(___){return _f_(f, next, ___);}])
                      : _f_(f, next, 0);
             });
   }
   function _g_(f, seq, param){
    var _W_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _W_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _X_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1],
                       _X_,
                       function(ok){
                        return ok
                                ? caml_call1
                                  (Lwt[4], [0, x, function(_Y_){return _g_(f, next, _Y_);}])
                                : _g_(f, next, 0);
                       });
             });
   }
   function filter_s(f, seq, param){
    var _T_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _T_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _U_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1],
                       _U_,
                       function(ok){
                        return ok
                                ? caml_call1
                                  (Lwt[4], [0, x, function(_V_){return _g_(f, next, _V_);}])
                                : _g_(f, next, 0);
                       });
             });
   }
   function flat_map_app(f, seq, tail, param){
    var _Q_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _Q_,
             function(param){
              if(param){
               var next = param[2], x = param[1];
               return caml_call1
                       (Lwt[4],
                        [0,
                         x,
                         function(_S_){return flat_map_app(f, next, tail, _S_);}]);
              }
              var _R_ = caml_call1(tail, 0);
              return caml_call2
                      (Lwt[33][1],
                       _R_,
                       function(param){
                        if(! param) return return_nil;
                        var next = param[2], x = param[1];
                        return flat_map_app(f, caml_call1(f, x), next, 0);
                       });
             });
   }
   function flat_map(f, seq, param){
    var _P_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _P_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1];
              return flat_map_app(f, caml_call1(f, x), next, 0);
             });
   }
   function fold_left(f, acc, seq){
    function aux(f, acc, seq){
     var _O_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _O_,
              function(param){
               if(! param) return caml_call1(Lwt[4], acc);
               var
                next = param[2],
                x = param[1],
                acc$0 = caml_call2(f, acc, x);
               return aux(f, acc$0, next);
              });
    }
    var _N_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _N_,
             function(param){
              if(! param) return caml_call1(Lwt[4], acc);
              var
               next = param[2],
               x = param[1],
               acc$0 = caml_call2(f, acc, x);
              return aux(f, acc$0, next);
             });
   }
   function fold_left_s(f, acc, seq){
    function aux(f, acc, seq){
     var _L_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _L_,
              function(param){
               if(! param) return caml_call1(Lwt[4], acc);
               var next = param[2], x = param[1], _M_ = caml_call2(f, acc, x);
               return caml_call2
                       (Lwt[35][1], _M_, function(acc){return aux(f, acc, next);});
              });
    }
    var _J_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _J_,
             function(param){
              if(! param) return caml_call1(Lwt[4], acc);
              var next = param[2], x = param[1], _K_ = caml_call2(f, acc, x);
              return caml_call2
                      (Lwt[35][1], _K_, function(acc){return aux(f, acc, next);});
             });
   }
   function iter(f, seq){
    function aux(seq){
     var _I_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _I_,
              function(param){
               if(! param) return Lwt[36];
               var next = param[2], x = param[1];
               caml_call1(f, x);
               return aux(next);
              });
    }
    var _H_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _H_,
             function(param){
              if(! param) return Lwt[36];
              var next = param[2], x = param[1];
              caml_call1(f, x);
              return aux(next);
             });
   }
   function iter_s(f, seq){
    function aux(seq){
     var _F_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _F_,
              function(param){
               if(! param) return Lwt[36];
               var next = param[2], x = param[1], _G_ = caml_call1(f, x);
               return caml_call2
                       (Lwt[35][1], _G_, function(param){return aux(next);});
              });
    }
    var _D_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _D_,
             function(param){
              if(! param) return Lwt[36];
              var next = param[2], x = param[1], _E_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1], _E_, function(param){return aux(next);});
             });
   }
   function iter_p(f, seq){
    function aux(acc, seq){
     var _C_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _C_,
              function(param){
               if(! param) return caml_call1(Lwt[14], acc);
               var next = param[2], x = param[1], p = caml_call1(f, x);
               return aux([0, p, acc], next);
              });
    }
    var acc = 0, _B_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _B_,
             function(param){
              if(! param) return caml_call1(Lwt[14], acc);
              var next = param[2], x = param[1], p = caml_call1(f, x);
              return aux([0, p, acc], next);
             });
   }
   function iter_n(opt, f, seq){
    if(opt)
     var sth = opt[1], max_concurrency = sth;
    else
     var max_concurrency = 1;
    if(max_concurrency <= 0){
     var message = caml_call2(Stdlib_Printf[4], _h_, max_concurrency);
     caml_call1(Stdlib[1], message);
    }
    function loop(running, available, seq){
     function _w_(param){
      var available = param[2], running = param[1], _A_ = caml_call1(seq, 0);
      return caml_call2
              (Lwt[33][1],
               _A_,
               function(param){
                if(! param) return caml_call1(Lwt[14], running);
                var seq = param[2], elt = param[1];
                return loop
                        ([0, caml_call1(f, elt), running], available - 1 | 0, seq);
               });
     }
     if(0 < available)
      var _x_ = caml_call1(Lwt[4], [0, running, available]);
     else
      var
       _y_ = caml_call1(Lwt[20], running),
       _x_ =
         caml_call2
          (Lwt[33][1],
           _y_,
           function(param){
            var
             running = param[2],
             complete = param[1],
             _z_ =
               [0,
                running,
                available + caml_call1(Stdlib_List[1], complete) | 0];
            return caml_call1(Lwt[4], _z_);
           });
     return caml_call2(Lwt[33][1], _x_, _w_);
    }
    return loop
            (0,
             max_concurrency,
             function(param){return caml_call2(Lwt[80], seq, 0);});
   }
   function unfold(f, u, param){
    try{var val = caml_call1(f, u);}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0);
     if(caml_call1(Lwt[78][4], exc))
      throw caml_maybe_attach_backtrace(exc, 0);
     throw caml_maybe_attach_backtrace(exc, 0);
    }
    if(! val) return return_nil;
    var match = val[1], u$0 = match[2], x = match[1];
    return caml_call1
            (Lwt[4], [0, x, function(_v_){return unfold(f, u$0, _v_);}]);
   }
   function _i_(f, u, param){
    var _t_ = caml_call1(f, u);
    return caml_call2
            (Lwt[35][1],
             _t_,
             function(x){
              if(! x) return return_nil;
              var match = x[1], u = match[2], x$0 = match[1];
              return caml_call1
                      (Lwt[4], [0, x$0, function(_u_){return _i_(f, u, _u_);}]);
             });
   }
   function unfold_lwt(f, u, param){
    var _r_ = caml_call2(Lwt[80], f, u);
    return caml_call2
            (Lwt[35][1],
             _r_,
             function(x){
              if(! x) return return_nil;
              var match = x[1], u = match[2], x$0 = match[1];
              return caml_call1
                      (Lwt[4], [0, x$0, function(_s_){return _i_(f, u, _s_);}]);
             });
   }
   function of_list(l, param){
    if(l)
     var
      t = l[2],
      h = l[1],
      _p_ = [0, h, function(_q_){return of_list(t, _q_);}];
    else
     var _p_ = 0;
    return caml_call1(Lwt[4], _p_);
   }
   function to_list(seq){
    function aux(f, seq){
     var _n_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[6],
              _n_,
              function(param){
               if(param){
                var t = param[2], h = param[1];
                return aux(function(x){return caml_call1(f, [0, h, x]);}, t);
               }
               var _o_ = caml_call1(f, 0);
               return caml_call1(Lwt[4], _o_);
              });
    }
    return aux(function(x){return x;}, caml_call1(Lwt[80], seq));
   }
   function of_seq(seq, param){
    try{var val = caml_call1(seq, 0);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(caml_call1(Lwt[78][4], exn))
      throw caml_maybe_attach_backtrace(exn, 0);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    if(! val) return return_nil;
    var next = val[2], x = val[1];
    return caml_call1
            (Lwt[4], [0, x, function(_m_){return of_seq(next, _m_);}]);
   }
   function _j_(seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return return_nil;
    var next = match[2], x = match[1];
    return caml_call2
            (Lwt[35][3],
             x,
             function(x){
              function next$0(_l_){return _j_(next, _l_);}
              return [0, x, next$0];
             });
   }
   function of_seq_lwt(seq, param){
    try{var val = caml_call1(seq, 0);}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0);
     if(caml_call1(Lwt[78][4], exc))
      throw caml_maybe_attach_backtrace(exc, 0);
     throw caml_maybe_attach_backtrace(exc, 0);
    }
    if(! val) return return_nil;
    var next = val[2], x = val[1];
    return caml_call2
            (Lwt[35][3],
             x,
             function(x){
              function next$0(_k_){return _j_(next, _k_);}
              return [0, x, next$0];
             });
   }
   var
    Lwt_seq =
      [0,
       empty,
       return$0,
       return_lwt,
       cons,
       cons_lwt,
       append,
       map,
       map_s,
       filter,
       filter_s,
       filter_map,
       filter_map_s,
       flat_map,
       fold_left,
       fold_left_s,
       iter,
       iter_s,
       iter_p,
       iter_n,
       unfold,
       unfold_lwt,
       to_list,
       of_list,
       of_seq,
       of_seq_lwt];
   runtime.caml_register_global(5, Lwt_seq, "Lwt_seq");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_stream
//# unitInfo: Requires: CamlinternalOO, Lwt, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__List, Stdlib__Printf, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$6 = "",
    cst_blocked = "blocked",
    cst_close = "close",
    cst_closed = "closed",
    cst_count = "count",
    cst_push = "push",
    cst_resize = "resize",
    cst_set_reference = "set_reference",
    cst_size = "size",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    cst$3 = "    ",
    cst$4 = "   ",
    cst$5 = " |",
    cst = cst$6,
    cst$0 = cst$6,
    cst$1 = cst$6,
    cst$2 = cst$6,
    shared =
      [0,
       cst_size,
       cst_set_reference,
       cst_resize,
       cst_push,
       cst_count,
       cst_closed,
       cst_close,
       cst_blocked,
       "*dummy method*"],
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    CamlinternalOO = global_data.CamlinternalOO,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Array = global_data.Stdlib__Array,
    Closed = [248, "Lwt_stream.Closed", caml_fresh_oo_id(0)],
    Full = [248, "Lwt_stream.Full", caml_fresh_oo_id(0)],
    Empty = [248, "Lwt_stream.Empty", caml_fresh_oo_id(0)],
    _a_ = [0, cst_closed],
    cst_Lwt_stream_clone = "Lwt_stream.clone",
    cst_Lwt_stream_bounded_push_re = "Lwt_stream.bounded_push#resize";
   function new_node(param){
    var node = [];
    runtime.caml_update_dummy(node, [0, node, 0]);
    return node;
   }
   function clone(s){
    if(3 === s[1][0]) caml_call1(Stdlib[1], cst_Lwt_stream_clone);
    return [0, s[1], s[2], s[3], s[4], s[5]];
   }
   function from_source(source){
    var
     node = new_node(0),
     match = caml_call1(Lwt[1], 0),
     close = match[2],
     closed = match[1];
    return [0, source, close, closed, node, [0, node]];
   }
   function from(f){return from_source([0, [0, f, Lwt[36]]]);}
   function from_direct(f){return from_source([1, f]);}
   function closed(s){return s[3];}
   function is_closed(s){return 1 - caml_call1(Lwt[76], s[3]);}
   function enqueue(e, last){
    var node = last[1], new_last = new_node(0);
    node[2] = e;
    node[1] = new_last;
    last[1] = new_last;
   }
   function enqueue$0(e, s){return enqueue(e, s[5]);}
   function create_with_reference(param){
    var
     match = caml_call1(Lwt[1], 0),
     push_signal_resolver = match[2],
     push_signal = match[1],
     push_signal_resolver$0 = [0, push_signal_resolver],
     source = [0, push_signal, 0, 0],
     t = from_source([2, source]),
     close = t[2],
     closed = t[3],
     last = t[5];
    function push(x){
     if(1 - caml_call1(Lwt[76], closed))
      throw caml_maybe_attach_backtrace(Closed, 1);
     enqueue(x, last);
     if(source[2]){
      source[2] = 0;
      var
       old_push_signal_resolver = push_signal_resolver$0[1],
       match = caml_call1(Lwt[1], 0),
       new_push_signal_resolver = match[2],
       new_waiter = match[1];
      source[1] = new_waiter;
      push_signal_resolver$0[1] = new_push_signal_resolver;
      caml_call2(Lwt[2], old_push_signal_resolver, 0);
     }
     var _aH_ = 0 === x ? 1 : 0;
     return _aH_ ? caml_call2(Lwt[52], close, 0) : _aH_;
    }
    return [0, t, push, function(x){source[3] = x; return 0;}];
   }
   function return$0(a){
    var match = create_with_reference(0), push = match[2], stream = match[1];
    caml_call1(push, [0, a]);
    caml_call1(push, 0);
    return stream;
   }
   function return_lwt(a){
    var match = create_with_reference(0), push = match[2], source = match[1];
    caml_call2
     (Lwt[10],
      function(param){
       return caml_call2
               (Lwt[6],
                a,
                function(x){
                 caml_call1(push, [0, x]);
                 caml_call1(push, 0);
                 return Lwt[36];
                });
      },
      function(exc){return caml_call1(push, 0);});
    return source;
   }
   function of_seq(s){
    var s$0 = [0, s];
    function get(param){
     var match = caml_call1(s$0[1], 0);
     if(! match) return 0;
     var s = match[2], elt = match[1];
     s$0[1] = s;
     return [0, elt];
    }
    return from_direct(get);
   }
   function of_lwt_seq(s){
    var s$0 = [0, s];
    function get(param){
     var _aG_ = caml_call1(s$0[1], 0);
     return caml_call2
             (Lwt[33][2],
              _aG_,
              function(param){
               if(! param) return 0;
               var s = param[2], elt = param[1];
               s$0[1] = s;
               return [0, elt];
              });
    }
    return from(get);
   }
   function create(param){
    var match = create_with_reference(0), push = match[2], source = match[1];
    return [0, source, push];
   }
   function of_iter(iter, i){
    var match = create(0), push = match[2], stream = match[1];
    caml_call2(iter, function(x){return caml_call1(push, [0, x]);}, i);
    caml_call1(push, 0);
    return stream;
   }
   function of_list(l){return of_iter(Stdlib_List[17], l);}
   function of_array(a){return of_iter(Stdlib_Array[13], a);}
   function of_string(s){return of_iter(Stdlib_String[29], s);}
   function notify_pusher(info, last){
    enqueue(info[5], last);
    info[5] = 0;
    var
     old_wakener = info[7],
     match = caml_call1(Lwt[22], 0),
     wakener = match[2],
     waiter = match[1];
    info[6] = waiter;
    info[7] = wakener;
    return caml_call2(Lwt[2], old_wakener, 0);
   }
   var
    bounded_push_impl =
      caml_call2
       (CamlinternalOO[19],
        [0,
         cst_blocked,
         cst_close,
         cst_push,
         cst_count,
         cst_size,
         cst_set_reference,
         cst_resize,
         cst_closed],
        function(_ap_){
         var
          _aq_ = caml_call2(CamlinternalOO[3], _ap_, cst),
          _ar_ = caml_call2(CamlinternalOO[3], _ap_, cst$0),
          _as_ = caml_call2(CamlinternalOO[3], _ap_, cst$1),
          _at_ = caml_call2(CamlinternalOO[3], _ap_, cst$2),
          _au_ = caml_call3(CamlinternalOO[4], _ap_, shared, _a_),
          _av_ = _au_[10];
         caml_call2
          (CamlinternalOO[11],
           _ap_,
           [0,
            _au_[1],
            function(self_1){return self_1[1 + _aq_][3];},
            _au_[3],
            function(self_1, size){
             if(size < 0)
              caml_call1(Stdlib[1], cst_Lwt_stream_bounded_push_re);
             self_1[1 + _aq_][3] = size;
             var
              _aE_ = self_1[1 + _aq_][4] < self_1[1 + _aq_][3] ? 1 : 0,
              _aF_ = _aE_ ? 0 !== self_1[1 + _aq_][5] ? 1 : 0 : _aE_;
             return _aF_
                     ? (self_1
                         [1 + _aq_]
                        [4]
                       = self_1[1 + _aq_][4] + 1 | 0,
                       notify_pusher(self_1[1 + _aq_], self_1[1 + _as_]))
                     : _aF_;
            },
            _au_[4],
            function(self_1, x){
             if(self_1[1 + _av_]) return caml_call1(Lwt[5], Closed);
             if(0 !== self_1[1 + _aq_][5]) return caml_call1(Lwt[5], Full);
             if(self_1[1 + _aq_][3] <= self_1[1 + _aq_][4]){
              self_1[1 + _aq_][5] = [0, x];
              return caml_call2
                      (Lwt[7],
                       function(param){return self_1[1 + _aq_][6];},
                       function(exn){
                        if(exn !== Lwt[21])
                         throw caml_maybe_attach_backtrace(exn, 0);
                        self_1[1 + _aq_][5] = 0;
                        var
                         match = caml_call1(Lwt[22], 0),
                         wakener = match[2],
                         waiter = match[1];
                        self_1[1 + _aq_][6] = waiter;
                        self_1[1 + _aq_][7] = wakener;
                        throw caml_maybe_attach_backtrace(exn, 0);
                       });
             }
             enqueue([0, x], self_1[1 + _as_]);
             self_1[1 + _aq_][4] = self_1[1 + _aq_][4] + 1 | 0;
             if(self_1[1 + _aq_][2]){
              self_1[1 + _aq_][2] = 0;
              var
               old_wakener = self_1[1 + _ar_][1],
               match = caml_call1(Lwt[1], 0),
               new_wakener = match[2],
               new_waiter = match[1];
              self_1[1 + _aq_][1] = new_waiter;
              self_1[1 + _ar_][1] = new_wakener;
              caml_call2(Lwt[2], old_wakener, 0);
             }
             return Lwt[36];
            },
            _au_[7],
            function(self_1){
             var _aD_ = 1 - self_1[1 + _av_];
             if(! _aD_) return _aD_;
             self_1[1 + _av_] = 1;
             var node = self_1[1 + _as_][1], new_last = new_node(0);
             node[2] = 0;
             node[1] = new_last;
             self_1[1 + _as_][1] = new_last;
             if(0 !== self_1[1 + _aq_][5]){
              self_1[1 + _aq_][5] = 0;
              caml_call2(Lwt[3], self_1[1 + _aq_][7], Closed);
             }
             if(self_1[1 + _aq_][2]){
              self_1[1 + _aq_][2] = 0;
              var old_wakener = self_1[1 + _ar_][1];
              caml_call2(Lwt[2], old_wakener, 0);
             }
             return caml_call2(Lwt[52], self_1[1 + _at_], 0);
            },
            _au_[5],
            function(self_1){return self_1[1 + _aq_][4];},
            _au_[8],
            function(self_1){return 0 !== self_1[1 + _aq_][5] ? 1 : 0;},
            _au_[6],
            function(self_1){return self_1[1 + _av_];},
            _au_[2],
            function(self_1, x){self_1[1 + _aq_][8] = x; return 0;}]);
         return function(_aB_, _aA_, _az_, _ay_, _ax_, _aw_){
          var _aC_ = caml_call2(CamlinternalOO[24], _aA_, _ap_);
          _aC_[1 + _at_] = _aw_;
          _aC_[1 + _as_] = _ax_;
          _aC_[1 + _ar_] = _ay_;
          _aC_[1 + _aq_] = _az_;
          _aC_[1 + _av_] = 0;
          return _aC_;};
        }),
    cst_Lwt_stream_create_bounded = "Lwt_stream.create_bounded",
    _b_ =
      [0,
       [11,
        "Lwt_stream.iter_n: max_concurrency must be > 0, ",
        [4, 0, 0, 0, [11, " given", 0]]],
       "Lwt_stream.iter_n: max_concurrency must be > 0, %d given"],
    cst_Lwt_stream_parse = "Lwt_stream.parse",
    _c_ = [0, [4, 6, [0, 2, 8], 0, [11, "|  ", 0]], "%08x|  "],
    _d_ = [0, [4, 6, [0, 2, 2], 0, [12, 32, 0]], "%02x "];
   function create_bounded(size){
    if(size < 0) caml_call1(Stdlib[1], cst_Lwt_stream_create_bounded);
    var
     match = caml_call1(Lwt[1], 0),
     wakener = match[2],
     waiter = match[1],
     match$0 = caml_call1(Lwt[22], 0),
     push_wakener = match$0[2],
     push_waiter = match$0[1],
     wakener_cell = [0, wakener],
     info = [0, waiter, 0, size, 0, 0, push_waiter, push_wakener, 0],
     t = from_source([3, info]);
    return [0,
            t,
            caml_call5
             (bounded_push_impl[1], 0, info, wakener_cell, t[5], t[2])];
   }
   function feed(s){
    var match = s[1];
    switch(match[0]){
      case 0:
       var from = match[1];
       if(caml_call1(Lwt[76], from[2])) return caml_call1(Lwt[25], from[2]);
       var
        thread =
          caml_call2
           (Lwt[7],
            function(param){
             var _ao_ = caml_call1(from[1], 0);
             return caml_call2
                     (Lwt[33][1],
                      _ao_,
                      function(x){
                       enqueue$0(x, s);
                       if(0 === x) caml_call2(Lwt[52], s[2], 0);
                       return Lwt[36];
                      });
            },
            function(_an_){throw caml_maybe_attach_backtrace(_an_, 0);});
       from[2] = thread;
       return caml_call1(Lwt[25], thread);
      case 1:
       var f = match[1], x = caml_call1(f, 0);
       enqueue$0(x, s);
       if(0 === x) caml_call2(Lwt[52], s[2], 0);
       return Lwt[36];
      case 2:
       var push = match[1]; push[2] = 1; return caml_call1(Lwt[25], push[1]);
      default:
       var push$0 = match[1];
       push$0[2] = 1;
       return caml_call1(Lwt[25], push$0[1]);
    }
   }
   function consume(s, node){
    var _am_ = node === s[4] ? 1 : 0;
    if(! _am_) return _am_;
    s[4] = node[1];
    var match = s[1];
    if(3 !== match[0]) return;
    var info = match[1];
    if(0 !== info[5]) return notify_pusher(info, s[5]);
    info[4] = info[4] - 1 | 0;
   }
   function peek_rec(s, node){
    if(node !== s[5][1]) return caml_call1(Lwt[4], node[2]);
    var _al_ = feed(s);
    return caml_call2
            (Lwt[33][1], _al_, function(param){return peek_rec(s, node);});
   }
   function peek(s){return peek_rec(s, s[4]);}
   function npeek_rec(node, acc, n, s){
    var node$0 = node, acc$0 = acc, n$0 = n;
    for(;;){
     if(0 >= n$0){
      var _ak_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _ak_);
     }
     if(node$0 === s[5][1]){
      var _ai_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _ai_,
               function(param){return npeek_rec(node$0, acc$0, n$0, s);});
     }
     var match = node$0[2];
     if(! match){
      var _aj_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _aj_);
     }
     var
      x = match[1],
      n$1 = n$0 - 1 | 0,
      acc$1 = [0, x, acc$0],
      node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
     n$0 = n$1;
    }
   }
   function npeek(n, s){return npeek_rec(s[4], 0, n, s);}
   function get_rec(s, node){
    if(node === s[5][1]){
     var _ah_ = feed(s);
     return caml_call2
             (Lwt[33][1], _ah_, function(param){return get_rec(s, node);});
    }
    if(0 !== node[2]) consume(s, node);
    return caml_call1(Lwt[4], node[2]);
   }
   function get(s){return get_rec(s, s[4]);}
   function get_exn_rec(s, node){
    if(node === s[5][1])
     return caml_call3
             (Lwt[9],
              function(param){return feed(s);},
              function(param){return get_exn_rec(s, node);},
              function(exn){return caml_call1(Lwt[4], [0, [1, exn]]);});
    var match = node[2];
    if(! match) return Lwt[37];
    var value = match[1];
    consume(s, node);
    return caml_call1(Lwt[4], [0, [0, value]]);
   }
   function wrap_exn(s){
    return from(function(param){return get_exn_rec(s, s[4]);});
   }
   function nget_rec(node, acc, n, s){
    var node$0 = node, acc$0 = acc, n$0 = n;
    for(;;){
     if(0 >= n$0){
      var _ag_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _ag_);
     }
     if(node$0 === s[5][1]){
      var _ae_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _ae_,
               function(param){return nget_rec(node$0, acc$0, n$0, s);});
     }
     var match = s[4][2];
     if(! match){
      var _af_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _af_);
     }
     var x = match[1];
     consume(s, node$0);
     var n$1 = n$0 - 1 | 0, acc$1 = [0, x, acc$0], node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
     n$0 = n$1;
    }
   }
   function nget(n, s){return nget_rec(s[4], 0, n, s);}
   function get_while_rec(node, acc, f, s){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var _ab_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _ab_,
               function(param){return get_while_rec(node$0, acc$0, f, s);});
     }
     var match = node$0[2];
     if(! match){
      var _ad_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _ad_);
     }
     var x = match[1], test = caml_call1(f, x);
     if(! test){
      var _ac_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _ac_);
     }
     consume(s, node$0);
     var acc$1 = [0, x, acc$0], node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
    }
   }
   function get_while(f, s){return get_while_rec(s[4], 0, f, s);}
   function get_while_s_rec(node, acc, f, s){
    if(node === s[5][1]){
     var _Z_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _Z_,
              function(param){return get_while_s_rec(node, acc, f, s);});
    }
    var match = node[2];
    if(match){
     var x = match[1], ___ = caml_call1(f, x);
     return caml_call2
             (Lwt[33][1],
              ___,
              function(param){
               if(param){
                consume(s, node);
                return get_while_s_rec(node[1], [0, x, acc], f, s);
               }
               var _aa_ = caml_call1(Stdlib_List[9], acc);
               return caml_call1(Lwt[4], _aa_);
              });
    }
    var _$_ = caml_call1(Stdlib_List[9], acc);
    return caml_call1(Lwt[4], _$_);
   }
   function get_while_s(f, s){return get_while_s_rec(s[4], 0, f, s);}
   function next_rec(s, node){
    if(node === s[5][1]){
     var _Y_ = feed(s);
     return caml_call2
             (Lwt[33][1], _Y_, function(param){return next_rec(s, node);});
    }
    var match = node[2];
    if(! match) return caml_call1(Lwt[5], Empty);
    var x = match[1];
    consume(s, node);
    return caml_call1(Lwt[4], x);
   }
   function next(s){return next_rec(s, s[4]);}
   function last_new_rec(node, x, s){
    var node$0 = node, x$0 = x;
    for(;;)
     if(node$0 === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Lwt[4], x$0);
      if(0 !== match[0]){var exn = match[1]; return caml_call1(Lwt[5], exn);}
     }
     else{
      var match$0 = node$0[2];
      if(! match$0) return caml_call1(Lwt[4], x$0);
      var x$1 = match$0[1];
      consume(s, node$0);
      var node$1 = node$0[1];
      node$0 = node$1;
      x$0 = x$1;
     }
   }
   function last_new(s){
    var node = s[4];
    if(node !== s[5][1]){
     var match$0 = node[2];
     if(! match$0) return caml_call1(Lwt[5], Empty);
     var x$0 = match$0[1];
     consume(s, node);
     return last_new_rec(node[1], x$0, s);
    }
    var thread = next(s), match = caml_call1(Lwt[48], thread);
    if(typeof match !== "number" && 0 === match[0]){
     var x = match[1];
     return last_new_rec(node, x, s);
    }
    return thread;
   }
   function to_list_rec(node, acc, s){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var _W_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _W_,
               function(param){return to_list_rec(node$0, acc$0, s);});
     }
     var match = node$0[2];
     if(! match){
      var _X_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _X_);
     }
     var x = match[1];
     consume(s, node$0);
     var acc$1 = [0, x, acc$0], node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
    }
   }
   function to_list(s){return to_list_rec(s[4], 0, s);}
   function to_string_rec(node, buf, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _U_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _U_,
               function(param){return to_string_rec(node$0, buf, s);});
     }
     var match = node$0[2];
     if(! match){
      var _V_ = caml_call1(Stdlib_Buffer[2], buf);
      return caml_call1(Lwt[4], _V_);
     }
     var x = match[1];
     consume(s, node$0);
     caml_call2(Stdlib_Buffer[12], buf, x);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function to_string(s){
    var _T_ = caml_call1(Stdlib_Buffer[1], 128);
    return to_string_rec(s[4], _T_, s);
   }
   function junk(s){
    var node = s[4];
    if(node === s[5][1]){
     var _S_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _S_,
              function(param){
               if(0 !== node[2]) consume(s, node);
               return Lwt[36];
              });
    }
    if(0 !== node[2]) consume(s, node);
    return Lwt[36];
   }
   function njunk_rec(node, n, s){
    var node$0 = node, n$0 = n;
    for(;;){
     if(0 >= n$0) return Lwt[36];
     if(node$0 === s[5][1]){
      var _R_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _R_,
               function(param){return njunk_rec(node$0, n$0, s);});
     }
     if(! node$0[2]) return Lwt[36];
     consume(s, node$0);
     var n$1 = n$0 - 1 | 0, node$1 = node$0[1];
     node$0 = node$1;
     n$0 = n$1;
    }
   }
   function njunk(n, s){return njunk_rec(s[4], n, s);}
   function junk_while_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _Q_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _Q_,
               function(param){return junk_while_rec(node$0, f, s);});
     }
     var match = node$0[2];
     if(! match) return Lwt[36];
     var x = match[1], test = caml_call1(f, x);
     if(! test) return Lwt[36];
     consume(s, node$0);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function junk_while(f, s){return junk_while_rec(s[4], f, s);}
   function junk_while_s_rec(node, f, s){
    if(node === s[5][1]){
     var _O_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _O_,
              function(param){return junk_while_s_rec(node, f, s);});
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1], _P_ = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             _P_,
             function(param){
              return param
                      ? (consume(s, node), junk_while_s_rec(node[1], f, s))
                      : Lwt[36];
             });
   }
   function junk_while_s(f, s){return junk_while_s_rec(s[4], f, s);}
   function junk_available(s){
    var node$1 = s[4], node = node$1;
    for(;;)
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var exn = match[1];
       throw caml_maybe_attach_backtrace(exn, 1);
      }
     }
     else{
      if(! node[2]) return 0;
      consume(s, node);
      var node$0 = node[1];
      node = node$0;
     }
   }
   function junk_old(s){
    var _N_ = junk_available(s);
    return caml_call1(Lwt[4], _N_);
   }
   function get_available(s){
    var node$1 = s[4], node = node$1, acc = 0;
    for(;;)
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Stdlib_List[9], acc);
      if(0 !== match[0]){
       var exn = match[1];
       throw caml_maybe_attach_backtrace(exn, 1);
      }
     }
     else{
      var match$0 = node[2];
      if(! match$0) return caml_call1(Stdlib_List[9], acc);
      var x = match$0[1];
      consume(s, node);
      var acc$0 = [0, x, acc], node$0 = node[1];
      node = node$0;
      acc = acc$0;
     }
   }
   function get_available_up_to(n$1, s){
    var node$1 = s[4], node = node$1, acc = 0, n = n$1;
    for(;;){
     if(0 >= n) return caml_call1(Stdlib_List[9], acc);
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Stdlib_List[9], acc);
      if(0 !== match[0]){
       var exn = match[1];
       throw caml_maybe_attach_backtrace(exn, 1);
      }
     }
     else{
      var match$0 = s[4][2];
      if(! match$0) return caml_call1(Stdlib_List[9], acc);
      var x = match$0[1];
      consume(s, node);
      var n$0 = n - 1 | 0, acc$0 = [0, x, acc], node$0 = node[1];
      node = node$0;
      acc = acc$0;
      n = n$0;
     }
    }
   }
   function is_empty(s){
    if(s[4] !== s[5][1]) return caml_call1(Lwt[4], 0 === s[4][2] ? 1 : 0);
    var _M_ = feed(s);
    return caml_call2(Lwt[33][1], _M_, function(param){return is_empty(s);});
   }
   function map(f, s){
    return from
            (function(param){
              var _L_ = get(s);
              return caml_call2
                      (Lwt[33][2],
                       _L_,
                       function(param){
                        if(! param) return 0;
                        var x = param[1], x$0 = caml_call1(f, x);
                        return [0, x$0];
                       });
             });
   }
   function map_s(f, s){
    return from
            (function(param){
              var _J_ = get(s);
              return caml_call2
                      (Lwt[33][1],
                       _J_,
                       function(param){
                        if(! param) return Lwt[37];
                        var x = param[1], _K_ = caml_call1(f, x);
                        return caml_call2
                                (Lwt[33][2], _K_, function(x){return [0, x];});
                       });
             });
   }
   function filter(f, s){
    function next(param){
     var t = get(s);
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], test = caml_call1(f, x);
               return test ? t : next(0);
              });
    }
    return from(next);
   }
   function filter_s(f, s){
    function next(param){
     var t = get(s);
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               if(! param) return t;
               var x = param[1], _I_ = caml_call1(f, x);
               return caml_call2
                       (Lwt[33][1],
                        _I_,
                        function(param){return param ? t : next(0);});
              });
    }
    return from(next);
   }
   function filter_map(f, s){
    function next(param){
     var _H_ = get(s);
     return caml_call2
             (Lwt[33][1],
              _H_,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], x$0 = caml_call1(f, x);
               return x$0 ? caml_call1(Lwt[4], x$0) : next(0);
              });
    }
    return from(next);
   }
   function filter_map_s(f, s){
    function next(param){
     var _G_ = get(s);
     return caml_call2
             (Lwt[33][1],
              _G_,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], t = caml_call1(f, x);
               return caml_call2
                       (Lwt[33][1],
                        t,
                        function(param){return param ? t : next(0);});
              });
    }
    return from(next);
   }
   function map_list(f, s){
    var pendings = [0, 0];
    function next(param){
     var match = pendings[1];
     if(match){
      var l = match[2], x = match[1];
      pendings[1] = l;
      return caml_call1(Lwt[4], [0, x]);
     }
     var _F_ = get(s);
     return caml_call2
             (Lwt[33][1],
              _F_,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], l = caml_call1(f, x);
               pendings[1] = l;
               return next(0);
              });
    }
    return from(next);
   }
   function map_list_s(f, s){
    var pendings = [0, 0];
    function next(param){
     var match = pendings[1];
     if(match){
      var l = match[2], x = match[1];
      pendings[1] = l;
      return caml_call1(Lwt[4], [0, x]);
     }
     var _D_ = get(s);
     return caml_call2
             (Lwt[33][1],
              _D_,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], _E_ = caml_call1(f, x);
               return caml_call2
                       (Lwt[33][1],
                        _E_,
                        function(l){pendings[1] = l; return next(0);});
              });
    }
    return from(next);
   }
   function flatten(s){return map_list(function(l){return l;}, s);}
   function fold_rec(node, f, s, acc){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var _C_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _C_,
               function(param){return fold_rec(node$0, f, s, acc$0);});
     }
     var match = node$0[2];
     if(! match) return caml_call1(Lwt[4], acc$0);
     var x = match[1];
     consume(s, node$0);
     var acc$1 = caml_call2(f, x, acc$0), node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
    }
   }
   function fold(f, s, acc){return fold_rec(s[4], f, s, acc);}
   function fold_s_rec(node, f, s, acc){
    if(node === s[5][1]){
     var _A_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _A_,
              function(param){return fold_s_rec(node, f, s, acc);});
    }
    var match = node[2];
    if(! match) return caml_call1(Lwt[4], acc);
    var x = match[1];
    consume(s, node);
    var _B_ = caml_call2(f, x, acc);
    return caml_call2
            (Lwt[33][1],
             _B_,
             function(acc){return fold_s_rec(node[1], f, s, acc);});
   }
   function fold_s(f, s, acc){return fold_s_rec(s[4], f, s, acc);}
   function iter_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _z_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _z_,
               function(param){return iter_rec(node$0, f, s);});
     }
     var match = node$0[2];
     if(! match) return Lwt[36];
     var x = match[1];
     consume(s, node$0);
     caml_call1(f, x);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function iter(f, s){return iter_rec(s[4], f, s);}
   function iter_s_rec(node, f, s){
    if(node === s[5][1]){
     var _x_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _x_,
              function(param){return iter_s_rec(node, f, s);});
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1];
    consume(s, node);
    var _y_ = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             _y_,
             function(param){return iter_s_rec(node[1], f, s);});
   }
   function iter_s(f, s){return iter_s_rec(s[4], f, s);}
   function iter_p_rec(node, f, s){
    if(node === s[5][1]){
     var _w_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _w_,
              function(param){return iter_p_rec(node, f, s);});
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1];
    consume(s, node);
    var res = caml_call1(f, x), rest = iter_p_rec(node[1], f, s);
    return caml_call2(Lwt[33][1], res, function(param){return rest;});
   }
   function iter_p(f, s){return iter_p_rec(s[4], f, s);}
   function iter_n(opt, f, stream){
    if(opt)
     var sth = opt[1], max_concurrency = sth;
    else
     var max_concurrency = 1;
    if(max_concurrency <= 0){
     var message = caml_call2(Stdlib_Printf[4], _b_, max_concurrency);
     caml_call1(Stdlib[1], message);
    }
    function loop(running, available){
     function _r_(param){
      var available = param[2], running = param[1], _v_ = get(stream);
      return caml_call2
              (Lwt[33][1],
               _v_,
               function(param){
                if(! param) return caml_call1(Lwt[14], running);
                var elt = param[1];
                return loop
                        ([0, caml_call1(f, elt), running], available - 1 | 0);
               });
     }
     if(0 < available)
      var _s_ = caml_call1(Lwt[4], [0, running, available]);
     else
      var
       _t_ = caml_call1(Lwt[20], running),
       _s_ =
         caml_call2
          (Lwt[33][1],
           _t_,
           function(param){
            var
             running = param[2],
             complete = param[1],
             _u_ =
               [0,
                running,
                available + caml_call1(Stdlib_List[1], complete) | 0];
            return caml_call1(Lwt[4], _u_);
           });
     return caml_call2(Lwt[33][1], _s_, _r_);
    }
    return loop(0, max_concurrency);
   }
   function find_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _q_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _q_,
               function(param){return find_rec(node$0, f, s);});
     }
     var opt = node$0[2];
     if(! opt) return Lwt[37];
     var x = opt[1];
     consume(s, node$0);
     var test = caml_call1(f, x);
     if(test) return caml_call1(Lwt[4], opt);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function find(f, s){return find_rec(s[4], f, s);}
   function find_s_rec(node, f, s){
    if(node === s[5][1]){
     var _o_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _o_,
              function(param){return find_s_rec(node, f, s);});
    }
    var opt = node[2];
    if(! opt) return Lwt[37];
    var x = opt[1];
    consume(s, node);
    var _p_ = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             _p_,
             function(param){
              return param
                      ? caml_call1(Lwt[4], opt)
                      : find_s_rec(node[1], f, s);
             });
   }
   function find_s(f, s){return find_s_rec(s[4], f, s);}
   function find_map_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _n_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _n_,
               function(param){return find_map_rec(node$0, f, s);});
     }
     var match = node$0[2];
     if(! match) return Lwt[37];
     var x = match[1];
     consume(s, node$0);
     var x$0 = caml_call1(f, x);
     if(0 !== x$0) return caml_call1(Lwt[4], x$0);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function find_map(f, s){return find_map_rec(s[4], f, s);}
   function find_map_s_rec(node, f, s){
    if(node === s[5][1]){
     var _m_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _m_,
              function(param){return find_map_s_rec(node, f, s);});
    }
    var match = node[2];
    if(! match) return Lwt[37];
    var x = match[1];
    consume(s, node);
    var t = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             t,
             function(param){
              return param ? t : find_map_s_rec(node[1], f, s);
             });
   }
   function find_map_s(f, s){return find_map_s_rec(s[4], f, s);}
   function combine(s1, s2){
    function next(param){
     var t1 = get(s1), t2 = get(s2);
     return caml_call2
             (Lwt[33][1],
              t1,
              function(n1){
               return caml_call2
                       (Lwt[33][1],
                        t2,
                        function(n2){
                         if(n1 && n2){
                          var x2 = n2[1], x1 = n1[1];
                          return caml_call1(Lwt[4], [0, [0, x1, x2]]);
                         }
                         return Lwt[37];
                        });
              });
    }
    return from(next);
   }
   function append(s1, s2){
    var current_s = [0, s1];
    function next(param){
     var t = get(current_s[1]);
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               return param
                       ? t
                       : current_s
                          [1]
                         === s2
                         ? Lwt[37]
                         : (current_s[1] = s2, next(0));
              });
    }
    return from(next);
   }
   function concat(s_top){
    var current_s = [0, from(function(param){return Lwt[37];})];
    function next(param){
     var t = get(current_s[1]);
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               if(param) return t;
               var _l_ = get(s_top);
               return caml_call2
                       (Lwt[33][1],
                        _l_,
                        function(param){
                         if(! param) return Lwt[37];
                         var s = param[1];
                         current_s[1] = s;
                         return next(0);
                        });
              });
    }
    return from(next);
   }
   function choose(streams){
    function source(s){
     var _k_ = get(s);
     return [0,
             s,
             caml_call2(Lwt[33][2], _k_, function(x){return [0, s, x];})];
    }
    var streams$0 = [0, caml_call2(Stdlib_List[19], source, streams)];
    function next(param){
     var l = streams$0[1];
     if(! l) return Lwt[37];
     var
      _h_ = caml_call2(Stdlib_List[19], function(_j_){return _j_[2];}, l),
      _i_ = caml_call1(Lwt[17], _h_);
     return caml_call2
             (Lwt[33][1],
              _i_,
              function(param){
               var
                x = param[2],
                s = param[1],
                l$0 = caml_call2(Stdlib_List[53], s, l);
               return x
                       ? (streams$0
                          [1]
                         = [0, source(s), l$0],
                         caml_call1(Lwt[4], x))
                       : (streams$0[1] = l$0, next(0));
              });
    }
    return from(next);
   }
   function parse(s, f){
    if(3 === s[1][0]) caml_call1(Stdlib[1], cst_Lwt_stream_parse);
    var node = s[4];
    return caml_call2
            (Lwt[7],
             function(param){return caml_call1(f, s);},
             function(exn){
              s[4] = node;
              throw caml_maybe_attach_backtrace(exn, 0);
             });
   }
   function hexdump(stream){
    var buf = caml_call1(Stdlib_Buffer[1], 80), num = [0, 0];
    return from
            (function(param){
              var _e_ = nget(16, stream);
              return caml_call2
                      (Lwt[33][1],
                       _e_,
                       function(l){
                        if(! l) return Lwt[37];
                        caml_call1(Stdlib_Buffer[8], buf);
                        caml_call3(Stdlib_Printf[5], buf, _c_, num[1]);
                        num[1] = num[1] + 16 | 0;
                        var pos = 0, param = l;
                        for(;;){
                         if(! param) break;
                         var l$0 = param[2], x = param[1];
                         if(8 === pos) caml_call2(Stdlib_Buffer[12], buf, 32);
                         caml_call3(Stdlib_Printf[5], buf, _d_, x);
                         var pos$0 = pos + 1 | 0;
                         pos = pos$0;
                         param = l$0;
                        }
                        var pos$1 = pos;
                        for(;;){
                         if(pos$1 >= 16) break;
                         if(8 === pos$1)
                          caml_call2(Stdlib_Buffer[16], buf, cst$3);
                         else
                          caml_call2(Stdlib_Buffer[16], buf, cst$4);
                         var pos$2 = pos$1 + 1 | 0;
                         pos$1 = pos$2;
                        }
                        caml_call2(Stdlib_Buffer[16], buf, cst$5);
                        caml_call2
                         (Stdlib_List[17],
                          function(ch){
                           a:
                           {
                            if(32 <= ch && 126 >= ch){var _g_ = ch; break a;}
                            var _g_ = 46;
                           }
                           return caml_call2(Stdlib_Buffer[12], buf, _g_);
                          },
                          l);
                        caml_call2(Stdlib_Buffer[12], buf, 124);
                        var _f_ = [0, caml_call1(Stdlib_Buffer[2], buf)];
                        return caml_call1(Lwt[4], _f_);
                       });
             });
   }
   var
    Lwt_stream =
      [0,
       from,
       from_direct,
       Closed,
       create,
       create_with_reference,
       Full,
       create_bounded,
       return$0,
       return_lwt,
       of_seq,
       of_lwt_seq,
       of_list,
       of_array,
       of_string,
       clone,
       to_list,
       to_string,
       Empty,
       peek,
       npeek,
       get,
       nget,
       get_while,
       get_while_s,
       next,
       last_new,
       junk,
       njunk,
       junk_while,
       junk_while_s,
       junk_available,
       get_available,
       get_available_up_to,
       is_empty,
       is_closed,
       closed,
       junk_old,
       choose,
       map,
       map_s,
       filter,
       filter_s,
       filter_map,
       filter_map_s,
       map_list,
       map_list_s,
       fold,
       fold_s,
       iter,
       iter_p,
       iter_s,
       iter_n,
       find,
       find_s,
       find_map,
       find_map_s,
       combine,
       append,
       concat,
       flatten,
       wrap_exn,
       parse,
       hexdump];
   runtime.caml_register_global(28, Lwt_stream, "Lwt_stream");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_result
//# unitInfo: Requires: Assert_failure, Lwt
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Assert_failure = global_data.Assert_failure;
   function return$0(x){return caml_call1(Lwt[4], [0, x]);}
   function fail(e){return caml_call1(Lwt[4], [1, e]);}
   var lift = Lwt[4], _a_ = [0, "src/core/lwt_result.ml", 84, 14];
   function ok(x){return caml_call2(Lwt[28], function(y){return [0, y];}, x);}
   function error(x){
    return caml_call2(Lwt[28], function(y){return [1, y];}, x);
   }
   function map(f, e){
    return caml_call2
            (Lwt[28],
             function(param){
              if(0 === param[0]){
               var x = param[1];
               return [0, caml_call1(f, x)];
              }
              var e = param[1];
              return [1, e];
             },
             e);
   }
   function map_error(f, e){
    return caml_call2
            (Lwt[28],
             function(param){
              if(0 === param[0]){var x = param[1]; return [0, x];}
              var e = param[1];
              return [1, caml_call1(f, e)];
             },
             e);
   }
   function map_err(f, e){return map_error(f, e);}
   function catch$0(e){
    return caml_call2
            (Lwt[7], function(param){return ok(caml_call1(e, 0));}, fail);
   }
   function get_exn(e){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){
               var x = param[1];
               return caml_call1(Lwt[4], x);
              }
              var e = param[1];
              return caml_call1(Lwt[5], e);
             });
   }
   function symbol_bind(e, f){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
              var e = param[1];
              return caml_call1(Lwt[4], [1, e]);
             });
   }
   function bind_error(e, f){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){
               var x = param[1];
               return caml_call1(Lwt[4], [0, x]);
              }
              var e = param[1];
              return caml_call1(f, e);
             });
   }
   function bind_lwt(e, f){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){
               var x = param[1];
               return ok(caml_call1(f, x));
              }
              var e = param[1];
              return fail(e);
             });
   }
   function bind_result(e, f){
    return caml_call2
            (Lwt[28],
             function(param){
              if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
              var e = param[1];
              return [1, e];
             },
             e);
   }
   function bind_lwt_error(e, f){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){var x = param[1]; return return$0(x);}
              var e = param[1], _d_ = caml_call1(f, e);
              return caml_call2(Lwt[6], _d_, fail);
             });
   }
   function bind_lwt_err(e, f){return bind_lwt_error(e, f);}
   function both(a, b){
    var s = [0, 0];
    function set_once(e){return s[1] ? 0 : (s[1] = [0, e], 0);}
    var
     b$0 = map_error(set_once, b),
     a$0 = map_error(set_once, a),
     _b_ = caml_call2(Lwt[13], a$0, b$0);
    return caml_call2
            (Lwt[28],
             function(param){
              var _c_ = param[1];
              if(0 === _c_[0]){
               var match = param[2], x = _c_[1];
               if(0 === match[0]){var y = match[1]; return [0, [0, x, y]];}
              }
              var param$0 = s[1];
              if(! param$0)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
              var e = param$0[1];
              return [1, e];
             },
             _b_);
   }
   function iter(f, r){
    return caml_call2
            (Lwt[6],
             r,
             function(param){
              if(0 !== param[0]) return Lwt[36];
              var x = param[1];
              return caml_call1(f, x);
             });
   }
   function iter_error(f, r){
    return caml_call2
            (Lwt[6],
             r,
             function(param){
              if(0 === param[0]) return Lwt[36];
              var e = param[1];
              return caml_call1(f, e);
             });
   }
   function symbol(e, f){return map(f, e);}
   function map$0(t, f){return map(f, t);}
   function bind(t, f){return symbol_bind(t, f);}
   var
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, map$0, bind, both, Open_on_rhs],
    Let_syntax$0 = [0, Let_syntax];
   function let$0(x, f){return map(f, x);}
   var
    Syntax = [0, symbol_bind, both, let$0, both],
    Lwt_result =
      [0,
       return$0,
       fail,
       lift,
       ok,
       error,
       catch$0,
       get_exn,
       map,
       map_error,
       symbol_bind,
       bind_error,
       bind_lwt,
       bind_lwt_error,
       bind_result,
       both,
       iter,
       iter_error,
       [0, symbol, symbol_bind],
       Let_syntax$0,
       Syntax,
       symbol,
       symbol_bind,
       map_err,
       bind_lwt_err];
   runtime.caml_register_global(3, Lwt_result, "Lwt_result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_pqueue
//# unitInfo: Requires: Assert_failure, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    _a_ = [0, "src/core/lwt_pqueue.ml", 81, 15];
   function Make(Ord){
    function link(t1, t2){
     var
      c2 = t2[3],
      r2 = t2[2],
      x2 = t2[1],
      c1 = t1[3],
      r1 = t1[2],
      x1 = t1[1],
      c = caml_call2(Ord[1], x1, x2);
     return 0 < c
             ? [0, x2, r2 + 1 | 0, [0, t1, c2]]
             : [0, x1, r1 + 1 | 0, [0, t2, c1]];
    }
    function ins(t, ts){
     var t$0 = t, ts$0 = ts;
     for(;;){
      if(! ts$0) return [0, t$0, 0];
      var t$1 = ts$0[1], r$0 = t$1[2], r = t$0[2];
      if(r < r$0) return [0, t$0, ts$0];
      var ts$1 = ts$0[2], t$2 = link(t$0, t$1);
      t$0 = t$2;
      ts$0 = ts$1;
     }
    }
    function is_empty(ts){return 0 === ts ? 1 : 0;}
    function add(x, ts){return ins([0, x, 0, 0], ts);}
    function union(ts$0, ts){
     if(! ts$0) return ts;
     if(! ts) return ts$0;
     var
      ts2 = ts[2],
      t2 = ts[1],
      ts1 = ts$0[2],
      t1 = ts$0[1],
      r = t2[2],
      r$2 = t1[2];
     if(r$2 < r) return [0, t1, union(ts1, [0, t2, ts2])];
     var r$1 = t1[2], r$0 = t2[2];
     if(r$0 < r$1) return [0, t2, union([0, t1, ts1], ts2)];
     var _c_ = union(ts1, ts2);
     return ins(link(t1, t2), _c_);
    }
    function find_min(param){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var t = param[1];
     if(! param[2]){var x$2 = t[1]; return x$2;}
     var
      ts = param[2],
      x = find_min(ts),
      x$1 = t[1],
      c = caml_call2(Ord[1], x$1, x);
     if(0 <= c) return x;
     var x$0 = t[1];
     return x$0;
    }
    function lookup_min(param){
     if(! param) return 0;
     var t = param[1];
     if(! param[2]){var x$2 = t[1]; return [0, x$2];}
     var ts = param[2], result = lookup_min(ts);
     if(! result) return 0;
     var x = result[1], x$1 = t[1], c = caml_call2(Ord[1], x$1, x);
     if(0 <= c) return result;
     var x$0 = t[1];
     return [0, x$0];
    }
    function get_min(param){
     if(! param)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var t = param[1];
     if(! param[2]) return [0, t, 0];
     var
      ts = param[2],
      match = get_min(ts),
      ts$0 = match[2],
      t$0 = match[1],
      x = t$0[1],
      x$0 = t[1],
      c = caml_call2(Ord[1], x$0, x);
     return 0 <= c ? [0, t$0, [0, t, ts$0]] : [0, t, ts];
    }
    function remove_min(ts){
     if(! ts) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var _b_ = get_min(ts), ts$0 = _b_[2], c = _b_[1][3];
     return union(caml_call1(Stdlib_List[9], c), ts$0);
    }
    function size(l){
     return caml_call3
             (Stdlib_List[25],
              function(s, t){
               var tl = t[3];
               return s + (1 + size(tl) | 0) | 0;
              },
              0,
              l);
    }
    return [0,
            0,
            is_empty,
            add,
            union,
            find_min,
            lookup_min,
            remove_min,
            size];
   }
   var Lwt_pqueue = [0, Make];
   runtime.caml_register_global(4, Lwt_pqueue, "Lwt_pqueue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_list
//# unitInfo: Requires: Lwt, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List;
   function tail_recursive_map(f, l){
    var _O_ = caml_call2(Stdlib_List[21], f, l);
    return caml_call1(Stdlib_List[9], _O_);
   }
   function tail_recursive_mapi_rev(f, l){
    var acc = 0, i = 0, param = l;
    for(;;){
     if(! param) return acc;
     var
      tl = param[2],
      hd = param[1],
      i$0 = i + 1 | 0,
      acc$0 = [0, caml_call2(f, i, hd), acc];
     acc = acc$0;
     i = i$0;
     param = tl;
    }
   }
   function iter_s(f, l){
    if(! l) return Lwt[36];
    var l$0 = l[2], x = l[1], _N_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1], _N_, function(param){return iter_s(f, l$0);});
   }
   function iter_p(f, l){
    var
     _M_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[21], _M_, l);
    return caml_call1(Lwt[14], ts);
   }
   function _a_(i, f, l){
    if(! l) return Lwt[36];
    var
     l$0 = l[2],
     x = l[1],
     _K_ = caml_call1(f, i),
     _L_ = caml_call2(Lwt[80], _K_, x);
    return caml_call2
            (Lwt[33][1], _L_, function(param){return _a_(i + 1 | 0, f, l$0);});
   }
   function iteri_s(f, l){return _a_(0, f, l);}
   function iteri_p(f, l){
    function f$0(i){
     var _J_ = caml_call1(f, i);
     return caml_call1(Lwt[80], _J_);
    }
    var ts = tail_recursive_mapi_rev(f$0, l);
    return caml_call1(Lwt[14], ts);
   }
   function map_s(f, l){
    function inner(acc, param){
     if(param){
      var tl = param[2], hd = param[1], _H_ = caml_call2(Lwt[80], f, hd);
      return caml_call2
              (Lwt[33][1], _H_, function(r){return inner([0, r, acc], tl);});
     }
     var _I_ = caml_call1(Stdlib_List[9], acc);
     return caml_call1(Lwt[4], _I_);
    }
    return inner(0, l);
   }
   function collect_rev(acc, param){
    if(! param) return caml_call1(Lwt[4], acc);
    var ts = param[2], t = param[1];
    return caml_call2
            (Lwt[33][1], t, function(i){return collect_rev([0, i, acc], ts);});
   }
   function map_p(f, l){
    var
     _G_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[21], _G_, l);
    return collect_rev(0, ts);
   }
   function filter_map_s(f, l){
    function inner(acc, param){
     if(param){
      var tl = param[2], hd = param[1], _E_ = caml_call2(Lwt[80], f, hd);
      return caml_call2
              (Lwt[33][1],
               _E_,
               function(param){
                if(! param) return inner(acc, tl);
                var v = param[1];
                return inner([0, v, acc], tl);
               });
     }
     var _F_ = caml_call1(Stdlib_List[9], acc);
     return caml_call1(Lwt[4], _F_);
    }
    return inner(0, l);
   }
   function filter_map_p(f, l){
    function collect_optional_rev(acc, param){
     if(! param) return caml_call1(Lwt[4], acc);
     var ts = param[2], t = param[1];
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               if(! param) return collect_optional_rev(acc, ts);
               var v = param[1];
               return collect_optional_rev([0, v, acc], ts);
              });
    }
    var
     _D_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[21], _D_, l);
    return collect_optional_rev(0, ts);
   }
   function mapi_s(f, l){
    function inner(acc, i, param){
     if(param){
      var
       tl = param[2],
       hd = param[1],
       _A_ = caml_call1(f, i),
       _B_ = caml_call2(Lwt[80], _A_, hd);
      return caml_call2
              (Lwt[33][1],
               _B_,
               function(v){return inner([0, v, acc], i + 1 | 0, tl);});
     }
     var _C_ = caml_call1(Stdlib_List[9], acc);
     return caml_call1(Lwt[4], _C_);
    }
    return inner(0, 0, l);
   }
   function mapi_p(f, l){
    function f$0(i){
     var _z_ = caml_call1(f, i);
     return caml_call1(Lwt[80], _z_);
    }
    var ts = tail_recursive_mapi_rev(f$0, l);
    return collect_rev(0, ts);
   }
   function rev_map_append_s(acc, f, l){
    if(! l) return caml_call1(Lwt[4], acc);
    var l$0 = l[2], x = l[1], _y_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1],
             _y_,
             function(x){return rev_map_append_s([0, x, acc], f, l$0);});
   }
   function rev_map_s(f, l){return rev_map_append_s(0, f, l);}
   function rev_map_p(f, l$1){
    var acc$1 = Lwt[38], acc = acc$1, l = l$1;
    for(;;){
     if(! l) return acc;
     var l$0 = l[2], x = l[1];
     let acc$1 = acc;
     var
      _x_ = caml_call2(Lwt[80], f, x),
      acc$0 =
        caml_call2
         (Lwt[33][1],
          _x_,
          function(x){
           return caml_call2
                   (Lwt[33][2], acc$1, function(l){return [0, x, l];});
          });
     acc = acc$0;
     l = l$0;
    }
   }
   function fold_left_s(f, acc, l){
    if(! l) return caml_call1(Lwt[4], acc);
    var
     l$0 = l[2],
     x = l[1],
     _v_ = caml_call1(f, acc),
     _w_ = caml_call2(Lwt[80], _v_, x);
    return caml_call2
            (Lwt[33][1], _w_, function(acc){return fold_left_s(f, acc, l$0);});
   }
   function fold_right_s(f, l, acc){
    function inner(f, a, param){
     if(! param) return caml_call1(Lwt[4], a);
     var
      tl = param[2],
      hd = param[1],
      _t_ = caml_call1(f, hd),
      _u_ = caml_call2(Lwt[80], _t_, a);
     return caml_call2(Lwt[33][1], _u_, function(a){return inner(f, a, tl);});
    }
    return inner(f, acc, caml_call1(Stdlib_List[9], l));
   }
   function for_all_s(f, l){
    if(! l) return Lwt[39];
    var l$0 = l[2], x = l[1], _s_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1],
             _s_,
             function(param){return param ? for_all_s(f, l$0) : Lwt[40];});
   }
   function for_all_p(f, l){
    var _q_ = map_p(f, l);
    return caml_call2
            (Lwt[33][1],
             _q_,
             function(bl){
              var
               _r_ = caml_call2(Stdlib_List[32], function(x){return x;}, bl);
              return caml_call1(Lwt[4], _r_);
             });
   }
   function exists_s(f, l){
    if(! l) return Lwt[40];
    var l$0 = l[2], x = l[1], _p_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1],
             _p_,
             function(param){return param ? Lwt[39] : exists_s(f, l$0);});
   }
   function exists_p(f, l){
    var _n_ = map_p(f, l);
    return caml_call2
            (Lwt[33][1],
             _n_,
             function(bl){
              var
               _o_ = caml_call2(Stdlib_List[33], function(x){return x;}, bl);
              return caml_call1(Lwt[4], _o_);
             });
   }
   function find_s(f, l){
    if(! l) return caml_call1(Lwt[5], Stdlib[8]);
    var l$0 = l[2], x = l[1], _m_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1],
             _m_,
             function(param){
              return param ? caml_call1(Lwt[4], x) : find_s(f, l$0);
             });
   }
   function optionalize(f, x){
    var _l_ = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             _l_,
             function(b){return b ? caml_call1(Lwt[4], [0, x]) : Lwt[37];});
   }
   function filter_s(f, l){
    return filter_map_s(function(_k_){return optionalize(f, _k_);}, l);
   }
   function filter_p(f, l){
    return filter_map_p(function(_j_){return optionalize(f, _j_);}, l);
   }
   function partition_s(f, l){
    function inner(acc1, acc2, param){
     if(param){
      var tl = param[2], hd = param[1], _g_ = caml_call2(Lwt[80], f, hd);
      return caml_call2
              (Lwt[33][1],
               _g_,
               function(b){
                return b
                        ? inner([0, hd, acc1], acc2, tl)
                        : inner(acc1, [0, hd, acc2], tl);
               });
     }
     var
      _h_ = caml_call1(Stdlib_List[9], acc2),
      _i_ = [0, caml_call1(Stdlib_List[9], acc1), _h_];
     return caml_call1(Lwt[4], _i_);
    }
    return inner(0, 0, l);
   }
   function partition_p(f, l){
    function g(x){
     var _f_ = caml_call2(Lwt[80], f, x);
     return caml_call2
             (Lwt[33][1],
              _f_,
              function(b){return caml_call1(Lwt[4], [0, b, x]);});
    }
    var _b_ = map_p(g, l);
    return caml_call2
            (Lwt[33][1],
             _b_,
             function(tl){
              var
               group1 =
                 tail_recursive_map
                  (function(_e_){return _e_[2];},
                   caml_call2
                    (Stdlib_List[41], function(_d_){return _d_[1];}, tl)),
               group2 =
                 tail_recursive_map
                  (function(_c_){return _c_[2];},
                   caml_call2
                    (Stdlib_List[41], function(x){return 1 - x[1];}, tl));
              return caml_call1(Lwt[4], [0, group1, group2]);
             });
   }
   var
    Lwt_list =
      [0,
       iter_s,
       iter_p,
       iteri_s,
       iteri_p,
       map_s,
       map_p,
       mapi_s,
       mapi_p,
       rev_map_s,
       rev_map_p,
       fold_left_s,
       fold_right_s,
       for_all_s,
       for_all_p,
       exists_s,
       exists_p,
       find_s,
       filter_s,
       filter_p,
       filter_map_s,
       filter_map_p,
       partition_s,
       partition_p];
   runtime.caml_register_global(3, Lwt_list, "Lwt_list");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_pool
//# unitInfo: Requires: Lwt, Lwt_list, Lwt_sequence, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Lwt_list = global_data.Lwt_list,
    Lwt = global_data.Lwt;
   function create(m, opt, _n_, _m_, create){
    if(opt)
     var sth = opt[1], validate = sth;
    else
     var validate = function(param){return Lwt[39];};
    if(_n_)
     var sth$0 = _n_[1], check = sth$0;
    else
     var check = function(param, f){return caml_call1(f, 1);};
    if(_m_)
     var sth$1 = _m_[1], dispose = sth$1;
    else
     var dispose = function(param){return Lwt[36];};
    var _o_ = caml_call1(Lwt_sequence[4], 0);
    return [0,
            create,
            check,
            validate,
            dispose,
            [0, [0, 0]],
            m,
            0,
            caml_call1(Stdlib_Queue[2], 0),
            _o_];
   }
   function create_member(p){
    return caml_call2
            (Lwt[7],
             function(param){p[7] = p[7] + 1 | 0; return caml_call1(p[1], 0);},
             function(exn){
              p[7] = p[7] - 1 | 0;
              return caml_call1(Lwt[5], exn);
             });
   }
   function release(p, c){
    var match = caml_call1(Lwt_sequence[13], p[9]);
    if(! match) return caml_call2(Stdlib_Queue[4], c, p[8]);
    var wakener = match[1];
    return caml_call2(Lwt[2], wakener, c);
   }
   function dispose(p, c){
    var _l_ = caml_call1(p[4], c);
    return caml_call2
            (Lwt[33][1],
             _l_,
             function(param){p[7] = p[7] - 1 | 0; return Lwt[36];});
   }
   function validate_and_return(p, c){
    return caml_call3
            (Lwt[9],
             function(param){return caml_call1(p[3], c);},
             function(param){
              if(param) return caml_call1(Lwt[4], c);
              var _k_ = dispose(p, c);
              return caml_call2
                      (Lwt[33][1], _k_, function(param){return create_member(p);});
             },
             function(e){
              var _i_ = dispose(p, c);
              return caml_call2
                      (Lwt[33][1],
                       _i_,
                       function(param){
                        var match = caml_call1(Lwt_sequence[13], p[9]);
                        if(match){
                         var wakener = match[1], _j_ = caml_call2(Lwt[80], p[1], 0);
                         caml_call3
                          (Lwt[32],
                           _j_,
                           function(c){return caml_call2(Lwt[2], wakener, c);},
                           function(exn){return caml_call2(Lwt[3], wakener, exn);});
                        }
                        throw caml_maybe_attach_backtrace(e, 0);
                       });
             });
   }
   function use(p, f){
    function _c_(c){
     var
      cleared = p[5][1],
      promise =
        caml_call2
         (Lwt[7],
          function(param){return caml_call1(f, c);},
          function(e){
           var cleared$0 = cleared[1], ok = [0, 0];
           caml_call2(p[2], c, function(result){ok[1] = result; return 0;});
           a:
           {
            var _g_ = function(param){return caml_call1(Lwt[5], e);};
            if(! cleared$0 && ok[1]){
             release(p, c);
             var _h_ = Lwt[36];
             break a;
            }
            var _h_ = dispose(p, c);
           }
           return caml_call2(Lwt[33][1], _h_, _g_);
          });
     return caml_call2
             (Lwt[33][1],
              promise,
              function(param){
               if(cleared[1]){
                var _f_ = dispose(p, c);
                return caml_call2
                        (Lwt[33][1], _f_, function(param){return promise;});
               }
               release(p, c);
               return promise;
              });
    }
    if(caml_call1(Stdlib_Queue[13], p[8]))
     if(p[7] < p[6])
      var _d_ = create_member(p);
     else
      var
       _b_ = caml_call1(Lwt[55], p[9]),
       _d_ =
         caml_call2
          (Lwt[33][1],
           _b_,
           function(_e_){return validate_and_return(p, _e_);});
    else
     var
      c = caml_call1(Stdlib_Queue[5], p[8]),
      _d_ = validate_and_return(p, c);
    return caml_call2(Lwt[33][1], _d_, _c_);
   }
   function clear(p){
    var
     elements =
       caml_call3
        (Stdlib_Queue[16],
         function(l, element){return [0, element, l];},
         0,
         p[8]);
    caml_call1(Stdlib_Queue[11], p[8]);
    var old_cleared = p[5][1];
    old_cleared[1] = 1;
    p[5][1] = [0, 0];
    return caml_call2
            (Lwt_list[1], function(_a_){return dispose(p, _a_);}, elements);
   }
   function wait_queue_length(p){return caml_call1(Lwt_sequence[7], p[9]);}
   var Lwt_pool = [0, create, use, clear, wait_queue_length];
   runtime.caml_register_global(4, Lwt_pool, "Lwt_pool");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_mvar
//# unitInfo: Requires: Lwt, Lwt_sequence
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Lwt_sequence = global_data.Lwt_sequence;
   function create_empty(param){
    var _b_ = caml_call1(Lwt_sequence[4], 0);
    return [0, 0, caml_call1(Lwt_sequence[4], 0), _b_];
   }
   function create(v){
    var _a_ = caml_call1(Lwt_sequence[4], 0);
    return [0, [0, v], caml_call1(Lwt_sequence[4], 0), _a_];
   }
   function put(mvar, v){
    if(mvar[1]){
     var
      match = caml_call1(Lwt[22], 0),
      w = match[2],
      res = match[1],
      node = caml_call2(Lwt_sequence[9], [0, v, w], mvar[2]);
     caml_call2
      (Lwt[24],
       res,
       function(param){return caml_call1(Lwt_sequence[3], node);});
     return res;
    }
    var match$0 = caml_call1(Lwt_sequence[13], mvar[3]);
    if(match$0){
     var w$0 = match$0[1];
     caml_call2(Lwt[2], w$0, v);
    }
    else
     mvar[1] = [0, v];
    return Lwt[36];
   }
   function take_available(mvar){
    var match$1 = mvar[1];
    if(! match$1) return 0;
    var v$0 = match$1[1], match = caml_call1(Lwt_sequence[13], mvar[2]);
    if(match){
     var match$0 = match[1], w = match$0[2], v = match$0[1];
     mvar[1] = [0, v];
     caml_call2(Lwt[2], w, 0);
    }
    else
     mvar[1] = 0;
    return [0, v$0];
   }
   function take(mvar){
    var match = take_available(mvar);
    if(! match) return caml_call1(Lwt[55], mvar[3]);
    var v = match[1];
    return caml_call1(Lwt[4], v);
   }
   function is_empty(mvar){return mvar[1] ? 0 : 1;}
   var
    Lwt_mvar = [0, create, create_empty, put, take, take_available, is_empty];
   runtime.caml_register_global(2, Lwt_mvar, "Lwt_mvar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_mutex
//# unitInfo: Requires: Lwt, Lwt_sequence
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Lwt = global_data.Lwt;
   function create(param){return [0, 0, caml_call1(Lwt_sequence[4], 0)];}
   function lock(m){
    return m[1] ? caml_call1(Lwt[55], m[2]) : (m[1] = 1, Lwt[36]);
   }
   function unlock(m){
    var _b_ = m[1];
    if(! _b_) return _b_;
    if(caml_call1(Lwt_sequence[6], m[2])){m[1] = 0; return 0;}
    var _c_ = caml_call1(Lwt_sequence[11], m[2]);
    return caml_call2(Lwt[2], _c_, 0);
   }
   function with_lock(m, f){
    var _a_ = lock(m);
    return caml_call2
            (Lwt[33][1],
             _a_,
             function(param){
              return caml_call2
                      (Lwt[8], f, function(param){unlock(m); return Lwt[36];});
             });
   }
   function is_locked(m){return m[1];}
   function is_empty(m){return caml_call1(Lwt_sequence[6], m[2]);}
   var Lwt_mutex = [0, create, lock, unlock, is_locked, is_empty, with_lock];
   runtime.caml_register_global(2, Lwt_mutex, "Lwt_mutex");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_condition
//# unitInfo: Requires: Lwt, Lwt_mutex, Lwt_sequence, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib_List = global_data.Stdlib__List,
    Lwt_mutex = global_data.Lwt_mutex,
    create = Lwt_sequence[4];
   function wait(mutex, cvar){
    var waiter = caml_call1(Lwt[55], cvar);
    if(mutex){var m = mutex[1]; caml_call1(Lwt_mutex[3], m);}
    return caml_call2
            (Lwt[8],
             function(param){return waiter;},
             function(param){
              if(! mutex) return Lwt[36];
              var m = mutex[1];
              return caml_call1(Lwt_mutex[2], m);
             });
   }
   function signal(cvar, arg){
    try{
     var
      _b_ = caml_call1(Lwt_sequence[11], cvar),
      _c_ = caml_call2(Lwt[2], _b_, arg);
     return _c_;
    }
    catch(_d_){
     var _a_ = caml_wrap_exception(_d_);
     if(_a_ === Lwt_sequence[10]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   function broadcast(cvar, arg){
    var
     wakeners =
       caml_call3
        (Lwt_sequence[22], function(x, l){return [0, x, l];}, cvar, 0);
    caml_call2(Lwt_sequence[19], Lwt_sequence[3], cvar);
    return caml_call2
            (Stdlib_List[17],
             function(wakener){return caml_call2(Lwt[2], wakener, arg);},
             wakeners);
   }
   function broadcast_exn(cvar, exn){
    var
     wakeners =
       caml_call3
        (Lwt_sequence[22], function(x, l){return [0, x, l];}, cvar, 0);
    caml_call2(Lwt_sequence[19], Lwt_sequence[3], cvar);
    return caml_call2
            (Stdlib_List[17],
             function(wakener){return caml_call2(Lwt[3], wakener, exn);},
             wakeners);
   }
   var Lwt_condition = [0, create, wait, signal, broadcast, broadcast_exn];
   runtime.caml_register_global(4, Lwt_condition, "Lwt_condition");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHd0LmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJFbXB0eSIsImdldCIsIm5vZGUiLCJzZXQiLCJkYXRhIiwicmVtb3ZlIiwiY3JlYXRlIiwicGFyYW0iLCJzZXEiLCJjbGVhciIsImlzX2VtcHR5IiwibGVuZ3RoIiwiY3VyciIsImxlbiIsImFkZF9sIiwiYWRkX3IiLCJ0YWtlX2wiLCJ0YWtlX3IiLCJ0YWtlX29wdF9sIiwidGFrZV9vcHRfciIsInRyYW5zZmVyX2wiLCJzMSIsInMyIiwidHJhbnNmZXJfciIsIml0ZXJfbCIsIml0ZXJfciIsIml0ZXJfbm9kZV9sIiwiaXRlcl9ub2RlX3IiLCJmb2xkX2wiLCJhY2MiLCJmb2xkX3IiLCJmaW5kX25vZGVfbCIsImZpbmRfbm9kZV9yIiwiZmluZF9ub2RlX29wdF9sIiwiZmluZF9ub2RlX29wdF9yIiwiTHd0X3NlcXVlbmNlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9qc2VvLy5vcGFtLzQuMTMuMS9saWIvbHd0L2x3dF9zZXF1ZW5jZS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsUUFB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U0FhakIsUUFBQUEsT0FBQSxRQUFBaUIsUUFBQTtBQUFBO0FBQUEsS0FURSxpQkFDRTtBQUFBLEtBR0E7QUFBQSxVQUFBQSxRQUNzQiwrQkFBQWpCLFNBQXNCO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FBQUEsU0FFMUM7QUFBQTtBQUFBLEdBRVc7QUFBQSxZQUFBbUIsWUFBQXJDLEdBQUFjO0FBQUFBLFFBQUFJLFNBZ0JqQixRQUFBQSxPQUFBO0FBQUE7QUFBQSxLQVpFLGlCQVVFO0FBQUEsS0FSQTtBQUFBLE1BQ0ssMkJBQ0Q7QUFBQSxVQUFBQSxTQUVBO0FBQUE7QUFBQTtBQUFBLGNBQUFBLFNBRUY7QUFBQTtBQUFBLEdBSU87QUFBQSxZQUFBb0IsWUFBQXRDLEdBQUFjO0FBQUFBLFFBQUFJLFNBZ0JiLFFBQUFBLE9BQUE7QUFBQTtBQUFBLEtBWkUsaUJBVUU7QUFBQSxLQVJBO0FBQUEsTUFDSywyQkFDRDtBQUFBLFVBQUFBLFNBRUE7QUFBQTtBQUFBO0FBQUEsY0FBQUEsU0FFRjtBQUFBO0FBQUEsR0FJTztBQUFBLFlBQUFxQixnQkFBQXZDLEdBQUFjO0FBQUFBLElBR2IsY0FBUztBQUFBO0FBQUEsZURsT1g7QUFBQSwyQkNrT2lEO0FBQUEsS0RsT2pEO0FBQUE7QUFBQSxHQ2tPcUQ7QUFBQSxZQUFBMEIsZ0JBQUF4QyxHQUFBYztBQUFBQSxJQUduRCxjQUFTO0FBQUE7QUFBQSxlRHJPWDtBQUFBLDJCQ3FPaUQ7QUFBQSxLRHJPakQ7QUFBQTtBQUFBLEdDcU9xRDtBQUFBO0FBQUEsSUFBQTJCO0FBQUFBLE1Eck9yRCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG5leGNlcHRpb24gRW1wdHlcblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIHByZXYgOiAnYSB0O1xuICBtdXRhYmxlIG5leHQgOiAnYSB0O1xufVxuXG50eXBlICdhIG5vZGUgPSB7XG4gIG5vZGVfcHJldiA6ICdhIHQ7XG4gIG5vZGVfbmV4dCA6ICdhIHQ7XG4gIG11dGFibGUgbm9kZV9kYXRhIDogJ2E7XG4gIG11dGFibGUgbm9kZV9hY3RpdmUgOiBib29sO1xufVxuXG5leHRlcm5hbCBzZXFfb2Zfbm9kZSA6ICdhIG5vZGUgLT4gJ2EgdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG5vZGVfb2Zfc2VxIDogJ2EgdCAtPiAnYSBub2RlID0gXCIlaWRlbnRpdHlcIlxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IE9wZXJhdGlvbnMgb24gbm9kZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmxldCBnZXQgbm9kZSA9XG4gIG5vZGUubm9kZV9kYXRhXG5cbmxldCBzZXQgbm9kZSBkYXRhID1cbiAgbm9kZS5ub2RlX2RhdGEgPC0gZGF0YVxuXG5sZXQgcmVtb3ZlIG5vZGUgPVxuICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gYmVnaW5cbiAgICBub2RlLm5vZGVfYWN0aXZlIDwtIGZhbHNlO1xuICAgIGxldCBzZXEgPSBzZXFfb2Zfbm9kZSBub2RlIGluXG4gICAgc2VxLnByZXYubmV4dCA8LSBzZXEubmV4dDtcbiAgICBzZXEubmV4dC5wcmV2IDwtIHNlcS5wcmV2XG4gIGVuZFxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IE9wZXJhdGlvbnMgb24gc2VxdWVuY2VzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmxldCBjcmVhdGUgKCkgPVxuICBsZXQgcmVjIHNlcSA9IHsgcHJldiA9IHNlcTsgbmV4dCA9IHNlcSB9IGluXG4gIHNlcVxuXG5sZXQgY2xlYXIgc2VxID1cbiAgc2VxLnByZXYgPC0gc2VxO1xuICBzZXEubmV4dCA8LSBzZXFcblxubGV0IGlzX2VtcHR5IHNlcSA9IHNlcS5uZXh0ID09IHNlcVxuXG5sZXQgbGVuZ3RoIHNlcSA9XG4gIGxldCByZWMgbG9vcCBjdXJyIGxlbiA9XG4gICAgaWYgY3VyciA9PSBzZXEgdGhlblxuICAgICAgbGVuXG4gICAgZWxzZVxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluIGxvb3Agbm9kZS5ub2RlX25leHQgKGxlbiArIDEpXG4gIGluXG4gIGxvb3Agc2VxLm5leHQgMFxuXG5sZXQgYWRkX2wgZGF0YSBzZXEgPVxuICBsZXQgbm9kZSA9IHsgbm9kZV9wcmV2ID0gc2VxOyBub2RlX25leHQgPSBzZXEubmV4dDsgbm9kZV9kYXRhID0gZGF0YTsgbm9kZV9hY3RpdmUgPSB0cnVlIH0gaW5cbiAgc2VxLm5leHQucHJldiA8LSBzZXFfb2Zfbm9kZSBub2RlO1xuICBzZXEubmV4dCA8LSBzZXFfb2Zfbm9kZSBub2RlO1xuICBub2RlXG5cbmxldCBhZGRfciBkYXRhIHNlcSA9XG4gIGxldCBub2RlID0geyBub2RlX3ByZXYgPSBzZXEucHJldjsgbm9kZV9uZXh0ID0gc2VxOyBub2RlX2RhdGEgPSBkYXRhOyBub2RlX2FjdGl2ZSA9IHRydWUgfSBpblxuICBzZXEucHJldi5uZXh0IDwtIHNlcV9vZl9ub2RlIG5vZGU7XG4gIHNlcS5wcmV2IDwtIHNlcV9vZl9ub2RlIG5vZGU7XG4gIG5vZGVcblxubGV0IHRha2VfbCBzZXEgPVxuICBpZiBpc19lbXB0eSBzZXEgdGhlblxuICAgIHJhaXNlIEVtcHR5XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIHNlcS5uZXh0IGluXG4gICAgcmVtb3ZlIG5vZGU7XG4gICAgbm9kZS5ub2RlX2RhdGFcbiAgZW5kXG5cbmxldCB0YWtlX3Igc2VxID1cbiAgaWYgaXNfZW1wdHkgc2VxIHRoZW5cbiAgICByYWlzZSBFbXB0eVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBzZXEucHJldiBpblxuICAgIHJlbW92ZSBub2RlO1xuICAgIG5vZGUubm9kZV9kYXRhXG4gIGVuZFxuXG5sZXQgdGFrZV9vcHRfbCBzZXEgPVxuICBpZiBpc19lbXB0eSBzZXEgdGhlblxuICAgIE5vbmVcbiAgZWxzZSBiZWdpblxuICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgc2VxLm5leHQgaW5cbiAgICByZW1vdmUgbm9kZTtcbiAgICBTb21lIG5vZGUubm9kZV9kYXRhXG4gIGVuZFxuXG5sZXQgdGFrZV9vcHRfciBzZXEgPVxuICBpZiBpc19lbXB0eSBzZXEgdGhlblxuICAgIE5vbmVcbiAgZWxzZSBiZWdpblxuICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgc2VxLnByZXYgaW5cbiAgICByZW1vdmUgbm9kZTtcbiAgICBTb21lIG5vZGUubm9kZV9kYXRhXG4gIGVuZFxuXG5sZXQgdHJhbnNmZXJfbCBzMSBzMiA9XG4gIHMyLm5leHQucHJldiA8LSBzMS5wcmV2O1xuICBzMS5wcmV2Lm5leHQgPC0gczIubmV4dDtcbiAgczIubmV4dCA8LSBzMS5uZXh0O1xuICBzMS5uZXh0LnByZXYgPC0gczI7XG4gIHMxLnByZXYgPC0gczE7XG4gIHMxLm5leHQgPC0gczFcblxubGV0IHRyYW5zZmVyX3IgczEgczIgPVxuICBzMi5wcmV2Lm5leHQgPC0gczEubmV4dDtcbiAgczEubmV4dC5wcmV2IDwtIHMyLnByZXY7XG4gIHMyLnByZXYgPC0gczEucHJldjtcbiAgczEucHJldi5uZXh0IDwtIHMyO1xuICBzMS5wcmV2IDwtIHMxO1xuICBzMS5uZXh0IDwtIHMxXG5cbmxldCBpdGVyX2wgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlbiBiZWdpblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gZiBub2RlLm5vZGVfZGF0YTtcbiAgICAgIGxvb3Agbm9kZS5ub2RlX25leHRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBzZXEubmV4dFxuXG5sZXQgaXRlcl9yIGYgc2VxID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgPVxuICAgIGlmIGN1cnIgIT0gc2VxIHRoZW4gYmVnaW5cbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuIGYgbm9kZS5ub2RlX2RhdGE7XG4gICAgICBsb29wIG5vZGUubm9kZV9wcmV2XG4gICAgZW5kXG4gIGluXG4gIGxvb3Agc2VxLnByZXZcblxubGV0IGl0ZXJfbm9kZV9sIGYgc2VxID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgPVxuICAgIGlmIGN1cnIgIT0gc2VxIHRoZW4gYmVnaW5cbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuIGYgbm9kZTtcbiAgICAgIGxvb3Agbm9kZS5ub2RlX25leHRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBzZXEubmV4dFxuXG5sZXQgaXRlcl9ub2RlX3IgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlbiBiZWdpblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gZiBub2RlO1xuICAgICAgbG9vcCBub2RlLm5vZGVfcHJldlxuICAgIGVuZFxuICBpblxuICBsb29wIHNlcS5wcmV2XG5cbmxldCBmb2xkX2wgZiBzZXEgYWNjID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgYWNjID1cbiAgICBpZiBjdXJyID09IHNlcSB0aGVuXG4gICAgICBhY2NcbiAgICBlbHNlXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW5cbiAgICAgIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlblxuICAgICAgICBsb29wIG5vZGUubm9kZV9uZXh0IChmIG5vZGUubm9kZV9kYXRhIGFjYylcbiAgICAgIGVsc2VcbiAgICAgICAgbG9vcCBub2RlLm5vZGVfbmV4dCBhY2NcbiAgaW5cbiAgbG9vcCBzZXEubmV4dCBhY2NcblxubGV0IGZvbGRfciBmIHNlcSBhY2MgPVxuICBsZXQgcmVjIGxvb3AgY3VyciBhY2MgPVxuICAgIGlmIGN1cnIgPT0gc2VxIHRoZW5cbiAgICAgIGFjY1xuICAgIGVsc2VcbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuXG4gICAgICAgIGxvb3Agbm9kZS5ub2RlX3ByZXYgKGYgbm9kZS5ub2RlX2RhdGEgYWNjKVxuICAgICAgZWxzZVxuICAgICAgICBsb29wIG5vZGUubm9kZV9wcmV2IGFjY1xuICBpblxuICBsb29wIHNlcS5wcmV2IGFjY1xuXG5sZXQgZmluZF9ub2RlX2wgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW5cbiAgICAgICAgaWYgZiBub2RlLm5vZGVfZGF0YSB0aGVuXG4gICAgICAgICAgbm9kZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbG9vcCBub2RlLm5vZGVfbmV4dFxuICAgICAgZWxzZVxuICAgICAgICBsb29wIG5vZGUubm9kZV9uZXh0XG4gICAgZWxzZVxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIGluXG4gIGxvb3Agc2VxLm5leHRcblxubGV0IGZpbmRfbm9kZV9yIGYgc2VxID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgPVxuICAgIGlmIGN1cnIgIT0gc2VxIHRoZW5cbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuXG4gICAgICAgIGlmIGYgbm9kZS5ub2RlX2RhdGEgdGhlblxuICAgICAgICAgIG5vZGVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxvb3Agbm9kZS5ub2RlX3ByZXZcbiAgICAgIGVsc2VcbiAgICAgICAgbG9vcCBub2RlLm5vZGVfcHJldlxuICAgIGVsc2VcbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICBpblxuICBsb29wIHNlcS5wcmV2XG5cbmxldCBmaW5kX25vZGVfb3B0X2wgZiBzZXEgPVxuICB0cnkgU29tZSAoZmluZF9ub2RlX2wgZiBzZXEpIHdpdGggTm90X2ZvdW5kIC0+IE5vbmVcblxubGV0IGZpbmRfbm9kZV9vcHRfciBmIHNlcSA9XG4gIHRyeSBTb21lIChmaW5kX25vZGVfciBmIHNlcSkgd2l0aCBOb3RfZm91bmQgLT4gTm9uZVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9Md3QiLCJjc3RfTHd0X3MiLCJjc3Rfc3JjX2NvcmVfbHd0X21sIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9vYmpfdGFnIiwiY2FtbF90cmFtcG9saW5lIiwiY2FtbF90cmFtcG9saW5lX3JldHVybiIsImNhbWxfdXBkYXRlX2R1bW15IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJjYW1sX2NhbGw2IiwiYTUiLCJjYW1sX2NhbGw3IiwiYTYiLCJkdW1teSIsImdsb2JhbF9kYXRhIiwiTHd0X3NlcXVlbmNlIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfTGlzdCIsIlN0ZGxpYiIsIkNhbWxpbnRlcm5hbExhenkiLCJTdGRsaWJfUmFuZG9tIiwiU3RkbGliX1ByaW50ZiIsIlN0ZGxpYl9RdWV1ZSIsIlN0ZGxpYl9QcmludGV4YyIsIlN0ZGxpYl9NYXAiLCJjb21wYXJlIiwiU3RvcmFnZV9tYXAiLCJzdGF0ZV9vZl9yZXN1bHQiLCJwYXJhbSIsIngiLCJleG4iLCJ1bmRlcmx5aW5nIiwicCIsIm1hdGNoIiwicDIiLCJwMSIsImhhbmRsZV9hbGwiLCJoYW5kbGVfYWxsX2V4Y2VwdF9ydW50aW1lIiwidiIsInNldCIsInJ1biIsImUiLCJuZXh0X2tleV9pZCIsIm5ld19rZXkiLCJpZCIsImN1cnJlbnRfc3RvcmFnZSIsImNzdF9GYXRhbF9lcnJvcl9leGNlcHRpb24iLCJnZXQiLCJrZXkiLCJyZWZyZXNoIiwidmFsdWUiLCJ3aXRoX3ZhbHVlIiwibmV3X3N0b3JhZ2UiLCJzYXZlZF9zdG9yYWdlIiwicmVzdWx0IiwiY29uY2F0X3JlZ3VsYXJfY2FsbGJhY2tzIiwibDEiLCJsMiIsImNsZWFuX3VwX2NhbGxiYWNrX2NlbGxzIiwiY2FsbGJhY2tzIiwiY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsIiwiY2VsbCIsInBzIiwiY2xlYW51cHNfZGVmZXJyZWQiLCJhZGRfcmVndWxhcl9jYWxsYmFja19saXN0X25vZGUiLCJub2RlIiwiZXhpc3RpbmciLCJhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWMiLCJhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGIiLCJzZWxmX3JlbW92aW5nX2NhbGxiYWNrX3dyYXBwZXIiLCJhZGRfY2FuY2VsX2NhbGxiYWNrIiwiYXN5bmNfZXhjZXB0aW9uX2hvb2siLCJoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG8iLCJDYW5jZWxlZCIsInJ1bl9jYWxsYmFja3MiLCJpc19jYW5jZWxlZCIsImZzIiwiaXRlcl9jYWxsYmFja19saXN0IiwiY291bnRlciIsInJlc3QiLCJzdG9yYWdlIiwiaXRlcl9saXN0IiwiY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoIiwiZGVmZXJyZWRfY2FsbGJhY2tzIiwiZGVmYXVsdF9tYXhpbXVtX2NhbGxiYWNrX25lc3RpIiwiY3N0X3dha2V1cF9yZXN1bHQiLCJjc3Rfd2FrZXVwIiwiY3N0X3dha2V1cF9leG4iLCJjc3Rfd2FrZXVwX2xhdGVyX3Jlc3VsdCIsImNzdF93YWtldXBfbGF0ZXIiLCJjc3Rfd2FrZXVwX2xhdGVyX2V4biIsImxlYXZlX3Jlc29sdXRpb25fbG9vcCIsInN0b3JhZ2Vfc25hcHNob3QiLCJydW5faW5fcmVzb2x1dGlvbl9sb29wIiwiYWJhbmRvbl93YWtldXBzIiwicnVuX2NhbGxiYWNrc19vcl9kZWZlcl90aGVtIiwib3B0Iiwic3RoIiwiYWxsb3dfZGVmZXJyaW5nIiwibWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoIiwic2hvdWxkX2RlZmVyIiwicmVzb2x2ZSIsInJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdCIsImlmX2RlZmVycmVkIiwicnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpIiwiZGVmZXJyZWRfcmVzdWx0IiwiZGVmZXJyZWRfY2FsbGJhY2siLCJpbW1lZGlhdGVfcmVzdWx0IiwiZGVmZXJyZWRfcmVjb3JkIiwid2FrZXVwX2dlbmVyYWwiLCJhcGlfZnVuY3Rpb25fbmFtZSIsInIiLCJ3YWtldXBfcmVzdWx0Iiwid2FrZXVwIiwid2FrZXVwX2V4biIsIndha2V1cF9sYXRlcl9nZW5lcmFsIiwid2FrZXVwX2xhdGVyX3Jlc3VsdCIsIndha2V1cF9sYXRlciIsIndha2V1cF9sYXRlcl9leG4iLCJjYW5jZWwiLCJjYW5jZWxlZF9yZXN1bHQiLCJjYW5jZWxfYW5kX2NvbGxlY3RfY2FsbGJhY2tzIiwiY2FsbGJhY2tzX2FjY3VtdWxhdG9yIiwicmV0dXJuIiwib2ZfcmVzdWx0IiwiZmFpbCIsInJldHVybl91bml0IiwicmV0dXJuX25vbmUiLCJyZXR1cm5fc29tZSIsInJldHVybl9uaWwiLCJyZXR1cm5fdHJ1ZSIsInJldHVybl9mYWxzZSIsInJldHVybl9vayIsInJldHVybl9lcnJvciIsImZhaWxfd2l0aCIsIm1zZyIsImZhaWxfaW52YWxpZF9hcmciLCJuZXdfcGVuZGluZyIsImhvd190b19jYW5jZWwiLCJzdGF0ZSIsIndhaXQiLCJ0YXNrIiwiYWRkX3Rhc2tfciIsInNlcXVlbmNlIiwiYWRkX3Rhc2tfbCIsInByb3RlY3RlZCIsInBfaW50ZXJuYWwiLCJjYWxsYmFjayIsInBfcmVzdWx0IiwicmVtb3ZlX3RoZV9jYWxsYmFjayIsInBfY2FsbGJhY2tzIiwibm9fY2FuY2VsIiwibWFrZV9pbnRvX3Byb3h5Iiwib3V0ZXJfcHJvbWlzZSIsInVzZXJfcHJvdmlkZWRfcHJvbWlzZSIsIm91dGVyX2NhbGxiYWNrcyIsInJlZ3VsYXJfY2FsbGJhY2tzIiwiY2FuY2VsX2NhbGxiYWNrcyIsInN5bWJvbF9iaW5kIiwiY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsIiwiYmFja3RyYWNlX2JpbmQiLCJhZGRfbG9jIiwic3ltYm9sIiwiY2F0Y2giLCJoIiwiYmFja3RyYWNlX2NhdGNoIiwidHJ5X2JpbmQiLCJiYWNrdHJhY2VfdHJ5X2JpbmQiLCJmaW5hbGl6ZSIsImJhY2t0cmFjZV9maW5hbGl6ZSIsIm9uX2NhbmNlbCIsIm9uX3N1Y2Nlc3MiLCJjYWxsYmFja19pZl9kZWZlcnJlZCIsIm9uX2ZhaWx1cmUiLCJvbl90ZXJtaW5hdGlvbiIsIm9uX2FueSIsImciLCJ3cmFwX2luX2NhbmNlbGFibGUiLCJwX3VuZGVybHlpbmciLCJkb250X3dhaXQiLCJhc3luYyIsImlnbm9yZV9yZXN1bHQiLCJqb2luIiwibnVtYmVyX3BlbmRpbmdfaW5fcHMiLCJqb2luX3Jlc3VsdCIsIm5ld19yZXN1bHQiLCJib3RoIiwicGFpciIsInYyIiwidjEiLCJhbGwiLCJ5IiwidnMiLCJpIiwiYWNjIiwiaW5kZXgiLCJjb3VudF9yZXNvbHZlZF9wcm9taXNlc19pbiIsInRvdGFsIiwicmVqZWN0ZWQiLCJudGhfcmVzb2x2ZWQiLCJuIiwibnRoX3Jlc29sdmVkX2FuZF9jYW5jZWxfcGVuZGluIiwicHJuZyIsImNzdF9Md3RfY2hvb3NlX3dvdWxkX3JldHVybl9hXyIsImNzdF9Md3RfcGlja193b3VsZF9yZXR1cm5fYV9wciIsImNzdF9Md3RfbmNob29zZV93b3VsZF9yZXR1cm5fYSIsImNzdF9Md3RfbnBpY2tfd291bGRfcmV0dXJuX2FfcCIsImNzdF9Md3RfbmNob29zZV9zcGxpdF93b3VsZF9yZSIsImNob29zZSIsInBpY2siLCJxcyIsImNvbGxlY3RfZnVsZmlsbGVkX3Byb21pc2VzX2FmdCIsInJlc3VsdHMiLCJuY2hvb3NlIiwibnBpY2siLCJuY2hvb3NlX3NwbGl0IiwicGVuZGluZ19hY2MiLCJ0b19yZXNvbHZlIiwiZnVsZmlsbGVkIiwicGVuZGluZyIsImRlYnVnX3N0YXRlX2lzIiwiZXhwZWN0ZWRfc3RhdGUiLCJpc19zbGVlcGluZyIsInBvbGwiLCJhcHBseSIsIndyYXAiLCJ3cmFwMSIsIngxIiwid3JhcDIiLCJ4MiIsIndyYXAzIiwieDMiLCJ3cmFwNCIsIng0Iiwid3JhcDUiLCJ4NSIsIndyYXA2IiwieDYiLCJ3cmFwNyIsIng3IiwicGF1c2VfaG9vayIsInBhdXNlZCIsInBhdXNlIiwid2FrZXVwX3BhdXNlZCIsInRtcCIsInJlZ2lzdGVyX3BhdXNlX25vdGlmaWVyIiwiYWJhbmRvbl9wYXVzZWQiLCJwYXVzZWRfY291bnQiLCJtYXAiLCJ0IiwiYmluZCIsIk9wZW5fb25fcmhzIiwiTGV0X3N5bnRheCIsImxldCIsIlN5bnRheCIsIkx3dCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvanNlby8ub3BhbS80LjEzLjEvbGli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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEL2xHckMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5cblxuKCogUmVhZGluZyBndWlkZVxuXG4gICBXZWxjb21lIHRvIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgTHd0IGNvcmUhIFRoaXMgaXMgYSBiaWcgZmlsZSwgYnV0IHdlXG4gICBob3BlIHRoYXQgcmVhZGluZyBpdCAocGFydHMgYXQgYSB0aW1lISkgd2lsbCBub3QgYmUgc2NhcnkgOikgSGVyZSBpcyB3aHk6XG5cblxuICAgKiBTZWN0aW9uaW5nXG5cbiAgIFRoZSBjb2RlIGlzIGJyb2tlbiB1cCBpbnRvIHNlY3Rpb25zLCBlYWNoIG9uZSBvZiB3aGljaCBpcyBhbiBpbnRlcm5hbCBtb2R1bGUuXG4gICBNb3N0IG9mIHRoZSBtb2R1bGVzIGhhdmUgYSBzaWduYXR1cmUsIHdoaWNoIHNlcnZlcyBhcyBhIG5lYXQgdGFibGUgb2ZcbiAgIGNvbnRlbnRzLlxuXG4gICBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdSByZWFkIHRoaXMgZmlsZSB3aXRoIGNvZGUgZm9sZGluZyBlbmFibGVkLiBJZiB5b3VcbiAgIGZvbGQgYWxsIHRoZSBtb2R1bGVzLCB5b3UgY2FuIHZpc3VhbGl6ZSB0aGUgbG9naWNhbCBzdHJ1Y3R1cmUgb2YgTHd0IHF1aXRlXG4gICBlYXNpbHkuIFlvdSBjYW4gdGhlbiBleHBhbmQgbW9kdWxlcyBhcyBuZWVkZWQsIGRlcGVuZGluZyBvbiB3aGF0IHBhcnQgb2YgdGhlXG4gICBpbXBsZW1lbnRhdGlvbiB5b3UgYXJlIGludGVyZXN0ZWQgaW4uIFdpdGhvdXQgY29kZSBmb2xkaW5nLCB5b3UgZmFjZSBhblxuICAgaW50aW1pZGF0aW5nIHdhbGwgb2YgY29kZSA6KCBZb3UgY2FuIHN0aWxsIHZpc3VhbGx5IHBhcnNlIHRoZSBmaWxlLCBob3dldmVyLFxuICAgYmVjYXVzZSB0aGVyZSBhcmUgcGxlbnR5IG9mIGJsYW5rIGxpbmVzIHRvIGhlbHAgc2VjdGlvbiB0aGluZ3Mgb2ZmLiBZb3UgY2FuXG4gICBhbHNvIHZpZXcgdGhpcyBmaWxlIGZvbGRlZCBvbmxpbmU6XG5cbiAgICAgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYWFudHJvbi85ZmFiMGJkZWFkOThhNjBmY2NmMDZlMDE4OTE4Njg2M1xuICAgICBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9hYW50cm9uLzk3YjU4NTIwZDViYjQ4NThjY2FjNmY1NDcwMGEyNGQ3XG5cbiAgIFRoZSBzaWduYXR1cmVzIGFyZSB1bnVzdWFsOiBiaWcgY29tbWVudHMgYXJlIGFic2VudC4gVGhleSBhcmUgbW92ZWQgaW50byB0aGVcbiAgIG1vZHVsZXMsIHNvIHRoYXQgdGhleSBhcmUgaGlkZGVuIGJ5IGNvZGUgZm9sZGluZyB3aGVuIHlvdSAodGhlIHJlYWRlciEpIGFyZVxuICAgbm90IGludGVyZXN0ZWQgaW4gdGhvc2UgbW9kdWxlcy5cblxuXG4gICAqIERvY3VtZW50YXRpb25cblxuICAgVGhlIGRvY3VtZW50YXRpb24gYmVnaW5zIHdpdGggYW4gb3ZlcnZpZXcgb2YgbWFqb3IgY29uY2VwdHMgYW5kIGNvbXBvbmVudHMuXG4gICBUaGlzIG92ZXJ2aWV3IHB1dHMgZXZlcnl0aGluZyBpbnRvIGNvbnRleHQuIFlvdSBkb24ndCBoYXZlIHRvIHJlYWQgdGhlIHdob2xlXG4gICB0aGluZy4gVGhlIG92ZXJ2aWV3IGJlZ2lucyB3aXRoIGJhc2ljIGNvbmNlcHRzLCBtb3ZlcyBvbiB0byBhZHZhbmNlZCBvbmVzLFxuICAgYW5kIHRoZW4gZ2V0cyBpbnRvIHRoZSB0cnVseSBlc290ZXJpYy4gWW91IGNhbiByZWFkIGFib3V0IGVhY2ggY29uY2VwdCBvbiBhblxuICAgYXMtbmVlZGVkIGJhc2lzLiBIb3dldmVyLCBvbmNlIHlvdSBoYXZlIHJlYWQgdGhlIHdob2xlIG92ZXJ2aWV3LCB5b3Ugd2lsbCBiZVxuICAgYXdhcmUgb2YgKmV2ZXJ5dGhpbmcqIHRoYXQgaXMgbmVlZGVkIHRvIHVuZGVyc3RhbmQsIGFuZCB3b3JrIHdpdGgsIHRoZSBjb3JlXG4gICBvZiBMd3QuXG5cbiAgIExpdHRlcmVkIGluIHRoZSBjb2RlIGFyZSBhZGRpdGlvbmFsIGNvbW1lbnRzLCB0aGF0IGdvIGluLWRlcHRoIG9uIHZhcmlvdXNcbiAgIGxvY2FsIGltcGxlbWVudGF0aW9uIGRldGFpbHMsIG9wcG9ydHVuaXRpZXMsIHJlZ3JldHMsIGFuZCB0aGUgbGlrZS5cblxuICAgVGhlIHNlY3Rpb25zIChtb2R1bGVzKSBvZiB0aGUgY29kZSBjb3JyZXNwb25kIGNsb3NlbHkgdG8gc2VjdGlvbnMgb2YgdGhlXG4gICBvdmVydmlldy5cblxuXG4gICAqIFdoaXRlc3BhY2VcblxuICAgVGhlIHRvdGFsIGxpbmUgY291bnQgb2YgdGhpcyBmaWxlIG1heSBzZWVtIGZyaWdodGVuaW5nLCBidXQgb25lIHRoaXJkIG9mIGl0XG4gICBpcyB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cywgYm90aCB0aGVyZSB0byBoZWxwIHlvdSByZWFkIHRoZSByZW1haW5pbmcgdHdvXG4gICB0aGlyZHMhXG5cbiAgIEFsc28sIHdpdGhpbiB0aG9zZSB0d28gdGhpcmRzLCB0aGVyZSBhcmUgbGFyZ2UgZ3JvdXBzIG9mIGZ1bmN0aW9ucyB0aGF0IGFyZVxuICAgcmVwZXRpdGl2ZSBhbmQgZm9ybXVsYWljLCBzbyB0aGVyZSBpcyBtdWNoIGxlc3MgY29uY2VwdHVhbGx5LXVuaXF1ZSBjb2RlIGluXG4gICBMd3QgdGhhbiB5b3UgbWlnaHQgdGhpbmsgYXQgZmlyc3QuXG5cblxuICAgKiBQbGVhc2UgZWRpdCB0aGUgY29kZSBhbmQgdGhlIGRvY3MhXG5cbiAgIFRoaXMgY29kZSBpcyBtZWFudCB0byBiZSByZWFkYWJsZSwgYW5kIHRvIGJlIGVkaXRlZC4gSWYgeW91IGFyZSByZWFkaW5nXG4gICBzb21ldGhpbmcsIGFuZCB0aGluayB0aGVyZSBpcyBhIGJldHRlciB3YXkgdG8gZXhwcmVzcyBpdCwgcGxlYXNlIGdvIGFoZWFkIGFuZFxuICAgb3BlbiBhIHB1bGwgcmVxdWVzdCB0byB0aGUgTHd0IHJlcG9zaXRvcnkgYXRcblxuICAgICBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3RcblxuICAgRXZlbiBpZiB5b3VyIHB1bGwgcmVxdWVzdCBzb21laG93IGRvZXNuJ3QgZ2V0IG1lcmdlZCwgeW91IHdpbGwgaGF2ZSBlZHVjYXRlZFxuICAgdGhlIG1haW50YWluZXJzLCBub3QgdG8gbWVudGlvbiBvdGhlciBjb250cmlidXRvcnMsIGFuZCB1c2Vycy4gVGhpcyBpcyB0cnVlXG4gICBldmVuIGlmIHRoZSBjaGFuZ2UgaXMgdHJpdmlhbCAtLSBzb21ldGltZXMsIG1haW50YWluZXJzIGp1c3QgbmVlZCB0byBiZVxuICAgZWR1Y2F0ZWQgbXVsdGlwbGUgdGltZXMgYmVmb3JlIHRoZXkgc2VlIHRoZSB3aXNkb20gb2YgaXQgOi9cblxuICAgTGlrZXdpc2UsIGlmIHlvdSB3b3VsZCBsaWtlIHRvIG1ha2UgYSBjb2RlIGNvbnRyaWJ1dGlvbiB0byB0aGUgTHd0IGNvcmUsIGl0XG4gICBpcyBxdWl0ZSB3ZWxjb21lLCBhbmQgd2UgaG9wZSB0aGF0IHRoaXMgY29kZSBpcyByZWFkYWJsZSBlbm91Z2ggZm9yIHlvdSB0byBiZVxuICAgYWJsZSB0byBtYWtlIGl0IVxuXG5cbiAgIEVuam95ISAqKVxuXG5cblxuKCogT3ZlcnZpZXdcblxuICAgSW4gdGhpcyBmaWxlLCB0aGVyZSBpcyBhIFwibW9kZWxcIiBmdW5jdGlvbiAtLSBbTHd0LmJpbmRdIC0tIHdoaWNoIHB1bGxzXG4gICB0b2dldGhlciBtYW55ICh0aG91Z2ggbm90IGFsbCkgb2YgdGhlIGNvbmNlcHRzIGFuZCBoZWxwZXJzIGRpc2N1c3NlZCBpbiB0aGlzXG4gICBvdmVydmlldy4gVG8gZmluZCBpdCwgc2VhcmNoIGZvciBcImxldCBiaW5kLFwiIGFuZCB5b3UgY2FuIGV4YW1pbmUgaXQgd2hpbGVcbiAgIHJlYWRpbmcgdGhlIG92ZXJ2aWV3LiBUaGUgYXV0aG9ycyBvZiB0aGlzIGZpbGUgaW50ZW5kIHRvIHB1dCBleHRyYSBlZmZvcnRcbiAgIGludG8gd3JpdGluZyBuaWNlIGNvbW1lbnRzIGluc2lkZSBbTHd0LmJpbmRdIDopXG5cblxuICAgMC4gTWFpbiBtZWNoYW5pc20gYW5kIHR3byBhc3BlY3RzXG5cbiAgIFRoZSBMd3QgaW50ZXJmYWNlIChbbHd0Lm1saV0pIHByb3ZpZGVzIG9uZSBtYWluIG1lY2hhbmlzbSwgcHJvbWlzZXMsIGFuZCB0d29cbiAgIFwiYXNwZWN0cyxcIiB3aGljaCBhcmUgKm5vdCogbmVjZXNzYXJ5IHRvIHVuZGVyc3RhbmQgdGhlIG1haW4gbWVjaGFuaXNtXG4gICBwcm9taXNlcywgYnV0IHRoZXkgYXJlIHN0aWxsIHRoZXJlOlxuXG4gICAtIHByb21pc2UgY2FuY2VsbGF0aW9uXG4gICAtIHNlcXVlbmNlLWFzc29jaWF0ZWQgc3RvcmFnZVxuXG4gICBJZiB5b3UgYXJlIG5vdCBpbnRlcmVzdGVkIGluIGNhbmNlbGxhdGlvbiBvciBzdG9yYWdlLCB5b3UgY2FuIGlnbm9yZSB0aGVzZVxuICAgdHdvIGNvbXBsaWNhdGlvbnMsIGFuZCBzdGlsbCBnZXQgYSBwcmV0dHkgZ29vZCB1bmRlcnN0YW5kaW5nIG9mIHRoZSBjb2RlLiBUb1xuICAgaGVscCwgYWxsIGlkZW50aWZpZXJzIHJlbGF0ZWQgdG8gY2FuY2VsbGF0aW9uIGNvbnRhaW4gdGhlIHN0cmluZyBcImNhbmNlbCxcIlxuICAgYW5kIGFsbCBpZGVudGlmaWVycyByZWxhdGVkIHRvIHN0b3JhZ2UgY29udGFpbiBcInN0b3JhZ2UuXCJcblxuXG4gICAxLiBQcm9taXNlc1xuXG4gICBBIHByb21pc2UgaXMgYSBjZWxsIHRoYXQgY2FuIGJlIGluIG9uZSBvZiB0d28gc3RhdGVzOiBcInJlc29sdmVkXCIgb3JcbiAgIFwicGVuZGluZy5cIlxuXG4gICAtIFJlc29sdmVkIHByb21pc2VzXG5cbiAgICAgQSByZXNvbHZlZCBwcm9taXNlIGlzIGVpdGhlciBcImZ1bGZpbGxlZFwiIHdpdGggYSB2YWx1ZSwgb3IgXCJyZWplY3RlZFwiIHdpdGhcbiAgICAgYW4gZXhjZXB0aW9uLiBUaGUgc3RhdGUgb2YgYSByZXNvbHZlZCBwcm9taXNlIHdpbGwgbmV2ZXIgY2hhbmdlIGFnYWluOiBhXG4gICAgIHJlc29sdmVkIHByb21pc2UgaXMgaW1tdXRhYmxlLiBBIHJlc29sdmVkIHByb21pc2UgaXMgYmFzaWNhbGx5IGVxdWl2YWxlbnRcbiAgICAgdG8gYW4gWygnYSwgZXhuKSBTdGRsaWIucmVzdWx0XS4gUmVzb2x2ZWQgcHJvbWlzZXMgYXJlIHByb2R1Y2VkIGluIHR3b1xuICAgICB3YXlzOlxuXG4gICAgIC0gW0x3dC5yZXR1cm5dLCBbTHd0LmZhaWxdLCBhbmQgcmVsYXRlZCBmdW5jdGlvbnMsIHByb2R1Y2UgXCJ0cml2aWFsXCJcbiAgICAgICBwcm9taXNlcyB0aGF0IGFyZSByZXNvbHZlZCBmcm9tIHRoZSBzdGFydC5cbiAgICAgLSBUaGUgb3RoZXIgd2F5IGlzIHRvIHJlc29sdmUgYSBwcm9taXNlIHRoYXQgc3RhcnRlZCBvdXQgcGVuZGluZy5cblxuICAgICBOb3RlIHRoYXQgcmVqZWN0ZWQgcHJvbWlzZXMgaGF2ZSBub3RoaW5nIHRvIGRvIHdpdGggdW5oYW5kbGVkIGV4Y2VwdGlvbnMuXG5cbiAgIC0gUGVuZGluZyBwcm9taXNlc1xuXG4gICAgIC4uLmFyZSB0aG9zZSB0aGF0IG1heSBiZWNvbWUgcmVzb2x2ZWQgaW4gdGhlIGZ1dHVyZS4gRWFjaCBwZW5kaW5nIHByb21pc2VcbiAgICAgY2FycmllcyBhIGxpc3Qgb2YgY2FsbGJhY2tzLiBUaGVzZSBjYWxsYmFja3MgYXJlIGFkZGVkIGJ5IGZ1bmN0aW9ucyBsaWtlXG4gICAgIFtMd3QuYmluZF0sIGFuZCBjYWxsZWQgYnkgTHd0IGlmL3doZW4gdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQuIFRoZXNlXG4gICAgIGNhbGxiYWNrcyB0eXBpY2FsbHkgZW5kIHVwIHJlc29sdmluZyBhZGRpdGlvbmFsIHByb21pc2VzOyBzZWUgc2VjdGlvblxuICAgICBcIlJlc29sdXRpb24gbG9vcFwiIGJlbG93LlxuXG4gICAgIFBlbmRpbmcgcHJvbWlzZXMgYXJlIHByb2R1Y2VkIGluIHRocmVlIHdheXMsIGFjY29yZGluZyB0byBob3cgdGhleSBjYW4gYmVcbiAgICAgcmVzb2x2ZWQ6XG5cbiAgICAgLSBJbml0aWFsIHByb21pc2VzXG5cbiAgICAgICAuLi5hcmUgY3JlYXRlZCBieSBbTHd0LndhaXRdIGFuZCBbTHd0LnRhc2tdLiBUaGUgdXNlciBvZiBMd3QgcmVzb2x2ZXNcbiAgICAgICB0aGVzZSBwcm9taXNlcyBtYW51YWxseSwgdGhyb3VnaCB0aGUgcmVzb2x2ZXJzIHJldHVybmVkIGJ5IHRob3NlXG4gICAgICAgZnVuY3Rpb25zLlxuXG4gICAgIC0gU2VxdWVudGlhbCBjb21wb3NpdGlvblxuXG4gICAgICAgRm9yIGV4YW1wbGUsIFtMd3QuYmluZF0uIFRoZXNlIHByb21pc2VzIG9ubHkgYXJlIG9ubHkgcmVzb2x2ZWQgd2hlbiB0aGVcbiAgICAgICBwcmVjZWRpbmcgc2VxdWVuY2Ugb2YgcHJvbWlzZXMgcmVzb2x2ZXMuIFRoZSB1c2VyIGNhbm5vdCByZXNvbHZlIHRoZXNlXG4gICAgICAgcHJvbWlzZXMgZGlyZWN0bHkgKGJ1dCBzZWUgdGhlIHNlY3Rpb24gb24gY2FuY2VsbGF0aW9uIGJlbG93KS5cblxuICAgICAtIENvbmN1cnJlbnQgY29tcG9zaXRpb25cblxuICAgICAgIEZvciBleGFtcGxlLCBbTHd0LmpvaW5dIG9yIFtMd3QuY2hvb3NlXS4gVGhlc2UgcHJvbWlzZXMgYXJlIG9ubHkgcmVzb2x2ZWRcbiAgICAgICB3aGVuIGFsbCBvciBvbmUgb2YgYSBzZXQgb2YgXCJwcmVjZWRpbmdcIiBwcm9taXNlcyByZXNvbHZlLiBUaGUgdXNlciBjYW5ub3RcbiAgICAgICByZXNvbHZlIHRoZXNlIHByb21pc2VzIGRpcmVjdGx5IChidXQgc2VlIHRoZSBzZWN0aW9uIG9uIGNhbmNlbGxhdGlvblxuICAgICAgIGJlbG93KS5cblxuXG4gICAyLiBSZXNvbHZlcnNcblxuICAgUmVzb2x2ZXJzIGFyZSBnaXZlbiB0byB0aGUgdXNlciBieSBbTHd0LndhaXRdIGFuZCBbTHd0LnRhc2tdLCBhbmQgY2FuIGJlIHVzZWRcbiAgIGJ5IHRoZSB1c2VyIHRvIHJlc29sdmUgdGhlIGNvcnJlc3BvbmRpbmcgcHJvbWlzZXMuIE5vdGUgdGhhdCB0aGlzIG1lYW5zIHRoZVxuICAgdXNlciBvbmx5IGV2ZXIgZ2V0cyByZXNvbHZlcnMgZm9yIGluaXRpYWwgcHJvbWlzZXMuXG5cbiAgIEludGVybmFsbHksIHJlc29sdmVycyBhcmUgdGhlIGV4YWN0IHNhbWUgb2JqZWN0cyBhcyB0aGUgcHJvbWlzZXMgdGhleVxuICAgcmVzb2x2ZSwgZXZlbiB0aG91Z2ggdGhlIHJlc29sdmVyIGlzIGV4cG9zZWQgYXMgYSByZWZlcmVuY2Ugb2YgYSBkaWZmZXJlbnRcbiAgIHR5cGUgYnkgW2x3dC5tbGldLiBGb3IgZGV0YWlscyBvbiB3aHksIHNlZSBzZWN0aW9uIFwiVHlwZSBzeXN0ZW0gYWJ1c2VcIiBiZWxvdy5cblxuXG4gICAzLiBDYWxsYmFja3NcblxuICAgLi4uYXJlIGF0dGFjaGVkIGJ5IEx3dCB0byBwZW5kaW5nIHByb21pc2VzLCBhbmQgYXJlIHJ1biBieSBMd3QgaWYvd2hlbiB0aG9zZVxuICAgcHJvbWlzZXMgYXJlIHJlc29sdmVkLiBUaGVzZSBjYWxsYmFja3MgYXJlIG5vdCBkaXJlY3RseSBleHBvc2VkIHRocm91Z2hcbiAgIFtsd3QubWxpXSAtLSB0aGV5IGFyZSBhIGxvdy1sZXZlbCBtZWNoYW5pc20uIEZvciBleGFtcGxlLCB0byBpbXBsZW1lbnRcbiAgIFtMd3QuYmluZCBwIGZdLCBMd3QgYXR0YWNoZXMgYSBjYWxsYmFjayB0byBbcF0gdGhhdCBkb2VzIHNvbWUgaW50ZXJuYWwgTHd0XG4gICBib29rLWtlZXBpbmcsIGFuZCB0aGVuIGNhbGxzIFtmXSBpZiBbcF0gaXMgZnVsZmlsbGVkLCBhbmQgZG9lcyBzb21ldGhpbmcgZWxzZVxuICAgaWYgW3BdIGlzIHJlamVjdGVkLlxuXG4gICBDYWxsYmFja3MgY29tZSBpbiB0d28gZmxhdm9yczogcmVndWxhciBjYWxsYmFja3MgYW5kIGNhbmNlbCBjYWxsYmFja3MuIFRoZVxuICAgb25seSBtYXRlcmlhbCBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZW0gYXJlIHRoYXQ6XG5cbiAgIC0gcmVndWxhciBjYWxsYmFja3MgYXJlIGFsd2F5cyBjYWxsZWQgd2hlbiBhIHByb21pc2UgaXMgcmVzb2x2ZWQsIGJ1dCBjYW5jZWxcbiAgICAgY2FsbGJhY2tzIGFyZSBjYWxsZWQsIGluIGFkZGl0aW9uLCBvbmx5IGlmIHRoZSBwcm9taXNlIGlzIGNhbmNlbGVkLCBhbmRcbiAgIC0gYWxsIGNhbmNlbCBjYWxsYmFja3Mgb2YgYSBwcm9taXNlIGFyZSBjYWxsZWQgYmVmb3JlIGFueSByZWd1bGFyIGNhbGxiYWNrXG4gICAgIGlzIGNhbGxlZC5cblxuICAgQ2FuY2VsbGF0aW9uIGlzIGEgc3BlY2lhbCBjYXNlIG9mIHJlc29sdXRpb24sIGluIHBhcnRpY3VsYXIsIGEgc3BlY2lhbCBjYXNlXG4gICBvZiByZWplY3Rpb24sIGJ1dCBzZWUgdGhlIHNlY3Rpb24gb24gY2FuY2VsbGF0aW9uIGxhdGVyIGJlbG93LlxuXG5cbiAgIDQuIFJlc29sdXRpb24gbG9vcFxuXG4gICBSZXNvbHZpbmcgYSBwZW5kaW5nIHByb21pc2UgdHJpZ2dlcnMgaXRzIGNhbGxiYWNrcywgYW5kIHRob3NlIG1pZ2h0IHJlc29sdmVcbiAgIG1vcmUgcGVuZGluZyBwcm9taXNlcywgdHJpZ2dlcmluZyBtb3JlIGNhbGxiYWNrcywgZXRjLiBUaGlzIGJlaGF2aW9yIGlzIHRoZVxuICAgKnJlc29sdXRpb24gbG9vcCouIEx3dCBoYXMgc29tZSBtYWNoaW5lcnkgdG8gYXZvaWQgc3RhY2sgb3ZlcmZsb3cgYW5kIG90aGVyXG4gICB1bmZvcnR1bmF0ZSBzaXR1YXRpb25zIGR1cmluZyB0aGlzIGxvb3AuXG5cbiAgIFRoaXMgY2hhaW5pbmcgb2YgcHJvbWlzZSByZXNvbHV0aW9ucyB0aHJvdWdoIGNhbGxiYWNrcyBjYW4gYmUgc2VlbiBhcyBhIGtpbmRcbiAgIG9mIHByb21pc2UgZGVwZW5kZW5jeSBncmFwaCwgaW4gd2hpY2ggdGhlIG5vZGVzIGFyZSBwZW5kaW5nIHByb21pc2VzLCBhbmQgdGhlXG4gICBlZGdlcyBhcmUgY2FsbGJhY2tzLiBEdXJpbmcgdGhlIHJlc29sdXRpb24gbG9vcCwgTHd0IHN0YXJ0cyBhdCBzb21lIGluaXRpYWxcbiAgIHByb21pc2UgdGhhdCBpcyBnZXR0aW5nIHJlc29sdmVkIGJ5IHRoZSB1c2VyLCBhbmQgcmVjdXJzaXZlbHkgcmVzb2x2ZXMgYWxsXG4gICBkZXBlbmRlbnQgcHJvbWlzZXMuIFRoZSBncmFwaCBpcyBtb2RpZmllZDogcmVzb2x2ZWQgcHJvbWlzZXMgYXJlIG5vIGxvbmdlclxuICAgcGVuZGluZywgc28gdGhleSBhcmUgbm8gbG9uZ2VyIHBhcnQgb2YgdGhlIGdyYXBoLlxuXG4gICBTb21lIG9mIHRoZXNlIGRlcGVuZGVuY2llcyBhcmUgZXhwbGljaXQgdG8gTHd0LCBlLmcuIHRoZSBjYWxsYmFja3MgcmVnaXN0ZXJlZFxuICAgYnkgW0x3dC5iaW5kXS4gT3RoZXJzIGFyZSBub3QgdmlzaWJsZSB0byBMd3QsIGJlY2F1c2UgdGhlIHVzZXIgY2FuIGFsd2F5c1xuICAgcmVnaXN0ZXIgYSBjYWxsYmFjayB1c2luZyBhIGZ1bmN0aW9uIGxpa2UgW0x3dC5vbl9zdWNjZXNzXSwgYW5kIHVzZSB0aGF0XG4gICBjYWxsYmFjayB0byByZXNvbHZlIGFub3RoZXIgaW5pdGlhbCBwcm9taXNlLiBBbGwgdGhlIGV4cGxpY2l0IGRlcGVuZGVuY2llc1xuICAgYXJlIGNyZWF0ZWQgYnkgTHd0J3Mgb3duIHNlcXVlbnRpYWwgYW5kIGNvbmN1cnJlbnQgY29tcG9zaXRpb24gZnVuY3Rpb25zXG4gICAoc28sIFtMd3QuYmluZF0sIFtMd3Quam9pbl0sIGV0YykuIFdoZXRoZXIgZGVwZW5kZW5jaWVzIGFyZSBleHBsaWNpdCBvciBub3RcbiAgIGlzIHJlbGV2YW50IG9ubHkgdG8gY2FuY2VsbGF0aW9uLlxuXG5cbiAgIDUuIENhbmNlbGxhdGlvblxuXG4gICBBcyBkZXNjcmliZWQgYWJvdmUsIG9yZGluYXJ5IHByb21pc2UgcmVzb2x1dGlvbiBwcm9jZWVkcyBmcm9tIGFuIGluaXRpYWxcbiAgIHByb21pc2UsIGZvcndhcmQgYWxvbmcgY2FsbGJhY2tzIHRocm91Z2ggdGhlIGRlcGVuZGVuY3kgZ3JhcGguIFNpbmNlIGl0XG4gICBzdGFydHMgZnJvbSBhbiBpbml0aWFsIHByb21pc2UsIGl0IGNhbiBvbmx5IGJlIHRyaWdnZXJlZCB1c2luZyBhIHJlc29sdmVyLlxuXG4gICBDYW5jZWxsYXRpb24gaXMgYSBzb3J0IG9mIGR1YWwgdG8gb3JkaW5hcnkgcmVzb2x1dGlvbi4gSW5zdGVhZCBvZiBzdGFydGluZyBhdFxuICAgYW4gaW5pdGlhbCBwcm9taXNlL3Jlc29sdmVyLCBjYW5jZWxsYXRpb24gc3RhcnRzIGF0ICphbnkqIHByb21pc2UuIEl0IHRoZW5cbiAgIGdvZXMgKmJhY2t3YXJkcyogdGhyb3VnaCB0aGUgZXhwbGljaXQgZGVwZW5kZW5jeSBncmFwaCwgbG9va2luZyBmb3JcbiAgIGNhbmNlbGFibGUgaW5pdGlhbCBwcm9taXNlcyB0byBjYW5jZWwgLS0gdGhvc2UgdGhhdCB3ZXJlIGNyZWF0ZWQgYnlcbiAgIFtMd3QudGFza10uIEFmdGVyIGZpbmRpbmcgdGhlbSwgY2FuY2VsbGF0aW9uIHJlc29sdmVzIHRoZW0gbm9ybWFsbHkgd2l0aFxuICAgW1JlamVjdGVkIEx3dC5DYW5jZWxlZF0sIGNhdXNpbmcgYW4gb3JkaW5hcnkgcHJvbWlzZSByZXNvbHV0aW9uIHByb2Nlc3MuXG5cbiAgIFRvIHN1bW1hcml6ZSwgY2FuY2VsbGF0aW9uIGlzIGEgd2F5IHRvIHRyaWdnZXIgYW4gKm9yZGluYXJ5KiByZXNvbHV0aW9uIG9mXG4gICBwcm9taXNlcyBjcmVhdGVkIHdpdGggW0x3dC50YXNrXSwgYnkgZmlyc3Qgc2VhcmNoaW5nIGZvciB0aGVtIGluIHRoZSBwcm9taXNlXG4gICBkZXBlbmRlbmN5IGdyYXBoICh3aGljaCBpcyBhc3NlbWJsZWQgYnkgW0x3dC5iaW5kXSwgW0x3dC5qb2luXSwgZXRjKS5cblxuICAgVGhpcyBiYWNrd2FyZHMgc2VhcmNoIGlzIHRyaWdnZXJlZCBvbmx5IGJ5IFtMd3QuY2FuY2VsXS4gSXQgaXMgYWxzbyBwb3NzaWJsZVxuICAgZm9yIHRoZSB1c2VyIHRvIGNhbmNlbCBhIHByb21pc2UgZGlyZWN0bHkgYnkgcmVqZWN0aW5nIGl0IHdpdGhcbiAgIFtMd3QuQ2FuY2VsZWRdLCBidXQgaW4gYWxsIGNhc2VzIHdoZXJlIHRoZSB1c2VyIGNhbiBkbyBzbywgdGhlIHNlYXJjaCB3b3VsZFxuICAgYmUgcmVkdW5kYW50IGFueXdheSAtLSB0aGUgdXNlciBoYXMgb25seSB0d28gd2F5cyBvZiBkaXJlY3RseSByZWplY3RpbmcgYVxuICAgcHJvbWlzZSB3aXRoIFtMd3QuQ2FuY2VsZWRdIChvciBhbnkgZXhjZXB0aW9uLCBmb3IgdGhhdCBtYXR0ZXIpOlxuXG4gICAtIFRoZSB1c2VyIGNhbiBjcmVhdGUgYW4gaW5pdGlhbCBwcm9taXNlLCB0aGVuIHJlamVjdCBpdCB0aHJvdWdoIGl0c1xuICAgICByZXNvbHZlci4gVGhlIHNlYXJjaCBpcyByZWR1bmRhbnQgYmVjYXVzZSBpdCB3b3VsZCBmaW5kIG9ubHkgdGhlIHNhbWVcbiAgICAgaW5pdGlhbCBwcm9taXNlIHRvIGNhbmNlbC5cbiAgIC0gVGhlIHVzZXIgY2FuIGNyZWF0ZSBhIHRyaXZpYWwgcHJvbWlzZSBieSBjYWxsaW5nIFtMd3QuZmFpbCBMd3QuQ2FuY2VsZWRdLlxuICAgICBUaGUgc2VhcmNoIGlzIGFnYWluIHJlZHVuZGFudDsgaW4gdGhpcyBjYXNlIGl0IHdvdWxkIGZpbmQgbm90aGluZyB0b1xuICAgICBjYW5jZWwuXG5cbiAgIE5vdGUgdGhhdCB0aGVyZSBpcyBhIHF1aXJrOiBvbmx5IHByb21pc2VzIGNyZWF0ZWQgYnkgW0x3dC50YXNrXSBhcmVcbiAgIHN1c2NlcHRpYmxlIHRvIGJlaW5nIGNhbmNlbGVkIGJ5IFtMd3QuY2FuY2VsXSwgYnV0IHRoZSB1c2VyIGNhbiBtYW51YWxseVxuICAgY2FuY2VsIGluaXRpYWwgcHJvbWlzZXMgY3JlYXRlZCBieSBib3RoIFtMd3QudGFza10gYW5kIFtMd3Qud2FpdF0uXG5cbiAgIER1ZSB0byBbTHd0LmNhbmNlbF0sIHByb21pc2UgY2FuY2VsbGF0aW9uLCBhbmQgdGhlcmVmb3JlIHJlc29sdXRpb24sIGNhbiBiZVxuICAgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyIHdpdGhvdXQgYWNjZXNzIHRvIGEgcmVzb2x2ZXIuIFRoaXMgaXMgaW1wb3J0YW50IGZvclxuICAgcmVhc29uaW5nIGFib3V0IHN0YXRlIGNoYW5nZXMgaW4gdGhlIGltcGxlbWVudGF0aW9uIG9mIEx3dCwgYW5kIGlzIHJlZmVyZW5jZWRcbiAgIGluIHNvbWUgaW1wbGVtZW50YXRpb24gZGV0YWlsIGNvbW1lbnRzLlxuXG5cbiAgIDYuIE5vIEkvT1xuXG4gICBUaGUgTHd0IGNvcmUgZGVsaWJlcmF0ZWx5IGRvZXNuJ3QgZG8gSS9PLiBUaGUgcmVzb2x1dGlvbiBsb29wIHN0b3BzIHJ1bm5pbmdcbiAgIG9uY2Ugbm8gcHJvbWlzZXMgY2FuIGJlIHJlc29sdmVkIGltbWVkaWF0ZWx5LiBJdCBoYXMgdG8gYmUgcmVzdGFydGVkIGxhdGVyXG4gICBieSBzb21lIHN1cnJvdW5kaW5nIEkvTyBsb29wLiBUaGlzIEkvTyBsb29wIHR5cGljYWxseSBrZWVwcyB0cmFjayBvZiBwZW5kaW5nXG4gICBwcm9taXNlcyB0aGF0IHJlcHJlc2VudCBibG9ja2VkIG9yIGluLXByb2dyZXNzIEkvTzsgb3RoZXIgcGVuZGluZyBwcm9taXNlc1xuICAgdGhhdCBpbmRpcmVjdGx5IGRlcGVuZCBvbiBJL08gYXJlIG5vdCBleHBsaWNpdGx5IHRyYWNrZWQuIFRoZXkgYXJlIHJldGFpbmVkXG4gICBpbiBtZW1vcnkgYnkgcmVmZXJlbmNlcyBjYXB0dXJlZCBpbnNpZGUgY2FsbGJhY2tzLlxuXG4gICBPbiBVbml4IGFuZCBXaW5kb3dzLCBhIHNlcGFyYXRlIHRvcC1sZXZlbCBsb29wLCB0eXBpY2FsbHkgW0x3dF9tYWluLnJ1bl0sIGlzXG4gICBuZWNlc3NhcnkgdG8gcmVwZWF0ZWRseSBjYWxsIFtzZWxlY3RdLCBbZXBvbGxdLCBvciBba2V2ZW50XSwgYW5kIHJlc29sdmVcbiAgIGJsb2NrZWQgSS9PIHByb21pc2VzLlxuXG4gICBJbiBKYXZhU2NyaXB0LCByZWZlcmVuY2VzIHRvIHByb21pc2VzIGFyZSByZXRhaW5lZCBieSBKYXZhU2NyaXB0IGNvZGUsIHdoaWNoXG4gICBpcywgaW4gdHVybiwgdHJpZ2dlcmVkIGJ5IHRoZSBKUyBlbmdpbmUuIEluIG90aGVyIHdvcmRzLCB0aGUgdG9wLWxldmVsIGxvb3BcbiAgIGlzIGJ1cmllZCBpbnNpZGUgdGhlIEpTIGVuZ2luZS5cblxuICAgVGhpcyBzZXBhcmF0aW9uIG9mIHRoZSBMd3QgY29yZSBmcm9tIHRoZSB0b3AtbGV2ZWwgSS9PIGxvb3Aga2VlcHMgdGhlIGNvcmVcbiAgIHBvcnRhYmxlLlxuXG5cbiAgIDcuIFByb21pc2UgXCJwcm94eWluZ1wiXG5cbiAgIEluIFtMd3QuYmluZCA6ICdhIHQgLT4gKCdhIC0+ICdiIHQpIC0+ICdiIHRdLCB0aGUgb3V0ZXIgWydiIHRdIGlzIGNyZWF0ZWQgYnlcbiAgIFtiaW5kXSBmaXJzdCwgYW5kIHJldHVybmVkIHRvIHRoZSB1c2VyLiBUaGUgaW5uZXIgWydiIHRdIGlzIGNyZWF0ZWQgYnkgdGhlXG4gICB1c2VyIGxhdGVyLCBhbmQgdGhlbiByZXR1cm5lZCB0byBbYmluZF0uIEF0IHRoYXQgcG9pbnQsIFtiaW5kXSBuZWVkcyB0byBtYWtlXG4gICB0aGUgaW5uZXIgYW5kIG91dGVyIFsnYiB0XXMgYmVoYXZlIGlkZW50aWNhbGx5LlxuXG4gICBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSBtYWtpbmcgb25lIG9mIHRoZSBwcm9taXNlcyBwb2ludCB0byB0aGUgb3RoZXIuIFRoZVxuICAgZmlyc3Qgb2YgdGhlIHByb21pc2VzIHRodXMgYmVjb21lcyBhIFwicHJveHksXCIgYW5kIHRoZSBvdGhlciBpcyBpdHNcbiAgIFwidW5kZXJseWluZ1wiIHByb21pc2UuXG5cbiAgIEFmdGVyIHRoYXQsIGFsbCBvcGVyYXRpb25zIHRoYXQgd291bGQgYmUgcGVyZm9ybWVkIGJ5IEx3dCBvbiB0aGUgcHJveHkgYXJlXG4gICBpbnN0ZWFkIHBlcmZvcm1lZCBvbiB0aGUgdW5kZXJseWluZyBwcm9taXNlLiBUaGlzIGlzIGVuc3VyZWQgYnkgdGhlIG51bWVyb3VzXG4gICBjYWxscyB0byB0aGUgaW50ZXJuYWwgZnVuY3Rpb24gW3VuZGVybHlpbmddIGluIHRoaXMgZmlsZS5cblxuICAgQmVjYXVzZSBvZiB0aGUgcGVydmFzaXZlIHVzZSBvZiBbdW5kZXJseWluZ10sIHByb3hpZXMgY2FuIGJlIG1vcmUgb3IgbGVzc1xuICAgaWdub3JlZCBvbiBhIGZpcnN0IHJlYWRpbmcgdGhlIGNvZGUuIEhvd2V2ZXIsIGJlY29taW5nIGEgcHJveHkgaXMgYSBraW5kIG9mXG4gICBzdGF0ZSBjaGFuZ2UsIGFuZCBhbnkgcHJvbWlzZSB0aGF0IGlzIHJldHVybmVkIGJ5IGEgY2FsbGJhY2sgdG8gW2JpbmRdLCBvciB0b1xuICAgYSBzaW1pbGFyIEx3dCBmdW5jdGlvbiwgbWlnaHQgYmVjb21lIGEgcHJveHkuIFRoYXQgbWVhbnM6IGp1c3QgYWJvdXQgYW55XG4gICBwcm9taXNlIHRoYXQgaXMgaGFuZGVkIHRvIHRoZSB1c2VyLCBtaWdodCBiZWNvbWUgYSBwcm94eSBwcm9taXNlIGJ5IHRoZSBuZXh0XG4gICB0aW1lIEx3dCBzZWVzIGl0LiBUaGlzIGlzIGltcG9ydGFudCBmb3IgcmVhc29uaW5nIGFib3V0IHBvc3NpYmxlIHN0YXRlXG4gICBjaGFuZ2VzIGluIGltcGxlbWVudGF0aW9uIG9mIEx3dCwgYW5kIGlzIHJlZmVyZW5jZWQgaW4gc29tZSBpbXBsZW1lbnRhdGlvblxuICAgZGV0YWlsIGNvbW1lbnRzLlxuXG5cbiAgIDguIFNlcXVlbmNlLWFzc29jaWF0ZWQgc3RvcmFnZVxuXG4gICBMd3QgaGFzIGEgZ2xvYmFsIGtleS12YWx1ZSBtYXAuIFRoZSBtYXAgY2FuIGJlIHByZXNlcnZlZCBhY3Jvc3Mgc2VxdWVudGlhbFxuICAgY29tcG9zaXRpb24gZnVuY3Rpb25zLCBzbyB0aGF0IGl0IGhhcyB0aGUgc2FtZSBzdGF0ZSBpbiB0aGUgdXNlcidzIGNhbGxiYWNrXG4gICBbZl0gYXMgaXQgZGlkIGF0IHRoZSB0aW1lIHRoZSB1c2VyIGNhbGxlZCBbTHd0LmJpbmQgcCBmXS5cblxuICAgVGhlIGRldGFpbHMgYXJlIHByZXR0eSBzdHJhaWdodGZvcndhcmQsIGFuZCBkaXNjdXNzZWQgaW4gbW9kdWxlXG4gICBbU2VxdWVuY2VfYXNzb2NpYXRlZF9zdG9yYWdlXS4gVGhlIG1haW4gdGhpbmcgdG8gYmUgYXdhcmUgb2YgaXMgdGhlIG1hbnlcbiAgIHJlZmVyZW5jZXMgdG8gW2N1cnJlbnRfc3RvcmFnZV0gdGhyb3VnaG91dCBMd3QsIHdoaWNoIGFyZSBuZWVkZWQgdG8gcHJvcGVybHlcbiAgIHNhdmUgYW5kIHJlc3RvcmUgdGhlIG1hcHBpbmcuXG5cblxuICAgOS4gVHlwZSBzeXN0ZW0gYWJ1c2VcblxuICAgVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgdGhlIHR5cGUgc3lzdGVtIHNvbWV3aGF0IGV4dGVuc2l2ZWx5LiBHZW50bGVcbiAgIGludHJvZHVjdGlvbnMgY2FuIGJlIGZvdW5kIGhlcmU6XG5cbiAgICAgaHR0cHM6Ly9kaXNjdXNzLm9jYW1sLm9yZy90LzE2MS83XG4gICAgIGh0dHBzOi8vZGlzY3Vzcy5vY2FtbC5vcmcvdC8xNjEvMTZcblxuICAgQSBzaG9ydCBzdW1tYXJ5IGZvbGxvd3MuXG5cbiAgIFRoZSBwcm9taXNlIHN0YXRlIGlzLCBpbnRlcm5hbGx5LCBhIEdBRFQgd2hpY2ggZW5jb2RlcyB0aGUgc3RhdGUgaW4gaXRzIHR5cGVcbiAgIHBhcmFtZXRlcnMuIFRodXMsIGlmIHlvdSBkbyBbbGV0IHAgPSB1bmRlcmx5aW5nIHBdLCB0aGUgc2hhZG93aW5nIHJlZmVyZW5jZVxuICAgW3BdIGlzIHN0YXRpY2FsbHkga25vd24gKm5vdCogdG8gYmUgYSBwcm94eSwgYW5kIHRoZSBjb21waWxlciBrbm93cyB0aGF0IHRoZVxuICAgY29ycmVzcG9uZGluZyBtYXRjaCBjYXNlIFtQcm94eSBfXSBpcyBpbXBvc3NpYmxlLlxuXG4gICBUaGUgZXh0ZXJuYWwgcHJvbWlzZSB0eXBlLCBbJ2EgdF0sIGFuZCB0aGUgZXh0ZXJuYWwgcmVzb2x2ZXIgdHlwZSwgWydhIHVdLFxuICAgYXJlIG5vdCBHQURUcy4gRnVydGhlcm1vcmUsIHRoZXkgYXJlLCByZXNwZWN0aXZlbHksIGNvdmFyaWFudCBhbmRcbiAgIGNvbnRyYXZhcmlhbnQgaW4gWydhXSwgd2hpbGUgdGhlIGludGVybmFsIHByb21pc2UgdHlwZSBpcyBpbnZhcmlhbnQgaW4gWydhXS5cbiAgIEZvciB0aGVzZSByZWFzb25zLCB0aGVyZSBhcmUgbmFzdHkgY2FzdHMgYmV0d2VlbiBbJ2EgdF0sIFsnYSB1XSwgYW5kIHRoZVxuICAgaW50ZXJuYWwgcHJvbWlzZSB0eXBlLiBUaGUgaW1wbGVtZW50YXRpb24gaXMsIG9mIGNvdXJzZSwgd3JpdHRlbiBpbiB0ZXJtcyBvZlxuICAgdGhlIGludGVybmFsIHR5cGUuXG5cbiAgIENhc3RpbmcgZnJvbSBhbiBbJ2EgdF0gdG8gYW4gaW50ZXJuYWwgcHJvbWlzZSBwcm9kdWNlcyBhIHJlZmVyZW5jZSBmb3JcbiAgIHdoaWNoIHRoZSBzdGF0ZSBpcyBcInVua25vd25cIjogdGhpcyBpcyBzaW11bGF0ZWQgd2l0aCBhIGhlbHBlciBHQURULCB3aGljaFxuICAgZW5jb2RlcyBleGlzdGVudGlhbCB0eXBlcy4gVGhlcmUgYXJlIHNldmVyYWwgc2ltaWxhciBjYXN0cywgd2hpY2ggYXJlIHVzZWRcbiAgIHRvIGRvY3VtZW50IHBvc3NpYmxlIHN0YXRlIGNoYW5nZXMgYmV0d2VlbiB0aGUgdGltZSBhIHByb21pc2UgaXMgY3JlYXRlZCxcbiAgIGFuZCB0aGUgbGF0ZXIgdGltZSBpdCBpcyB1c2VkIGluIGEgY2FsbGJhY2suIFlvdSBjYW4gc2VlIHRoZXNlIGNhc3RzIGluXG4gICBhY3Rpb24gaW4gW0x3dC5iaW5kXS4gVGhlIGNhc3Qgc3ludGF4IGlzIHByZXR0eSBsaWdodCwgYW5kLCBiZXNpZGVzIGJlaW5nXG4gICBjb21tZW50ZWQgaW4gW2JpbmRdLCBhbGwgc3VjaCBjYXN0cyBhcmUgZG9jdW1lbnRlZCBpbiBtb2R1bGVzIFtQdWJsaWNfdHlwZXNdXG4gICBhbmQgW0Jhc2ljX2hlbHBlcnNdLlxuXG5cbiAgIElmIHlvdSd2ZSBtYWRlIGl0IHRoaXMgZmFyLCB5b3UgYXJlIGFuIEx3dCBleHBlcnQhIFJlam9pY2UhICopXG5cblxuXG4oKiBbTHd0X3NlcXVlbmNlXSBpcyBkZXByZWNhdGVkIOKAkyB3ZSBkb24ndCB3YW50IHVzZXJzIG91dHNpZGUgTHd0IHVzaW5nIGl0LlxuICAgSG93ZXZlciwgaXQgaXMgc3RpbGwgdXNlZCBpbnRlcm5hbGx5IGJ5IEx3dC4gU28sIGJyaWVmbHkgZGlzYWJsZSB3YXJuaW5nIDNcbiAgIChcImRlcHJlY2F0ZWRcIiksIGFuZCBjcmVhdGUgYSBsb2NhbCwgbm9uLWRlcHJlY2F0ZWQgYWxpYXMgZm9yXG4gICBbTHd0X3NlcXVlbmNlXSB0aGF0IGNhbiBiZSByZWZlcnJlZCB0byBieSB0aGUgcmVzdCBvZiB0aGUgY29kZSBpbiB0aGlzXG4gICBtb2R1bGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFueSBtb3JlIHdhcm5pbmdzLiAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubW9kdWxlIEx3dF9zZXF1ZW5jZSA9IEx3dF9zZXF1ZW5jZVxuW0BAQG9jYW1sLndhcm5pbmcgXCIrM1wiXVxuXG4oKiBTb21lIHNlcXVlbmNlLWFzc29jaWF0ZWQgc3RvcmFnZSB0eXBlc1xuXG4gICBTZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2UgaXMgZGVmaW5lZCBhbmQgZG9jdW1lbnRlZCBsYXRlciwgaW4gbW9kdWxlXG4gICBbU2VxdWVuY2VfYXNzb2NpYXRlZF9zdG9yYWdlXS4gSG93ZXZlciwgdGhlIGZvbGxvd2luZyB0eXBlcyBhcmUgbWVudGlvbmVkIGluXG4gICB0aGUgZGVmaW5pdGlvbiBvZiBbcHJvbWlzZV0sIHNvIHRoZXkgbXVzdCBiZSBkZWZpbmVkIGhlcmUgZmlyc3QuICopXG5tb2R1bGUgU3RvcmFnZV9tYXAgPVxuICBNYXAuTWFrZVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IGludFxuICAgICAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gICAgZW5kKVxudHlwZSBzdG9yYWdlID0gKHVuaXQgLT4gdW5pdCkgU3RvcmFnZV9tYXAudFxuXG5cblxubW9kdWxlIE1haW5faW50ZXJuYWxfdHlwZXMgPVxuc3RydWN0XG4gICgqIFBoYW50b20gdHlwZXMgZm9yIHVzZSB3aXRoIHR5cGVzIFtwcm9taXNlXSBhbmQgW3N0YXRlXS4gVGhlc2UgYXJlIG5ldmVyXG4gICAgIGNvbnN0cnVjdGVkOyB0aGUgcHVycG9zZSBvZiB0aGUgY29uc3RydWN0b3JzIGlzIHRvIHByb3ZlIHRvIHRoZSB0eXBlXG4gICAgIGNoZWNrZXIgdGhhdCB0aGVzZSB0eXBlcyBhcmUgZGlzdGluY3QgZnJvbSBlYWNoIG90aGVyLiBXYXJuaW5nIDM3LCBcInVudXNlZFxuICAgICBjb25zdHJ1Y3RvcixcIiB0aGVyZWZvcmUgaGFzIHRvIGJlIHRlbXBvcmFyaWx5IHN1cHByZXNzZWQuICopXG5cbiAgW0BAQG9jYW1sLndhcm5pbmcgXCItMzdcIl1cblxuICB0eXBlIHVuZGVybHlpbmcgPSBwcml2YXRlIFVuZGVybHlpbmdfYW5kX3RoaXNfY29uc3RydWN0b3JfaXNfbm90X3VzZWRcbiAgdHlwZSBwcm94eSA9IHByaXZhdGUgUHJveHlfYW5kX3RoaXNfY29uc3RydWN0b3JfaXNfbm90X3VzZWRcblxuICB0eXBlIHJlc29sdmVkID0gcHJpdmF0ZSBSZXNvbHZlZF9hbmRfdGhpc19jb25zdHJ1Y3Rvcl9pc19ub3RfdXNlZFxuICB0eXBlIHBlbmRpbmcgPSBwcml2YXRlIFBlbmRpbmdfYW5kX3RoaXNfY29uc3RydWN0b3JfaXNfbm90X3VzZWRcblxuICBbQEBAb2NhbWwud2FybmluZyBcIiszN1wiXVxuXG5cblxuICAoKiBQcm9taXNlcyBwcm9wZXIuICopXG5cbiAgdHlwZSAoJ2EsICd1LCAnYykgcHJvbWlzZSA9IHtcbiAgICBtdXRhYmxlIHN0YXRlIDogKCdhLCAndSwgJ2MpIHN0YXRlO1xuICB9XG5cbiAgYW5kIChfLCBfLCBfKSBzdGF0ZSA9XG4gICAgfCBGdWxmaWxsZWQgOiAnYSAgICAgICAgICAgICAgICAgIC0+ICgnYSwgdW5kZXJseWluZywgcmVzb2x2ZWQpIHN0YXRlXG4gICAgfCBSZWplY3RlZCAgOiBleG4gICAgICAgICAgICAgICAgIC0+ICggXywgdW5kZXJseWluZywgcmVzb2x2ZWQpIHN0YXRlXG4gICAgfCBQZW5kaW5nICAgOiAnYSBjYWxsYmFja3MgICAgICAgIC0+ICgnYSwgdW5kZXJseWluZywgcGVuZGluZykgIHN0YXRlXG4gICAgfCBQcm94eSAgICAgOiAoJ2EsIF8sICdjKSBwcm9taXNlIC0+ICgnYSwgcHJveHksICAgICAgJ2MpICAgICAgIHN0YXRlXG5cbiAgKCogTm90ZTpcblxuICAgICBBIHByb21pc2Ugd2hvc2Ugc3RhdGUgaXMgW1Byb3h5IF9dIGlzIGEgXCJwcm94eVwiIHByb21pc2UuIEEgcHJvbWlzZSB3aG9zZVxuICAgICBzdGF0ZSBpcyAqbm90KiBbUHJveHkgX10gaXMgYW4gXCJ1bmRlcmx5aW5nXCIgcHJvbWlzZS5cblxuICAgICBUaGUgXCJ1bmRlcmx5aW5nIHByb21pc2Ugb2YgW3BdXCIgaXM6XG5cbiAgICAgLSBbcF0sIGlmIFtwXSBpcyBpdHNlbGYgdW5kZXJseWluZy5cbiAgICAgLSBPdGhlcndpc2UsIFtwXSBpcyBhIHByb3h5IGFuZCBoYXMgc3RhdGUgW1Byb3h5IHAnXS4gVGhlIHVuZGVybHlpbmdcbiAgICAgICBwcm9taXNlIG9mIFtwXSBpcyB0aGUgdW5kZXJseWluZyBwcm9taXNlIG9mIFtwJ10uXG5cbiAgICAgSW4gb3RoZXIgd29yZHMsIHRvIGZpbmQgdGhlIHVuZGVybHlpbmcgcHJvbWlzZSBvZiBhIHByb3h5LCBMd3QgZm9sbG93cyB0aGVcbiAgICAgW1Byb3h5IF9dIGxpbmtzIHRvIHRoZSBlbmQuICopXG5cbiAgKCogTm90ZTpcblxuICAgICBXaGVuIGEgcHJvbWlzZSBpcyByZXNvbHZlZCwgb3IgYmVjb21lcyBhIHByb3h5LCBpdHMgc3RhdGUgZmllbGQgaXNcbiAgICAgbXV0YXRlZC4gVGhpcyBpbnZhbGlkYXRlcyB0aGUgdHlwZSBpbnZhcmlhbnRzIG9uIHRoZSBwcm9taXNlLiBTZWUgaW50ZXJuYWxcbiAgICAgZnVuY3Rpb24gW3NldF9wcm9taXNlX3N0YXRlXSBmb3IgZGV0YWlscyBhYm91dCB0aGF0LlxuXG4gICAgIFdoZW4gYW4gTHd0IGZ1bmN0aW9uIGhhcyBhIHJlZmVyZW5jZSB0byBhIHByb21pc2UsIGFuZCBhbHNvIHJlZ2lzdGVycyBhXG4gICAgIGNhbGxiYWNrIHRoYXQgaGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBzYW1lIHByb21pc2UsIHRoZSBpbnZhcmlhbnRzIG9uIHRoZVxuICAgICByZWZlcmVuY2UgbWF5IGJlY29tZSBpbnZhbGlkIGJ5IHRoZSB0aW1lIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQuIEFsbCBzdWNoXG4gICAgIGNhbGxiYWNrcyBoYXZlIGNvbW1lbnRzIGV4cGxhaW5pbmcgd2hhdCB0aGUgdmFsaWQgaW52YXJpYW50cyBhcmUgYXQgdGhhdFxuICAgICBwb2ludCwgYW5kL29yIGNhc3RzIHRvICgxKSBnZXQgdGhlIGNvcnJlY3QgdHlwaW5nIGFuZCAoMikgZG9jdW1lbnQgdGhlXG4gICAgIHBvdGVudGlhbCBzdGF0ZSBjaGFuZ2UgZm9yIHJlYWRlcnMgb2YgdGhlIGNvZGUuICopXG5cblxuXG4gICgqIENhbGxiYWNrIGluZm9ybWF0aW9uIGZvciBwZW5kaW5nIHByb21pc2VzLiAqKVxuXG4gIGFuZCAnYSBjYWxsYmFja3MgPSB7XG4gICAgbXV0YWJsZSByZWd1bGFyX2NhbGxiYWNrcyA6ICdhIHJlZ3VsYXJfY2FsbGJhY2tfbGlzdDtcbiAgICBtdXRhYmxlIGNhbmNlbF9jYWxsYmFja3MgIDogJ2EgY2FuY2VsX2NhbGxiYWNrX2xpc3Q7XG4gICAgbXV0YWJsZSBob3dfdG9fY2FuY2VsICAgICA6IGhvd190b19jYW5jZWw7XG4gICAgbXV0YWJsZSBjbGVhbnVwc19kZWZlcnJlZCA6IGludDtcbiAgfVxuXG4gIGFuZCAnYSByZWd1bGFyX2NhbGxiYWNrID0gJ2EgcmVzb2x2ZWRfc3RhdGUgLT4gdW5pdFxuXG4gIGFuZCBjYW5jZWxfY2FsbGJhY2sgPSB1bml0IC0+IHVuaXRcblxuICBhbmQgJ2EgcmVzb2x2ZWRfc3RhdGUgPSAoJ2EsIHVuZGVybHlpbmcsIHJlc29sdmVkKSBzdGF0ZVxuXG4gIGFuZCBob3dfdG9fY2FuY2VsID1cbiAgICB8IE5vdF9jYW5jZWxhYmxlICAgICAgICAgICAgICA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgaG93X3RvX2NhbmNlbFxuICAgIHwgQ2FuY2VsX3RoaXNfcHJvbWlzZSAgICAgICAgIDogICAgICAgICAgICAgICAgICAgICAgICAgICBob3dfdG9fY2FuY2VsXG4gICAgfCBQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSAgICAgOiAoXywgXywgXykgcHJvbWlzZSAgICAgIC0+IGhvd190b19jYW5jZWxcbiAgICB8IFByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCA6IChfLCBfLCBfKSBwcm9taXNlIGxpc3QgLT4gaG93X3RvX2NhbmNlbFxuXG4gIGFuZCAnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3QgPVxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5XG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfY29uY2F0IG9mXG4gICAgICAnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3QgKiAnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3RcbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgb2ZcbiAgICAgICdhIHJlZ3VsYXJfY2FsbGJhY2tcbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFjayBvZlxuICAgICAgJ2EgcmVndWxhcl9jYWxsYmFjayBvcHRpb24gcmVmXG5cbiAgYW5kIF8gY2FuY2VsX2NhbGxiYWNrX2xpc3QgPVxuICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfZW1wdHkgOlxuICAgICAgXyBjYW5jZWxfY2FsbGJhY2tfbGlzdFxuICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY29uY2F0IDpcbiAgICAgICdhIGNhbmNlbF9jYWxsYmFja19saXN0ICogJ2EgY2FuY2VsX2NhbGxiYWNrX2xpc3QgLT5cbiAgICAgICAgJ2EgY2FuY2VsX2NhbGxiYWNrX2xpc3RcbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2NhbGxiYWNrIDpcbiAgICAgIHN0b3JhZ2UgKiBjYW5jZWxfY2FsbGJhY2sgLT5cbiAgICAgICAgXyBjYW5jZWxfY2FsbGJhY2tfbGlzdFxuICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfcmVtb3ZlX3NlcXVlbmNlX25vZGUgOlxuICAgICAgKCdhLCBfLCBfKSBwcm9taXNlIEx3dF9zZXF1ZW5jZS5ub2RlIC0+XG4gICAgICAgICdhIGNhbmNlbF9jYWxsYmFja19saXN0XG5cbiAgKCogTm90ZXM6XG5cbiAgICAgVGhlc2UgdHlwZSBkZWZpbml0aW9ucyBhcmUgZ3VpbHR5IG9mIHBlcmZvcm1pbmcgc2V2ZXJhbCBvcHRpbWl6YXRpb25zLFxuICAgICB3aXRob3V0IHdoaWNoIHRoZXkgd291bGQgYmUgbXVjaCBlYXNpZXIgdG8gdW5kZXJzdGFuZC5cblxuICAgICAtIFRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgWydhIHJlc29sdmVkX3N0YXRlXSBndWFyYW50ZWUgdGhhdCBpdCBpcyBlaXRoZXJcbiAgICAgICBbRnVsZmlsbGVkIF9dIG9yIFtSZWplY3RlZCBfXS4gU28sIGl0IGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICBbKCdhLCBleG4pIFN0ZGxpYi5yZXN1bHRdLCBhbmQsIGluZGVlZCwgc2hvdWxkIGhhdmUgYW4gaWRlbnRpY2FsXG4gICAgICAgbWVtb3J5IHJlcHJlc2VudGF0aW9uLlxuXG4gICAgIC0gQXMgcGVyIHRoZSBPdmVydmlldywgdGhlcmUgYXJlIHJlZ3VsYXIgY2FsbGJhY2tzIGFuZCBjYW5jZWwgY2FsbGJhY2tzLlxuICAgICAgIENhbmNlbCBjYWxsYmFja3MgYXJlIGNhbGxlZCBvbmx5IG9uIGNhbmNlbGxhdGlvbiwgYW5kLCB0aGVuLCBiZWZvcmUgYW55XG4gICAgICAgcmVndWxhciBjYWxsYmFja3MgYXJlIGNhbGxlZC5cblxuICAgICAgIERlc3BpdGUgdGhlIGRpZmZlcmVudCB0eXBlcyBmb3IgdGhlIHR3byBraW5kcyBvZiBjYWxsYmFja3MsIHRoZXkgYXJlXG4gICAgICAgb3RoZXJ3aXNlIHRoZSBzYW1lLiBDYW5jZWwgY2FsbGJhY2tzIGp1c3QgZG9uJ3QgbmVlZCBhIHJlc3VsdCBzdGF0ZVxuICAgICAgIGFyZ3VtZW50LCBiZWNhdXNlIGl0IGlzIGtub3duIHRvIGJlIFtSZWplY3RlZCBDYW5jZWxlZF0uXG5cbiAgICAgLSBSZWd1bGFyIGNhbGxiYWNrcyBhcmUgbm90IGFsbG93ZWQgdG8gcmFpc2UgZXhjZXB0aW9ucy4gQWxsIHJlZ3VsYXJcbiAgICAgICBjYWxsYmFja3MgYXJlIGNyZWF0ZWQgaW4gdGhpcyBmaWxlLCBzbyB0aGlzIGNhbiBiZSBjaGVja2VkLlxuXG4gICAgICAgQ2FuY2VsIGNhbGxiYWNrcyBjYW4gcmFpc2UgZXhjZXB0aW9ucywgYnV0IGlmIHRoZXkgZG8gc28sIHRoZSBleGNlcHRpb25zXG4gICAgICAgYXJlIHBhc3NlZCB0byBbYXN5bmNfZXhjZXB0aW9uX2hvb2tdLlxuXG4gICAgIC0gW2hvd190b19jYW5jZWxdIGltcGxlbWVudHMgdGhlIGRlcGVuZGVuY3kgZ3JhcGggbWVudGlvbmVkIGluIHRoZVxuICAgICAgIE92ZXJ2aWV3LiBJdCBpcyB0cmF2ZXJzZWQgYmFja3dhcmRzIGR1cmluZyBbTHd0LmNhbmNlbF0uIEl0IGlzIGEgR0FEVFxuICAgICAgIGJlY2F1c2Ugd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgYWN0dWFsIHR5cGVzIG9mIHRoZSBwcm9taXNlIHJlZmVyZW5jZXNcbiAgICAgICBzdG9yZWQsIG9yIHRoZWlyIGludmFyaWFudHMuIFRoZSBjb25zdHJ1Y3RvcnMgY29ycmVzcG9uZCB0byBwZW5kaW5nXG4gICAgICAgcHJvbWlzZSBraW5kcyBhcyBmb2xsb3dzOlxuICAgICAgICAgLSBbTm90X2NhbmNlbGFibGVdOiBpbml0aWFsLCBbTHd0LndhaXRdLlxuICAgICAgICAgLSBbQ2FuY2VsX3RoaXNfcHJvbWlzZV06IGluaXRpYWwsIFtMd3QudGFza10uXG4gICAgICAgICAtIFtQcm9wYWdhdGVfY2FuY2VsX3RvX29uZV06IHNlcXVlbnRpYWwgY29tcG9zaXRpb24sIGUuZy4gW0x3dC5iaW5kXS5cbiAgICAgICAgIC0gW1Byb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbF06IGNvbmN1cnJlbnQgY29tcG9zaXRpb24sIGUuZy5cbiAgICAgICAgICAgW0x3dC5qb2luXS5cblxuICAgICAtIFRoZSB0d28gY2FsbGJhY2sgbGlzdCB0eXBlcyBhcmUgb3JkaW5hcnkgYXBwZW5kLWZyaWVuZGx5IGxpc3RzLCB3aXRoIHR3b1xuICAgICAgIG9wdGltaXphdGlvbnMgaW5saW5lZDpcblxuICAgICAgIC0gWydhIHJlZ3VsYXJfY2FsbGJhY2tfbGlzdF0gYXBwYXJlbnRseSBoYXMgdHdvIFwia2luZHNcIiBvZiByZWd1bGFyXG4gICAgICAgICBjYWxsYmFja3MsIGltcGxpY2l0bHkgcmVtb3ZlZCBhbmQgZXhwbGljaXRseSByZW1vdmFibGUuIEFsbCBjYWxsYmFja3NcbiAgICAgICAgIGFyZSByZW1vdmFibGUuIEl0J3MganVzdCB0aGF0LCBmb3Igc29tZSBjYWxsYmFja3MsIHRoZXkgd2lsbCBvbmx5IGJlXG4gICAgICAgICByZW1vdmVkIGF0IHRoZSBzYW1lIHRpbWUgdGhhdCB0aGUgcHJvbWlzZSB0aGV5IGFyZSBhdHRhY2hlZCB0byBiZWNvbWVzXG4gICAgICAgICByZXNvbHZlZC4gV2hlbiB0aGF0IGhhcHBlbnMsIHRoZSBlbnRpcmUgc3RhdGUgb2YgdGhhdCBwcm9taXNlIGNoYW5nZXNcbiAgICAgICAgIHRvIFtGdWxmaWxsZWQgX10gb3IgW1JlamVjdGVkIF9dLCBhbmQgdGhlIHJlZmVyZW5jZSB0byB0aGUgd2hvbGVcbiAgICAgICAgIGNhbGxiYWNrIGxpc3QgaXMgc2ltcGx5IGxvc3QuIFRoaXMgXCJyZW1vdmVzXCIgdGhlIGNhbGxiYWNrLiBGb3IgdGhlc2VcbiAgICAgICAgIGNhbGxiYWNrcywgWydhIHJlZ3VsYXJfY2FsbGJhY2tfbGlzdF0gYXR0ZW1wdHMgdG8gdHJpbSBhbiBvcHRpb24gYW5kIGFcbiAgICAgICAgIHJlZmVyZW5jZSBjZWxsIHdpdGggdGhlXG4gICAgICAgICBbUmVndWxhcl9jYWxsYmFja19saXN0X2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFja10gY29uc3RydWN0b3IuXG5cbiAgICAgICAtIFsnYSBjYW5jZWxfY2FsbGJhY2tfbGlzdF0gaGFzXG4gICAgICAgICBbQ2FuY2VsX2NhbGxiYWNrX2xpc3RfcmVtb3ZlX3NlcXVlbmNlX25vZGUgbm9kZV0sIHdoaWNoIGlzIHRoZSBzYW1lIGFzXG4gICAgICAgICBbQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY2FsbGJhY2sgKF8sIChmdW4gXyAtPlxuICAgICAgICAgICBMd3Rfc2VxdWVuY2UucmVtb3ZlIG5vZGUpKV0uXG4gICAgICAgICBUaGlzIHdhcyBwcm9iYWJseSBkb25lIHRvIGF2b2lkIGEgY2xvc3VyZSBhbGxvY2F0aW9uLlxuXG4gICAgIC0gVGhlIFtjbGVhbnVwc19kZWZlcnJlZF0gZmllbGQgaXMgZXhwbGFpbmVkIGluIG1vZHVsZVxuICAgICAgIFtQZW5kaW5nX2NhbGxiYWNrc10uICopXG5lbmRcbm9wZW4gTWFpbl9pbnRlcm5hbF90eXBlc1xuXG5cblxubW9kdWxlIFB1YmxpY190eXBlcyA9XG5zdHJ1Y3RcbiAgdHlwZSArJ2EgdFxuICB0eXBlIC0nYSB1XG5cbiAgbGV0IHRvX3B1YmxpY19wcm9taXNlIDogKCdhLCBfLCBfKSBwcm9taXNlIC0+ICdhIHQgPSBPYmoubWFnaWNcbiAgbGV0IHRvX3B1YmxpY19yZXNvbHZlciA6ICgnYSwgXywgXykgcHJvbWlzZSAtPiAnYSB1ID0gT2JqLm1hZ2ljXG5cbiAgdHlwZSBfIHBhY2tlZF9wcm9taXNlID1cbiAgICB8IEludGVybmFsIDogKCdhLCBfLCBfKSBwcm9taXNlIC0+ICdhIHBhY2tlZF9wcm9taXNlXG4gICAgW0BAb2NhbWwudW5ib3hlZF1cblxuICBsZXQgdG9faW50ZXJuYWxfcHJvbWlzZSAocCA6ICdhIHQpIDogJ2EgcGFja2VkX3Byb21pc2UgPVxuICAgIEludGVybmFsIChPYmoubWFnaWMgcClcbiAgbGV0IHRvX2ludGVybmFsX3Jlc29sdmVyIChyIDogJ2EgdSkgOiAnYSBwYWNrZWRfcHJvbWlzZSA9XG4gICAgSW50ZXJuYWwgKE9iai5tYWdpYyByKVxuXG4gICgqIE1vc3QgZnVuY3Rpb25zIHRoYXQgdGFrZSBhIHB1YmxpYyBwcm9taXNlIChbJ2EgdF0pIGNvbnZlcnQgaXQgdG8gYW5cbiAgICAgaW50ZXJuYWwgcHJvbWlzZSBhcyBmb2xsb3dzOlxuXG4gICAgICAgKCogcCA6ICdhIHQgKilcblxuICAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG5cbiAgICAgICAoKiBwIDogKCdhLCB1LCBjKSBwcm9taXNlLCB3aGVyZSB1IGFuZCBjIGFyZSBmcmVzaCB0eXBlcywgaS5lLiB0aGVcbiAgICAgICAgICBpbnZhcmlhbnRzIG9uIHAgYXJlIHVua25vd24uICopXG5cbiAgICAgVGhpcyBjYXN0IGlzIGEgbm8tb3AgY2FzdC4gSXQgb25seSBwcm9kdWNlcyBhIHJlZmVyZW5jZSB3aXRoIGEgZGlmZmVyZW50XG4gICAgIHR5cGUuIFRoZSBpbnRyb2R1Y3Rpb24gYW5kIGltbWVkaWF0ZSBlbGltaW5hdGlvbiBvZiBbSW50ZXJuYWwgX10gc2VlbXMgdG9cbiAgICAgYmUgb3B0aW1pemVkIGF3YXkgZXZlbiBvbiBvbGRlciB2ZXJzaW9ucyBvZiBPQ2FtbCB0aGF0IGRvbid0IGhhdmUgRmxhbWJkYVxuICAgICBhbmQgZG9uJ3Qgc3VwcG9ydCBbW0BAb2NhbWwudW5ib3hlZF1dLiAqKVxuXG4gICgqIFRoaXMgY291bGQgcHJvYmFibHkgc2F2ZSBhbiBhbGxvY2F0aW9uIGJ5IHVzaW5nIFtPYmoubWFnaWNdLiAqKVxuICBsZXQgc3RhdGVfb2ZfcmVzdWx0ID0gZnVuY3Rpb25cbiAgICB8IE9rIHggLT4gRnVsZmlsbGVkIHhcbiAgICB8IEVycm9yIGV4biAtPiBSZWplY3RlZCBleG5cbmVuZFxuaW5jbHVkZSBQdWJsaWNfdHlwZXNcblxuXG5cbm1vZHVsZSBCYXNpY19oZWxwZXJzIDpcbnNpZ1xuICB2YWwgaWRlbnRpY2FsIDogKCdhLCBfLCBfKSBwcm9taXNlIC0+ICgnYSwgXywgXykgcHJvbWlzZSAtPiBib29sXG4gIHZhbCB1bmRlcmx5aW5nIDogKCdhLCAndSwgJ2MpIHByb21pc2UgLT4gKCdhLCB1bmRlcmx5aW5nLCAnYykgcHJvbWlzZVxuXG4gIHR5cGUgKCdhLCAndSwgJ2MpIHN0YXRlX2NoYW5nZWQgPVxuICAgIHwgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBvZiAoJ2EsICd1LCAnYykgcHJvbWlzZVxuICAgIFtAQG9jYW1sLnVuYm94ZWRdXG4gIHZhbCBzZXRfcHJvbWlzZV9zdGF0ZSA6XG4gICAgKCdhLCBfLCBfKSBwcm9taXNlIC0+ICgnYSwgJ3UsICdjKSBzdGF0ZSAtPiAoJ2EsICd1LCAnYykgc3RhdGVfY2hhbmdlZFxuXG4gIHR5cGUgJ2EgbWF5X25vd19iZV9wcm94eSA9XG4gICAgfCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgOlxuICAgICAgKCdhLCBfLCBwZW5kaW5nKSBwcm9taXNlIC0+ICdhIG1heV9ub3dfYmVfcHJveHlcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuICB2YWwgbWF5X25vd19iZV9wcm94eSA6XG4gICAgKCdhLCB1bmRlcmx5aW5nLCBwZW5kaW5nKSBwcm9taXNlIC0+ICdhIG1heV9ub3dfYmVfcHJveHlcbmVuZCA9XG5zdHJ1Y3RcbiAgKCogQ2hlY2tzIHBoeXNpY2FsIGVxdWFsaXR5IChbPT1dKSBvZiB0d28gaW50ZXJuYWwgcHJvbWlzZXMuIFVubGlrZSBbPT1dLCBkb2VzXG4gICAgIG5vdCBmb3JjZSB1bmlmaWNhdGlvbiBvZiB0aGVpciBpbnZhcmlhbnRzLiAqKVxuICBsZXQgaWRlbnRpY2FsIHAxIHAyID1cbiAgICAodG9fcHVibGljX3Byb21pc2UgcDEpID09ICh0b19wdWJsaWNfcHJvbWlzZSBwMilcblxuICAoKiBbdW5kZXJseWluZyBwXSBldmFsdWF0ZXMgdG8gdGhlIHVuZGVybHlpbmcgcHJvbWlzZSBvZiBbcF0uXG5cbiAgICAgSWYgbXVsdGlwbGUgW1Byb3h5IF9dIGxpbmtzIGFyZSB0cmF2ZXJzZWQsIFt1bmRlcmx5aW5nXSB1cGRhdGVzIGFsbCB0aGVcbiAgICAgcHJveGllcyB0byBwb2ludCBpbW1lZGlhdGVseSB0byB0aGVpciBmaW5hbCB1bmRlcmx5aW5nIHByb21pc2UuICopXG4gIGxldCByZWMgdW5kZXJseWluZ1xuICAgICAgOiB0eXBlIHUgYy4gKCdhLCB1LCBjKSBwcm9taXNlIC0+ICgnYSwgdW5kZXJseWluZywgYykgcHJvbWlzZSA9XG4gICAgZnVuIHAgLT5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT4gKHAgOiAoXywgdW5kZXJseWluZywgXykgcHJvbWlzZSlcbiAgICB8IFJlamVjdGVkIF8gLT4gcFxuICAgIHwgUGVuZGluZyBfIC0+IHBcbiAgICB8IFByb3h5IHAnIC0+XG4gICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJyBpblxuICAgICAgaWYgbm90IChpZGVudGljYWwgcCcnIHAnKSB0aGVuXG4gICAgICAgIHAuc3RhdGUgPC0gUHJveHkgcCcnO1xuICAgICAgcCcnXG5cblxuXG4gIHR5cGUgKCdhLCAndSwgJ2MpIHN0YXRlX2NoYW5nZWQgPVxuICAgIHwgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBvZiAoJ2EsICd1LCAnYykgcHJvbWlzZVxuICAgIFtAQG9jYW1sLnVuYm94ZWRdXG5cbiAgbGV0IHNldF9wcm9taXNlX3N0YXRlIHAgc3RhdGUgPVxuICAgIGxldCBwIDogKF8sIF8sIF8pIHByb21pc2UgPSBPYmoubWFnaWMgcCBpblxuICAgIHAuc3RhdGUgPC0gc3RhdGU7XG4gICAgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwXG5cbiAgKCogW3NldF9wcm9taXNlX3N0YXRlIHAgc3RhdGVdIG11dGF0ZXMgdGhlIHN0YXRlIG9mIFtwXSwgYW5kIGV2YWx1YXRlcyB0byBhXG4gICAgICh3cmFwcGVkKSByZWZlcmVuY2UgdG8gW3BdIHdpdGggdGhlIHNhbWUgaW52YXJpYW50cyBhcyBvbiBbc3RhdGVdLiBUaGVcbiAgICAgb3JpZ2luYWwgcmVmZXJlbmNlIFtwXSBzaG91bGQgYmUgc2hhZG93ZWQgd2hlbiBjYWxsaW5nIHRoaXMgZnVuY3Rpb246XG5cbiAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID0gc2V0X3Byb21pc2Vfc3RhdGUgcCAoRnVsZmlsbGVkIDQyKSBpbiAuLi5cblxuICAgICBUaGlzIGlzIGEga2luZCBvZiBjaGVhcCBpbWl0YXRpb24gb2YgbGluZWFyIHR5cGluZywgd2hpY2ggaXMgZ29vZCBlbm91Z2hcbiAgICAgZm9yIHRoZSBuZWVkcyBvZiBbbHd0Lm1sXS5cblxuICAgICBJbnRlcm5hbCBmdW5jdGlvbnMgdGhhdCB0cmFuc2l0aXZlbHkgY2FsbCBbc2V0X3Byb21pc2Vfc3RhdGVdIGxpa2V3aXNlXG4gICAgIHJldHVybiB0aGUgbmV3IHJlZmVyZW5jZS4gVGhpcyBlbmRzIGF0IHNvbWUgdG9wLWxldmVsIGZ1bmN0aW9uLCB0eXBpY2FsbHlcbiAgICAgZWl0aGVyIGEgY2FsbGJhY2sgb3IgYSBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS4gVGhlcmUsIHRoZSBuZXcgcmVmZXJlbmNlXG4gICAgIGlzIHN0aWxsIGJvdW5kLCBidXQgaXMgdGhlbiBleHBsaWNpdGx5IGlnbm9yZWQuXG5cbiAgICAgVGhlIHN0YXRlIG9mIGEgcHJvbWlzZSBpcyBuZXZlciB1cGRhdGVkIGRpcmVjdGx5IG91dHNpZGUgdGhpcyBtb2R1bGVcbiAgICAgW0Jhc2ljX2hlbHBlcnNdLiBBbGwgdXBkYXRlcyBlbHNld2hlcmUgYXJlIGRvbmUgdGhyb3VnaFxuICAgICBbc2V0X3Byb21pc2Vfc3RhdGVdLlxuXG4gICAgIFRvIGF2b2lkIHByb2JsZW1zIHdpdGggdHlwZS1sZXZlbCBpbnZhcmlhbnRzIG5vdCBtYXRjaGluZyByZWFsaXR5LCBkYXRhXG4gICAgIHN0cnVjdHVyZXMgZG8gbm90IHN0b3JlIHByb21pc2VzIHdpdGggY29uY3JldGUgaW52YXJpYW50cyAtLSBleGNlcHRcbiAgICAgcmVzb2x2ZWQgcHJvbWlzZXMsIHdoaWNoIGFyZSBpbW11dGFibGUuIEluZGVlZCwgaWYgb25lIGxvb2tzIGF0XG4gICAgIGRlZmluaXRpb25zIG9mIGRhdGEgc3RydWN0dXJlcyB0aGF0IGNhbiBzdG9yZSBwZW5kaW5nIHByb21pc2VzLCBlLmcuIHRoZVxuICAgICBbaG93X3RvX2NhbmNlbF0gZ3JhcGgsIHRoZSBpbnZhcmlhbnRzIGFyZSBleGlzdGVudGlhbGx5IHF1YW50aWZpZWQuXG5cbiAgICAgTm90ZTogaXQncyBwb3NzaWJsZSB0byBzdGF0aWNhbGx5IGRpc2FsbG93IHRoZSBzZXR0aW5nIG9mIHRoZSBbc3RhdGVdIGZpZWxkXG4gICAgIGJ5IG1ha2luZyB0eXBlIFtwcm9taXNlXSBwcml2YXRlLiBIb3dldmVyLCB0aGF0IHNlZW1zIHRvIHJlcXVpcmUgd3JpdGluZyBhXG4gICAgIHNpZ25hdHVyZSB0aGF0IGlzIGEgbmVhci1kdXBsaWNhdGUgb2YgW01haW5faW50ZXJuYWxfdHlwZXNdLCBvciBzb21lIGFidXNlXG4gICAgIG9mIGZ1bmN0b3JzLiAqKVxuXG5cblxuICB0eXBlICdhIG1heV9ub3dfYmVfcHJveHkgPVxuICAgIHwgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IDpcbiAgICAgICgnYSwgXywgcGVuZGluZykgcHJvbWlzZSAtPiAnYSBtYXlfbm93X2JlX3Byb3h5XG4gICAgW0BAb2NhbWwudW5ib3hlZF1cblxuICBsZXQgbWF5X25vd19iZV9wcm94eSBwID0gU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHBcblxuICAoKiBNYW55IGZ1bmN0aW9ucywgZm9yIGV4YW1wbGUgW0x3dC5iaW5kXSBhbmQgW0x3dC5qb2luXSwgY3JlYXRlIGEgZnJlc2hcbiAgICAgcGVuZGluZyBwcm9taXNlIFtwXSBhbmQgcmV0dXJuIGl0IHRvIHRoZSB1c2VyLlxuXG4gICAgIFRoZXkgZG8gbm90IHJldHVybiBhIGNvcnJlc3BvbmRpbmcgcmVzb2x2ZXIuIFRoYXQgbWVhbnMgdGhhdCBvbmx5IHRoZVxuICAgICBmdW5jdGlvbiBpdHNlbGYgKHR5cGljYWxseSwgYSBjYWxsYmFjayByZWdpc3RlcmVkIGJ5IGl0KSBjYW4gcmVzb2x2ZSBbcF0uXG4gICAgIFRoZSBvbmx5IHRoaW5nIHRoZSB1c2VyIGNhbiBkbyBkaXJlY3RseSBpcyB0cnkgdG8gY2FuY2VsIFtwXSwgYnV0LCBzaW5jZVxuICAgICBbcF0gaXMgbm90IGFuIGluaXRpYWwgcHJvbWlzZSwgdGhlIGNhbmNlbGxhdGlvbiBhdHRlbXB0IHNpbXBseSBwcm9wYWdhdGVzXG4gICAgIHBhc3QgW3BdIHRvIFtwXSdzIHByZWRlY2Vzc29ycy4gSWYgdGhhdCBldmVudHVhbGx5IHJlc3VsdHMgaW4gY2FuY2VsaW5nXG4gICAgIFtwXSwgaXQgd2lsbCBiZSB0aHJvdWdoIHRoZSBub3JtYWwgbWVjaGFuaXNtcyBvZiB0aGUgZnVuY3Rpb24gKGUuZy5cbiAgICAgW0x3dC5iaW5kXSdzIGNhbGxiYWNrKS5cblxuICAgICBBcyBhIHJlc3VsdCwgdGhlIG9ubHkgcG9zc2libGUgc3RhdGUgY2hhbmdlLCBiZWZvcmUgdGhlIGNhbGxiYWNrLCBpcyB0aGF0XG4gICAgIFtwXSBtYXkgaGF2ZSBiZWNvbWUgYSBwcm94eS4gTm93LFxuXG4gICAgIC0gSWYgW3BdIGRvZXMgbm90IHVuZGVyZ28gdGhpcyBzdGF0ZSBjaGFuZ2UgYW5kIGJlY29tZSBhIHByb3h5LCBpdCByZW1haW5zXG4gICAgICAgYW4gdW5kZXJseWluZywgcGVuZGluZyBwcm9taXNlLlxuICAgICAtIElmIFtwXSBkb2VzIGJlY29tZSBhIHByb3h5LCBpdCB3aWxsIGJlIGEgcHJveHkgZm9yIGFub3RoZXIgcHJvbWlzZSBbcCddXG4gICAgICAgY3JlYXRlZCBmcmVzaCBieSBbTHd0LmJpbmRdLCB0byB3aGljaCB0aGlzIHNhbWUgYXJndW1lbnQgYXBwbGllcy4gU2VlXG4gICAgICAgW21ha2VfaW50b19wcm94eV0uXG5cbiAgICAgU28sIGJ5IGluZHVjdGlvbiBvbiB0aGUgbGVuZ3RoIG9mIHRoZSBwcm94eSAoW1Byb3h5IF9dKSBjaGFpbiwgYXQgdGhlIHRpbWVcbiAgICAgdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCwgW3BdIGlzIGVpdGhlciBhbiB1bmRlcmx5aW5nLCBwZW5kaW5nIHByb21pc2UsIG9yIGFcbiAgICAgcHJveHkgZm9yIGEgcGVuZGluZyBwcm9taXNlLlxuXG4gICAgIFRoZSBjYXN0XG5cbiAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAgPSBtYXlfbm93X2JlX3Byb3h5IHAgaW4gLi4uXG5cbiAgICAgZW5jb2RlcyB0aGUgcG9zc2liaWxpdHkgb2YgdGhpcyBzdGF0ZSBjaGFuZ2UuIEl0IHJlcGxhY2VzIGEgcmVmZXJlbmNlXG5cbiAgICAgICBwIDogKCdhLCB1bmRlcmx5aW5nLCBwZW5kaW5nKVxuXG4gICAgIHdpdGhcblxuICAgICAgIHAgOiAoJ2EsICRVbmtub3duLCBwZW5kaW5nKVxuXG4gICAgIGFuZCBpcyB0eXBpY2FsbHkgc2VlbiBhdCB0aGUgYmVnaW5uaW5nIG9mIGNhbGxiYWNrcyByZWdpc3RlcmVkIGJ5XG4gICAgIFtMd3QuYmluZF0gYW5kIHNpbWlsYXIgZnVuY3Rpb25zLlxuXG4gICAgIFRoZSBjYXN0IGlzIGEgbm8tb3AgY2FzdC4gVGhlIGludHJvZHVjdGlvbiBhbmQgaW1tZWRpYXRlIGVsaW1pbmF0aW9uIG9mXG4gICAgIFtTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIF9dIHNlZW1zIHRvIGJlIG9wdGltaXplZCBhd2F5IGV2ZW4gb24gb2xkIHZlcnNpb25zXG4gICAgIG9mIE9DYW1sLiAqKVxuZW5kXG5vcGVuIEJhc2ljX2hlbHBlcnNcblxuKCogU21hbGwgaGVscGVycyB0byBhdm9pZCBjYXRjaGluZyBvY2FtbC1ydW50aW1lIGV4Y2VwdGlvbnMgKilcbm1vZHVsZSBFeGNlcHRpb25fZmlsdGVyID0gc3RydWN0XG4gIHR5cGUgdCA9IGV4biAtPiBib29sXG4gIGxldCBoYW5kbGVfYWxsID0gZnVuIF8gLT4gdHJ1ZVxuICBsZXQgaGFuZGxlX2FsbF9leGNlcHRfcnVudGltZSA9IGZ1bmN0aW9uXG4gICAgfCBPdXRfb2ZfbWVtb3J5IC0+IGZhbHNlXG4gICAgfCBTdGFja19vdmVyZmxvdyAtPiBmYWxzZVxuICAgIHwgXyAtPiB0cnVlXG4gIGxldCB2ID1cbiAgICAoKiBEZWZhdWx0IHZhbHVlOiB0aGUgbGVnYWN5IGJlaGF2aW91ciB0byBhdm9pZCBicmVha2luZyBwcm9ncmFtcyAqKVxuICAgIHJlZiBoYW5kbGVfYWxsXG4gIGxldCBzZXQgZiA9IHYgOj0gZlxuICBsZXQgcnVuIGUgPSAhdiBlXG5lbmRcblxubW9kdWxlIFNlcXVlbmNlX2Fzc29jaWF0ZWRfc3RvcmFnZSA6XG5zaWdcbiAgKCogUHVibGljIGludGVyZmFjZSAqKVxuICB0eXBlICd2IGtleVxuICB2YWwgbmV3X2tleSA6IHVuaXQgLT4gXyBrZXlcbiAgdmFsIGdldCA6ICd2IGtleSAtPiAndiBvcHRpb25cbiAgdmFsIHdpdGhfdmFsdWUgOiAndiBrZXkgLT4gJ3Ygb3B0aW9uIC0+ICh1bml0IC0+ICdiKSAtPiAnYlxuXG4gICgqIEludGVybmFsIGludGVyZmFjZSAqKVxuICB2YWwgY3VycmVudF9zdG9yYWdlIDogc3RvcmFnZSByZWZcbmVuZCA9XG5zdHJ1Y3RcbiAgKCogVGhlIGlkZWEgYmVoaW5kIHNlcXVlbmNlLWFzc29jaWF0ZWQgc3RvcmFnZSBpcyB0byBwcmVzZXJ2ZSBzb21lIHZhbHVlc1xuICAgICBkdXJpbmcgYSBjYWxsIHRvIFtiaW5kXSBvciBvdGhlciBzZXF1ZW50aWFsIGNvbXBvc2l0aW9uIG9wZXJhdGlvbiwgYW5kXG4gICAgIHJlc3RvcmUgdGhvc2UgdmFsdWVzIGluIHRoZSBjYWxsYmFjayBmdW5jdGlvbjpcblxuICAgICAgIEx3dC53aXRoX3ZhbHVlIG15X2tleSAoU29tZSBcImZvb1wiKSAoZnVuICgpIC0+XG4gICAgICAgcCA+fD0gZnVuICgpIC0+XG4gICAgICAgYXNzZXJ0IChMd3QuZ2V0IG15X2tleSA9IFNvbWUgXCJmb29cIikpXG4gICAgICAgICAoKiBXaWxsIHN1Y2NlZWQgZXZlbiBpZiB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCBsYXRlci4gKilcblxuICAgICBOb3RlIHRoYXQgaXQgZG9lcyBub3QgbWF0dGVyIHRoYXQgdGhlIGNhbGxiYWNrIGlzIGRlZmluZWQgd2l0aGluIGFuXG4gICAgIGFyZ3VtZW50IG9mIFt3aXRoX3ZhbHVlXSwgaS5lLiwgdGhpcyBkb2VzIHRoZSBzYW1lOlxuXG4gICAgICAgbGV0IGYgPSBmdW4gKCkgLT4gYXNzZXJ0IChMd3QuZ2V0IG15X2tleSA9IFNvbWUgXCJmb29cIikgaW5cbiAgICAgICBMd3Qud2l0aF92YWx1ZSBteV9rZXkgKFNvbWUgXCJmb29cIikgKGZ1biAoKSAtPiBwID58PSBmKVxuXG4gICAgIEFsbCB0aGF0IG1hdHRlcnMgaXMgdGhhdCB0aGUgdG9wLW1vc3Qgc2VxdWVuY2luZyBvcGVyYXRpb24gKGluIHRoaXMgY2FzZSxcbiAgICAgbWFwKSBpcyBleGVjdXRlZCBieSB0aGF0IGFyZ3VtZW50LlxuXG4gICAgIFRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSBzaW5nbGUgZ2xvYmFsIGhldGVyb2dlbmVvdXMga2V5LXZhbHVlIG1hcC5cbiAgICAgU2VxdWVudGlhbCBjb21wb3NpdGlvbiBmdW5jdGlvbnMgc25hcHNob3QgdGhpcyBtYXAgd2hlbiB0aGV5IGFyZSBjYWxsZWQsXG4gICAgIGFuZCByZXN0b3JlIHRoZSBzbmFwc2hvdCByaWdodCBiZWZvcmUgY2FsbGluZyB0aGUgdXNlcidzIGNhbGxiYWNrLiBUaGUgc2FtZVxuICAgICBoYXBwZW5zIGZvciBjYW5jZWwgdHJpZ2dlcnMgYWRkZWQgYnkgW29uX2NhbmNlbF0uXG5cbiAgICAgTWFpbnRhaW5lcidzIG5vdGU6IEkgdGhpbmsgdXNpbmcgdGhpcyBtZWNoYW5pc20gc2hvdWxkIGJlIGRpc2NvdXJhZ2VkIGluXG4gICAgIG5ldyBjb2RlLiAqKVxuXG4gIHR5cGUgJ3Yga2V5ID0ge1xuICAgIGlkIDogaW50O1xuICAgIG11dGFibGUgdmFsdWUgOiAndiBvcHRpb247XG4gIH1cblxuICBsZXQgbmV4dF9rZXlfaWQgPSByZWYgMFxuXG4gIGxldCBuZXdfa2V5ICgpID1cbiAgICBsZXQgaWQgPSAhbmV4dF9rZXlfaWQgaW5cbiAgICBuZXh0X2tleV9pZCA6PSBpZCArIDE7XG4gICAge2lkID0gaWQ7IHZhbHVlID0gTm9uZX1cblxuICBsZXQgY3VycmVudF9zdG9yYWdlID0gcmVmIFN0b3JhZ2VfbWFwLmVtcHR5XG5cbiAgbGV0IGdldCBrZXkgPVxuICAgIGlmIFN0b3JhZ2VfbWFwLm1lbSBrZXkuaWQgIWN1cnJlbnRfc3RvcmFnZSB0aGVuIGJlZ2luXG4gICAgICBsZXQgcmVmcmVzaCA9IFN0b3JhZ2VfbWFwLmZpbmQga2V5LmlkICFjdXJyZW50X3N0b3JhZ2UgaW5cbiAgICAgIHJlZnJlc2ggKCk7XG4gICAgICBsZXQgdmFsdWUgPSBrZXkudmFsdWUgaW5cbiAgICAgIGtleS52YWx1ZSA8LSBOb25lO1xuICAgICAgdmFsdWVcbiAgICBlbmRcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbiAgbGV0IHdpdGhfdmFsdWUga2V5IHZhbHVlIGYgPVxuICAgIGxldCBuZXdfc3RvcmFnZSA9XG4gICAgICBtYXRjaCB2YWx1ZSB3aXRoXG4gICAgICB8IFNvbWUgXyAtPlxuICAgICAgICBsZXQgcmVmcmVzaCA9IGZ1biAoKSAtPiBrZXkudmFsdWUgPC0gdmFsdWUgaW5cbiAgICAgICAgU3RvcmFnZV9tYXAuYWRkIGtleS5pZCByZWZyZXNoICFjdXJyZW50X3N0b3JhZ2VcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBTdG9yYWdlX21hcC5yZW1vdmUga2V5LmlkICFjdXJyZW50X3N0b3JhZ2VcbiAgICBpblxuXG4gICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG4gICAgY3VycmVudF9zdG9yYWdlIDo9IG5ld19zdG9yYWdlO1xuICAgIHRyeVxuICAgICAgbGV0IHJlc3VsdCA9IGYgKCkgaW5cbiAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgcmVzdWx0XG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT5cbiAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgcmFpc2UgZXhuXG5lbmRcbmluY2x1ZGUgU2VxdWVuY2VfYXNzb2NpYXRlZF9zdG9yYWdlXG5cblxuXG5tb2R1bGUgUGVuZGluZ19jYWxsYmFja3MgOlxuc2lnXG4gICgqIE11dGF0aW5nIGNhbGxiYWNrIGxpc3RzIGF0dGFjaGVkIHRvIHBlbmRpbmcgcHJvbWlzZXMgKilcbiAgdmFsIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgOlxuICAgICdhIGNhbGxiYWNrcyAtPiAnYSByZWd1bGFyX2NhbGxiYWNrIC0+IHVuaXRcbiAgdmFsIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja190b19lYWNoX29mIDpcbiAgICAnYSB0IGxpc3QgLT4gJ2EgcmVndWxhcl9jYWxsYmFjayAtPiB1bml0XG4gIHZhbCBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfYW5kX2dpdmVfcmVtb3ZlX2Z1bmN0aW9uIDpcbiAgICAnYSB0IGxpc3QgLT4gJ2EgcmVndWxhcl9jYWxsYmFjayAtPiBjYW5jZWxfY2FsbGJhY2tcbiAgdmFsIGFkZF9jYW5jZWxfY2FsbGJhY2sgOiAnYSBjYWxsYmFja3MgLT4gY2FuY2VsX2NhbGxiYWNrIC0+IHVuaXRcbiAgdmFsIG1lcmdlX2NhbGxiYWNrcyA6IGZyb206J2EgY2FsbGJhY2tzIC0+IGludG86J2EgY2FsbGJhY2tzIC0+IHVuaXRcbmVuZCA9XG5zdHJ1Y3RcbiAgbGV0IGNvbmNhdF9yZWd1bGFyX2NhbGxiYWNrcyBsMSBsMiA9XG4gICAgYmVnaW4gbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eSwgXyAtPiBsMlxuICAgIHwgXywgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5IC0+IGwxXG4gICAgfCBfLCBfIC0+IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9jb25jYXQgKGwxLCBsMilcbiAgICBlbmQgW0BvY2FtbC53YXJuaW5nIFwiLTRcIl1cblxuICBsZXQgY29uY2F0X2NhbmNlbF9jYWxsYmFja3MgbDEgbDIgPVxuICAgIGJlZ2luIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eSwgXyAtPiBsMlxuICAgIHwgXywgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfZW1wdHkgLT4gbDFcbiAgICB8IF8sIF8gLT4gQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY29uY2F0IChsMSwgbDIpXG4gICAgZW5kIFtAb2NhbWwud2FybmluZyBcIi00XCJdXG5cbiAgKCogSW4gYSBjYWxsYmFjayBsaXN0LCBmaWx0ZXJzIG91dCBjZWxscyBvZiBleHBsaWNpdGx5IHJlbW92YWJsZSBjYWxsYmFja3NcbiAgICAgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gKilcbiAgbGV0IHJlYyBjbGVhbl91cF9jYWxsYmFja19jZWxscyA9IGZ1bmN0aW9uXG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2sge2NvbnRlbnRzID0gTm9uZX0gLT5cbiAgICAgIFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eVxuXG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2sge2NvbnRlbnRzID0gU29tZSBffVxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBfXG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHkgYXMgY2FsbGJhY2tzIC0+XG4gICAgICBjYWxsYmFja3NcblxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCAobDEsIGwyKSAtPlxuICAgICAgbGV0IGwxID0gY2xlYW5fdXBfY2FsbGJhY2tfY2VsbHMgbDEgaW5cbiAgICAgIGxldCBsMiA9IGNsZWFuX3VwX2NhbGxiYWNrX2NlbGxzIGwyIGluXG4gICAgICBjb25jYXRfcmVndWxhcl9jYWxsYmFja3MgbDEgbDJcblxuICAoKiBTZWUgW2NsZWFyX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2NlbGxdIGFuZCBbbWVyZ2VfY2FsbGJhY2tzXS4gKilcbiAgbGV0IGNsZWFudXBfdGhyb3R0bGUgPSA0MlxuXG4gICgqIEV4cGxpY2l0bHkgcmVtb3ZhYmxlIGNhbGxiYWNrcyBhcmUgYWRkZWQgKG1haW5seSkgYnkgW0x3dC5jaG9vc2VdIGFuZCBpdHNcbiAgICAgc2ltaWxhciBmdW5jdGlvbnMuIEluIFtMd3QuY2hvb3NlIFtwOyBwJ11dLCBpZiBbcCddIHJlc29sdmVzIGZpcnN0LCB0aGVcbiAgICAgY2FsbGJhY2sgYWRkZWQgYnkgW0x3dC5jaG9vc2VdIHRvIFtwXSBpcyByZW1vdmVkLlxuXG4gICAgIFRoZSByZW1vdmFsIGl0c2VsZiBpcyBhY2NvbXBsaXNoZWQgd2hlbiB0aGlzIGZ1bmN0aW9uIGNsZWFycyB0aGUgcmVmZXJlbmNlXG4gICAgIGNlbGwgW2NlbGxdLCB3aGljaCBjb250YWlucyB0aGUgcmVmZXJlbmNlIHRvIHRoYXQgY2FsbGJhY2suXG5cbiAgICAgSWYgW3BdIGlzIGEgbG9uZy1wZW5kaW5nIHByb21pc2UgdGhhdCByZXBlYXRlZGx5IHBhcnRpY2lwYXRlcyBpblxuICAgICBbTHd0LmNob29zZV0sIHBlcmhhcHMgaW4gYSBsb29wLCBpdCB3aWxsIGFjY3VtdWxhdGUgYSBsYXJnZSBudW1iZXIgb2ZcbiAgICAgY2xlYXJlZCByZWZlcmVuY2UgY2VsbHMgaW4gdGhpcyBmYXNoaW9uLiBUbyBhdm9pZCBhIG1lbW9yeSBsZWFrLCB0aGV5IG11c3RcbiAgICAgYmUgY2xlYW5lZCB1cC4gSG93ZXZlciwgdGhlIGNlbGxzIGFyZSBub3QgY2xlYW5lZCB1cCBvbiAqZXZlcnkqIHJlbW92YWwsXG4gICAgIHByZXN1bWFibHkgYmVjYXVzZSBzY2FubmluZyB0aGUgY2FsbGJhY2sgbGlzdCB0aGF0IG9mdGVuLCBhbmQgcmVidWlsZGluZ1xuICAgICBpdCwgY2FuIGdldCBleHBlbnNpdmUuXG5cbiAgICAgQ2xlYW51cCBpcyB0aHJvdHRsZWQgYnkgbWFpbnRhaW5pbmcgYSBjb3VudGVyLCBbY2xlYW51cHNfZGVmZXJyZWRdLCBvbiBlYWNoXG4gICAgIHBlbmRpbmcgcHJvbWlzZS4gVGhlIGNvdW50ZXIgaXMgaW5jcmVtZW50ZWQgZWFjaCB0aW1lIHRoaXMgZnVuY3Rpb24gd2FudHNcbiAgICAgdG8gY2xlYW4gdGhlIGNhbGxiYWNrIGxpc3QgKHJpZ2h0IGFmdGVyIGNsZWFyaW5nIGEgY2VsbCkuIFdoZW4gdGhlIGNvdW50ZXJcbiAgICAgcmVhY2hlcyBbY2xlYW51cF90aHJvdHRsZV0sIHRoZSBjYWxsYmFjayBsaXN0IGlzIGFjdHVhbGx5IHNjYW5uZWQgYW5kXG4gICAgIGNsZWFyZWQgY2FsbGJhY2sgY2VsbHMgYXJlIHJlbW92ZWQuICopXG4gIGxldCBjbGVhcl9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19jZWxsIGNlbGwgfm9yaWdpbmFsbHlfYWRkZWRfdG86cHMgPVxuICAgIGNlbGwgOj0gTm9uZTtcblxuICAgICgqIEdvIHRocm91Z2ggdGhlIHByb21pc2VzIHRoZSBjZWxsIGhhZCBvcmlnaW5hbGx5IGJlZW4gYWRkZWQgdG8sIGFuZCBlaXRoZXJcbiAgICAgICBkZWZlciBhIGNsZWFudXAsIG9yIGFjdHVhbGx5IGNsZWFuIHVwIHRoZWlyIGNhbGxiYWNrIGxpc3RzLiAqKVxuICAgIHBzIHw+IExpc3QuaXRlciAoZnVuIHAgLT5cbiAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgICAoKiBTb21lIG9mIHRoZSBwcm9taXNlcyBtYXkgYWxyZWFkeSBoYXZlIGJlZW4gcmVzb2x2ZWQgYXQgdGhlIHRpbWUgdGhpc1xuICAgICAgICAgZnVuY3Rpb24gaXMgY2FsbGVkLiAqKVxuICAgICAgfCBGdWxmaWxsZWQgXyAtPiAoKVxuICAgICAgfCBSZWplY3RlZCBfIC0+ICgpXG5cbiAgICAgIHwgUGVuZGluZyBjYWxsYmFja3MgLT5cbiAgICAgICAgbWF0Y2ggY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzIHdpdGhcbiAgICAgICAgKCogSWYgdGhlIHByb21pc2UgaGFzIG9ubHkgb25lIHJlZ3VsYXIgY2FsbGJhY2ssIGFuZCBpdCBpcyByZW1vdmFibGUsIGl0XG4gICAgICAgICAgIG11c3QgaGF2ZSBiZWVuIHRoZSBjZWxsIGNsZWFyZWQgaW4gdGhpcyBmdW5jdGlvbiwgYWJvdmUuIEluIHRoYXRcbiAgICAgICAgICAgY2FzZSwganVzdCBzZXQgaXRzIGNhbGxiYWNrIGxpc3QgdG8gZW1wdHkuICopXG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrIF8gLT5cbiAgICAgICAgICBjYWxsYmFja3MucmVndWxhcl9jYWxsYmFja3MgPC0gUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5XG5cbiAgICAgICAgKCogTWFpbnRhaW5lcidzIG5vdGU6IEkgdGhpbmsgdGhpcyBmdW5jdGlvbiBzaG91bGRuJ3QgdHJ5IHRvIHRyaWdnZXIgYVxuICAgICAgICAgICBjbGVhbnVwIGluIHRoZSBmaXJzdCB0d28gY2FzZXMsIGJ1dCBJIGFtIHByZXNlcnZpbmcgdGhlbSBmb3Igbm93LCBhc1xuICAgICAgICAgICB0aGlzIGlzIGhvdyB0aGUgY29kZSB3YXMgd3JpdHRlbiBpbiB0aGUgcGFzdC4gKilcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHlcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIF9cbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfY29uY2F0IF8gLT5cbiAgICAgICAgICBsZXQgY2xlYW51cHNfZGVmZXJyZWQgPSBjYWxsYmFja3MuY2xlYW51cHNfZGVmZXJyZWQgKyAxIGluXG4gICAgICAgICAgaWYgY2xlYW51cHNfZGVmZXJyZWQgPiBjbGVhbnVwX3Rocm90dGxlIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGNhbGxiYWNrcy5jbGVhbnVwc19kZWZlcnJlZCA8LSAwO1xuICAgICAgICAgICAgY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzIDwtXG4gICAgICAgICAgICAgIGNsZWFuX3VwX2NhbGxiYWNrX2NlbGxzIGNhbGxiYWNrcy5yZWd1bGFyX2NhbGxiYWNrc1xuICAgICAgICAgIGVuZCBlbHNlXG4gICAgICAgICAgICBjYWxsYmFja3MuY2xlYW51cHNfZGVmZXJyZWQgPC0gY2xlYW51cHNfZGVmZXJyZWQpXG5cbiAgKCogQ29uY2F0ZW5hdGVzIGJvdGgga2luZHMgb2YgY2FsbGJhY2tzIG9uIFt+ZnJvbV0gdG8gdGhlIGNvcnJlc3BvbmRpbmcgbGlzdHNcbiAgICAgb2YgW35pbnRvXS4gVGhlIGNhbGxiYWNrIGxpc3RzIG9uIFt+ZnJvbV0gYXJlICpub3QqIHRoZW4gY2xlYXJlZCwgYmVjYXVzZVxuICAgICB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IGJ5IFtTZXF1ZW50aWFsX2NvbXBvc2l0aW9uLm1ha2VfaW50b19wcm94eV0sXG4gICAgIHdoaWNoIGltbWVkaWF0ZWx5IGNoYW5nZXMgdGhlIHN0YXRlIG9mIFt+ZnJvbV0gYW5kIGxvc2VzIHJlZmVyZW5jZXMgdG8gdGhlXG4gICAgIG9yaWdpbmFsIGNhbGxiYWNrIGxpc3RzLlxuXG4gICAgIFRoZSBbY2xlYW51cHNfZGVmZXJyZWRdIGZpZWxkcyBvZiBib3RoIHByb21pc2VzIGFyZSBzdW1tZWQsIGFuZCBpZiB0aGUgc3VtXG4gICAgIGV4Y2VlZHMgW2NsZWFudXBfdGhyb3R0bGVdLCBhIGNsZWFudXAgb2YgcmVndWxhciBjYWxsYmFja3MgaXMgdHJpZ2dlcmVkLlxuICAgICBUaGlzIGlzIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzOyBzZWVcbiAgICAgW2NsZWFyX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2NlbGxdLiAqKVxuICBsZXQgbWVyZ2VfY2FsbGJhY2tzIH5mcm9tIH5pbnRvID1cbiAgICBsZXQgcmVndWxhcl9jYWxsYmFja3MgPVxuICAgICAgY29uY2F0X3JlZ3VsYXJfY2FsbGJhY2tzIGludG8ucmVndWxhcl9jYWxsYmFja3MgZnJvbS5yZWd1bGFyX2NhbGxiYWNrcyBpblxuICAgIGxldCBjbGVhbnVwc19kZWZlcnJlZCA9IGludG8uY2xlYW51cHNfZGVmZXJyZWQgKyBmcm9tLmNsZWFudXBzX2RlZmVycmVkIGluXG5cbiAgICBsZXQgcmVndWxhcl9jYWxsYmFja3MsIGNsZWFudXBzX2RlZmVycmVkID1cbiAgICAgIGlmIGNsZWFudXBzX2RlZmVycmVkID4gY2xlYW51cF90aHJvdHRsZSB0aGVuXG4gICAgICAgIGNsZWFuX3VwX2NhbGxiYWNrX2NlbGxzIHJlZ3VsYXJfY2FsbGJhY2tzLCAwXG4gICAgICBlbHNlXG4gICAgICAgIHJlZ3VsYXJfY2FsbGJhY2tzLCBjbGVhbnVwc19kZWZlcnJlZFxuICAgIGluXG5cbiAgICBsZXQgY2FuY2VsX2NhbGxiYWNrcyA9XG4gICAgICBjb25jYXRfY2FuY2VsX2NhbGxiYWNrcyBpbnRvLmNhbmNlbF9jYWxsYmFja3MgZnJvbS5jYW5jZWxfY2FsbGJhY2tzIGluXG5cbiAgICBpbnRvLnJlZ3VsYXJfY2FsbGJhY2tzIDwtIHJlZ3VsYXJfY2FsbGJhY2tzO1xuICAgIGludG8uY2FuY2VsX2NhbGxiYWNrcyA8LSBjYW5jZWxfY2FsbGJhY2tzO1xuICAgIGludG8uY2xlYW51cHNfZGVmZXJyZWQgPC0gY2xlYW51cHNfZGVmZXJyZWRcblxuXG5cbiAgKCogR2VuZXJhbCwgaW50ZXJuYWwsIGZ1bmN0aW9uIGZvciBhZGRpbmcgYSByZWd1bGFyIGNhbGxiYWNrLiAqKVxuICBsZXQgYWRkX3JlZ3VsYXJfY2FsbGJhY2tfbGlzdF9ub2RlIGNhbGxiYWNrcyBub2RlID1cbiAgICBjYWxsYmFja3MucmVndWxhcl9jYWxsYmFja3MgPC1cbiAgICAgIG1hdGNoIGNhbGxiYWNrcy5yZWd1bGFyX2NhbGxiYWNrcyB3aXRoXG4gICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eSAtPlxuICAgICAgICBub2RlXG4gICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgX1xuICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2sgX1xuICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfY29uY2F0IF8gYXMgZXhpc3RpbmcgLT5cbiAgICAgICAgUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCAobm9kZSwgZXhpc3RpbmcpXG5cbiAgbGV0IGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgY2FsbGJhY2tzIGYgPVxuICAgIGFkZF9yZWd1bGFyX2NhbGxiYWNrX2xpc3Rfbm9kZVxuICAgICAgY2FsbGJhY2tzIChSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIGYpXG5cbiAgKCogQWRkcyBbY2FsbGJhY2tdIGFzIHJlbW92YWJsZSB0byBlYWNoIHByb21pc2UgaW4gW3BzXS4gVGhlIGZpcnN0IHByb21pc2UgaW5cbiAgICAgW3BzXSB0byB0cmlnZ2VyIFtjYWxsYmFja10gcmVtb3ZlcyBbY2FsbGJhY2tdIGZyb20gdGhlIG90aGVyIHByb21pc2VzOyB0aGlzXG4gICAgIGd1YXJhbnRlZXMgdGhhdCBbY2FsbGJhY2tdIGlzIGNhbGxlZCBhdCBtb3N0IG9uY2UuIEFsbCB0aGUgcHJvbWlzZXMgaW4gW3BzXVxuICAgICBtdXN0IGJlIHBlbmRpbmcuXG5cbiAgICAgVGhpcyBpcyBhbiBpbnRlcm5hbCBmdW5jdGlvbiwgaW5kaXJlY3RseSB1c2VkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbnMgb2ZcbiAgICAgW0x3dC5jaG9vc2VdIGFuZCByZWxhdGVkIGZ1bmN0aW9ucy4gKilcbiAgbGV0IGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19hbmRfZ2l2ZV9jZWxsIHBzIGYgPVxuICAgIGxldCByZWMgY2VsbCA9IHJlZiAoU29tZSBzZWxmX3JlbW92aW5nX2NhbGxiYWNrX3dyYXBwZXIpXG4gICAgYW5kIHNlbGZfcmVtb3ZpbmdfY2FsbGJhY2tfd3JhcHBlciByZXN1bHQgPVxuICAgICAgY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfY2VsbCBjZWxsIH5vcmlnaW5hbGx5X2FkZGVkX3RvOnBzO1xuICAgICAgZiByZXN1bHRcbiAgICBpblxuXG4gICAgbGV0IG5vZGUgPSBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2sgY2VsbCBpblxuICAgIHBzIHw+IExpc3QuaXRlciAoZnVuIHAgLT5cbiAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgICB8IFBlbmRpbmcgY2FsbGJhY2tzIC0+IGFkZF9yZWd1bGFyX2NhbGxiYWNrX2xpc3Rfbm9kZSBjYWxsYmFja3Mgbm9kZVxuICAgICAgfCBGdWxmaWxsZWQgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPiBhc3NlcnQgZmFsc2UpO1xuXG4gICAgY2VsbFxuXG4gIGxldCBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiBwcyBmID1cbiAgICBpZ25vcmUgKGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19hbmRfZ2l2ZV9jZWxsIHBzIGYpXG5cbiAgKCogVGhpcyBpcyBiYXNpY2FsbHkganVzdCB0byBzdXBwb3J0IFtMd3QucHJvdGVjdGVkXSwgd2hpY2ggbmVlZHMgdG8gcmVtb3ZlXG4gICAgIHRoZSBjYWxsYmFjayBpbiBjaXJjdW1zdGFuY2VzIG90aGVyIHRoYW4gdGhlIGNhbGxiYWNrIGJlaW5nIGNhbGxlZC4gKilcbiAgbGV0IGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19hbmRfZ2l2ZV9yZW1vdmVfZnVuY3Rpb24gcHMgZiA9XG4gICAgbGV0IGNlbGwgPSBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfYW5kX2dpdmVfY2VsbCBwcyBmIGluXG4gICAgZnVuICgpIC0+XG4gICAgICBjbGVhcl9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19jZWxsIGNlbGwgfm9yaWdpbmFsbHlfYWRkZWRfdG86cHNcblxuICBsZXQgYWRkX2NhbmNlbF9jYWxsYmFjayBjYWxsYmFja3MgZiA9XG4gICAgbGV0IG5vZGUgPSBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jYWxsYmFjayAoIWN1cnJlbnRfc3RvcmFnZSwgZikgaW5cblxuICAgIGNhbGxiYWNrcy5jYW5jZWxfY2FsbGJhY2tzIDwtXG4gICAgICBtYXRjaCBjYWxsYmFja3MuY2FuY2VsX2NhbGxiYWNrcyB3aXRoXG4gICAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2VtcHR5IC0+XG4gICAgICAgIG5vZGVcblxuICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jYWxsYmFjayBfXG4gICAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIF9cbiAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY29uY2F0IF8gLT5cbiAgICAgICAgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY29uY2F0IChub2RlLCBjYWxsYmFja3MuY2FuY2VsX2NhbGxiYWNrcylcbmVuZFxub3BlbiBQZW5kaW5nX2NhbGxiYWNrc1xuXG5cblxubW9kdWxlIFJlc29sdXRpb25fbG9vcCA6XG5zaWdcbiAgKCogQWxsIHVzZXItcHJvdmlkZWQgY2FsbGJhY2tzIGFyZSBjYWxsZWQgYnkgTHd0IG9ubHkgdGhyb3VnaCB0aGlzIG1vZHVsZS4gSXRcbiAgICAgdHJhY2tzIHRoZSBjdXJyZW50IGNhbGxiYWNrIHN0YWNrIGRlcHRoLCBhbmQgZGVjaWRlcyB3aGV0aGVyIGVhY2ggY2FsbGJhY2tcbiAgICAgY2FsbCBzaG91bGQgYmUgZGVmZXJyZWQgb3Igbm90LiAqKVxuXG4gICgqIEludGVybmFsIGludGVyZmFjZSB1c2VkIG9ubHkgaW4gdGhpcyBtb2R1bGUgTHd0ICopXG4gIHZhbCByZXNvbHZlIDpcbiAgICA/YWxsb3dfZGVmZXJyaW5nOmJvb2wgLT5cbiAgICA/bWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoOmludCAtPlxuICAgICgnYSwgdW5kZXJseWluZywgcGVuZGluZykgcHJvbWlzZSAtPlxuICAgICdhIHJlc29sdmVkX3N0YXRlIC0+XG4gICAgICAoJ2EsIHVuZGVybHlpbmcsIHJlc29sdmVkKSBzdGF0ZV9jaGFuZ2VkXG5cbiAgdmFsIHJ1bl9jYWxsYmFja3Nfb3JfZGVmZXJfdGhlbSA6XG4gICAgP2FsbG93X2RlZmVycmluZzpib29sIC0+XG4gICAgP21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aDppbnQgLT5cbiAgICAoJ2EgY2FsbGJhY2tzKSAtPlxuICAgICdhIHJlc29sdmVkX3N0YXRlIC0+XG4gICAgICB1bml0XG5cbiAgdmFsIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdCA6XG4gICAgP3J1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDpib29sIC0+XG4gICAgY2FsbGJhY2s6KHVuaXQgLT4gJ2EpIC0+XG4gICAgaWZfZGVmZXJyZWQ6KHVuaXQgLT4gJ2EgKiAnYiByZWd1bGFyX2NhbGxiYWNrICogJ2IgcmVzb2x2ZWRfc3RhdGUpIC0+XG4gICAgICAnYVxuXG4gIHZhbCBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayA6ICgnYSAtPiB1bml0KSAtPiAnYSAtPiB1bml0XG5cbiAgKCogSW50ZXJuYWwgaW50ZXJmYWNlIGV4cG9zZWQgdG8gb3RoZXIgbW9kdWxlcyBpbiBMd3QgKilcbiAgdmFsIGFiYW5kb25fd2FrZXVwcyA6IHVuaXQgLT4gdW5pdFxuXG4gICgqIFB1YmxpYyBpbnRlcmZhY2UgKilcbiAgZXhjZXB0aW9uIENhbmNlbGVkXG5cbiAgdmFsIGFzeW5jX2V4Y2VwdGlvbl9ob29rIDogKGV4biAtPiB1bml0KSByZWZcbmVuZCA9XG5zdHJ1Y3RcbiAgKCogV2hlbiBMd3QgbmVlZHMgdG8gY2FsbCBhIGNhbGxiYWNrLCBpdCBlbnRlcnMgdGhlIHJlc29sdXRpb24gbG9vcC4gVGhpc1xuICAgICB0eXBpY2FsbHkgaGFwcGVucyB3aGVuIEx3dCBzZXRzIHRoZSBzdGF0ZSBvZiBvbmUgcHJvbWlzZSB0byBbRnVsZmlsbGVkIF9dXG4gICAgIG9yIFtSZWplY3RlZCBfXS4gVGhlIGNhbGxiYWNrcyB0aGF0IHdlcmUgYXR0YWNoZWQgdG8gdGhlIHByb21pc2Ugd2hlbiBpdFxuICAgICB3YXMgcGVuZGluZyBtdXN0IHRoZW4gYmUgY2FsbGVkLlxuXG4gICAgIFRoaXMgYWxzbyBoYXBwZW5zIGluIGEgZmV3IG90aGVyIHNpdHVhdGlvbnMuIEZvciBleGFtcGxlLCB3aGVuIFtMd3QuYmluZF1cbiAgICAgaXMgY2FsbGVkIG9uIGEgcHJvbWlzZSwgYnV0IHRoYXQgcHJvbWlzZSBpcyBhbHJlYWR5IHJlc29sdmVkLCB0aGUgY2FsbGJhY2tcbiAgICAgcGFzc2VkIHRvIFtiaW5kXSBtdXN0IGJlIGNhbGxlZC5cblxuICAgICBUaGUgY2FsbGJhY2tzIHRyaWdnZXJlZCBkdXJpbmcgdGhlIHJlc29sdXRpb24gbG9vcCBtaWdodCByZXNvbHZlIG1vcmVcbiAgICAgcHJvbWlzZXMsIHRyaWdnZXJpbmcgbW9yZSBjYWxsYmFja3MsIGFuZCBzbyBvbi4gVGhpcyBpcyB3aGF0IG1ha2VzIHRoZVxuICAgICByZXNvbHV0aW9uIGxvb3AgYSB7ZSBsb29wfS5cblxuICAgICBMd3QgZ2VuZXJhbGx5IHRyaWVzIHRvIGNhbGwgZWFjaCBjYWxsYmFjayBpbW1lZGlhdGVseS4gSG93ZXZlciwgdGhpcyBjYW5cbiAgICAgbGVhZCB0byBhIHByb2dyZXNzaXZlIGRlZXBlbmluZyBvZiB0aGUgY2FsbCBzdGFjaywgdW50aWwgdGhlcmUgaXMgYSBzdGFja1xuICAgICBvdmVyZmxvdy4gVGhpcyBjYW4ndCBiZSBhdm9pZGVkIGJ5IGRvaW5nIHRhaWwgY2FsbHMsIGJlY2F1c2UgTHd0IGFsd2F5c1xuICAgICBuZWVkcyB0byBkbyBleGNlcHRpb24gaGFuZGxpbmcgYXJvdW5kIGNhbGxiYWNrcyBjYWxsczogZWFjaCBjYWxsYmFjayBjYWxsXG4gICAgIGlzIGZvbGxvd2VkIGJ5IGFuIGV4Y2VwdGlvbiBoYW5kbGVyLiBJbnN0ZWFkLCB3aGF0IEx3dCBkb2VzIGlzIHRyYWNrIHRoZVxuICAgICBjdXJyZW50IGNhbGxiYWNrIGNhbGwgZGVwdGguIE9uY2UgdGhhdCBkZXB0aCByZWFjaGVzIGEgY2VydGFpbiBudW1iZXIsXG4gICAgIFtkZWZhdWx0X21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aF0sIGRlZmluZWQgYmVsb3csIGZ1cnRoZXIgY2FsbGJhY2tzXG4gICAgIGFyZSBkZWZlcnJlZCBpbnRvIGEgcXVldWUgaW5zdGVhZC4gVGhhdCBxdWV1ZSBpcyBkcmFpbmVkIHdoZW4gTHd0IGV4aXRzXG4gICAgIGZyb20gdGhlIHRvcC1tb3N0IGNhbGxiYWNrIGNhbGwgdGhhdCB0cmlnZ2VyZWQgdGhlIHJlc29sdXRpb24gbG9vcCBpbiB0aGVcbiAgICAgZmlyc3QgcGxhY2UuXG5cbiAgICAgVG8gZW5zdXJlIHRoYXQgdGhpcyBkZWZlcnJhbCBtZWNoYW5pc20gaXMgYWx3YXlzIHByb3Blcmx5IGludm9rZWQsIGFsbFxuICAgICBjYWxsYmFja3MgY2FsbGVkIGJ5IEx3dCBhcmUgY2FsbGVkIHRocm91Z2ggb25lIG9mIHRocmVlIGZ1bmN0aW9ucyBwcm92aWRlZFxuICAgICBieSB0aGlzIG1vZHVsZTpcblxuICAgICAtIFtyZXNvbHZlXSwgd2hpY2ggY2FsbHMgYWxsIHRoZSBjYWxsYmFja3MgYXNzb2NpYXRlZCB0byBhIHBlbmRpbmcgcHJvbWlzZVxuICAgICAgIChhbmQgcmVzb2x2ZXMgaXQsIGNoYW5naW5nIGl0cyBzdGF0ZSkuXG4gICAgIC0gW3J1bl9jYWxsYmFja3Nfb3JfZGVmZXJfdGhlbV0sIHdoaWNoIGlzIGludGVybmFsbHkgdXNlZCBieSBbcmVzb2x2ZV0gdG9cbiAgICAgICBjYWxsIGNhbGxiYWNrcyB0aGF0IGFyZSBpbiBhIHJlY29yZCBvZiB0eXBlIFsnYSBjYWxsYmFja3NdLCB3aGljaCByZWNvcmRzXG4gICAgICAgYXJlIGFzc29jaWF0ZWQgd2l0aCBwZW5kaW5nIHByb21pc2VzLiBUaGlzIGZ1bmN0aW9uIGlzIGV4cG9zZWQgYmVjYXVzZVxuICAgICAgIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIFtMd3QuY2FuY2VsXSBuZWVkcyB0byBjYWxsIGl0IGRpcmVjdGx5LlxuICAgICAgIFByb21pc2UgcmVzb2x1dGlvbiBhbmQgY2FsbGJhY2sgY2FsbGluZyBhcmUgc2VwYXJhdGVkIGluIGEgdW5pcXVlIHdheSBpblxuICAgICAgIFtjYW5jZWxdLlxuICAgICAtIFtydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRdLCB3aGljaCBpcyB1c2VkIGJ5IFtMd3QuYmluZF0gYW5kIHNpbWlsYXJcbiAgICAgICBmdW5jdGlvbnMgdG8gY2FsbCBzaW5nbGUgY2FsbGJhY2tzIHdoZW4gdGhlIHByb21pc2VzIHBhc3NlZCB0b1xuICAgICAgIFtMd3QuYmluZF0sIGV0Yy4sIGFyZSBhbHJlYWR5IHJlc29sdmVkLlxuXG4gICAgIEN1cnJlbnQgTHd0IGFjdHVhbGx5IGhhcyBhIG1lc3N5IG1peCBvZiBjYWxsYmFjay1jYWxsaW5nIGJlaGF2aW9ycy4gRm9yXG4gICAgIGV4YW1wbGUsIFtMd3QuYmluZF0gaXMgZXhwZWN0ZWQgdG8gYWx3YXlzIGNhbGwgaXRzIGNhbGxiYWNrIGltbWVkaWF0ZWx5LFxuICAgICB3aGlsZSBbTHd0Lndha2V1cF9sYXRlcl0gaXMgZXhwZWN0ZWQgdG8gZGVmZXIgYWxsIGNhbGxiYWNrcyBvZiB0aGUgcHJvbWlzZVxuICAgICByZXNvbHZlZCwge2UgdW5sZXNzfSBMd3QgaXMgbm90IGFscmVhZHkgaW5zaWRlIHRoZSByZXNvbHV0aW9uIGxvb3AuXG5cbiAgICAgV2UgcGxhbm5lZCB0byBtYWtlIHRoZXNlIGJlaGF2aW9ycyB1bmlmb3JtIGluIEx3dCA0LjAuMCwgYnV0IGRlY2lkZWRcbiAgICAgYWdhaW5zdCBpdCBkdWUgdG8gdGhlIHJpc2sgb2YgYnJlYWtpbmcgdXNlcnMuIFNlZVxuXG4gICAgIC0gaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L3B1bGwvNTAwXG4gICAgIC0gaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L3B1bGwvNTE5XG5cbiAgICAgQXMgcGFydCBvZiB0aGUgcHJlcGFyYXRpb24gZm9yIHRoZSBjaGFuZ2UsIHRoZSBhYm92ZSBjYWxsYmFjay1pbnZva2luZ1xuICAgICBmdW5jdGlvbnMgc3VwcG9ydCBzZXZlcmFsIG9wdGlvbmFsIGFyZ3VtZW50cyB0byBlbXVsYXRlIHRoZSB2YXJpb3VzXG4gICAgIGJlaGF2aW9ycy4gV2UgZGVjaWRlZCBub3QgdG8gcmVtb3ZlIHRoaXMgbWFjaGluZXJ5LCBiZWNhdXNlIHdlIG1pZ2h0IHdhbnRcbiAgICAgdG8gZXhwb3NlIGRpZmZlcmVudCBBUElzIHRvIEx3dCBpbiB0aGUgZnV0dXJlLlxuXG4gICAgIC0gW35hbGxvd19kZWZlcnJpbmc6ZmFsc2VdIGFsbG93cyBpZ25vcmluZyB0aGUgY2FsbGJhY2sgc3RhY2sgZGVwdGgsIGFuZFxuICAgICAgIGNhbGxpbmcgdGhlIGNhbGxiYWNrcyBpbW1lZGlhdGVseS4gVGhpcyBlbXVsYXRlcyB0aGUgb2xkIHJlc29sdXRpb25cbiAgICAgICBiZWhhdmlvci5cbiAgICAgLSBbfm1heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aDoxXSBhbGxvd3MgbGltaXRpbmcgdGhlIGRlcHRoIHdoaWNoXG4gICAgICAgdHJpZ2dlcnMgZGVmZXJyYWwgb24gYSBwZXItY2FsbC1zaXRlIGJhc2lzLiBUaGlzIGlzIHVzZWQgYnlcbiAgICAgICBbTHd0Lndha2V1cF9sYXRlcl0uXG4gICAgIC0gW35ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZV0gaXMgbGlrZVxuICAgICAgIFt+YWxsb3dfZGVmZXJyaW5nOmZhbHNlXSwgd2hpY2ggaWdub3JlcyB0aGUgY2FsbGJhY2sgc3RhY2sgZGVwdGguXG4gICAgICAgSG93ZXZlciwgdG8gZW5zdXJlIHRoYXQgdGhlIGNhbGxiYWNrIGlzIHRhaWwtY2FsbGVkLCBMd3QgZG9lc24ndCBldmVuXG4gICAgICAgdXBkYXRlIHRoZSBjYWxsYmFjayBzdGFjayBkZXB0aCBmb3IgdGhlIGJlbmVmaXQgb2YgKm90aGVyKiBjYWxsYmFja1xuICAgICAgIGNhbGxzLiBJdCBqdXN0IGJsaW5kbHkgY2FsbHMgdGhlIGNhbGxiYWNrLlxuXG4gICAgIFNlZSBkaXNjdXNzaW9uIG9mIGNhbGxiYWNrLWNhbGxpbmcgc2VtYW50aWNzIGluOlxuXG4gICAgICAgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2lzc3Vlcy8zMjlcblxuICAgICAqIENvbnRleHRcblxuICAgICBUaGUgcmVzb2x1dGlvbiBsb29wIGVmZmVjdGl2ZWx5IGhhbmRsZXMgYWxsIHByb21pc2VzIHRoYXQgY2FuIGJlIHJlc29sdmVkXG4gICAgIGltbWVkaWF0ZWx5LCB3aXRob3V0IGJsb2NraW5nIG9uIEkvTy4gQSBjb21wbGV0ZSBwcm9ncmFtIHRoYXQgZG9lcyBJL09cbiAgICAgY2FsbHMgW0x3dF9tYWluLnJ1bl0uIFNlZSBcIk5vIEkvT1wiIGluIHRoZSBPdmVydmlldy4gKilcblxuXG5cbiAgbGV0IGFzeW5jX2V4Y2VwdGlvbl9ob29rID1cbiAgICByZWYgKGZ1biBleG4gLT5cbiAgICAgIHByZXJyX3N0cmluZyBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gXCI7XG4gICAgICBwcmVycl9zdHJpbmcgKFByaW50ZXhjLnRvX3N0cmluZyBleG4pO1xuICAgICAgcHJlcnJfY2hhciAnXFxuJztcbiAgICAgIFByaW50ZXhjLnByaW50X2JhY2t0cmFjZSBzdGRlcnI7XG4gICAgICBmbHVzaCBzdGRlcnI7XG4gICAgICBleGl0IDIpXG5cbiAgbGV0IGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgdiA9XG4gICAgKCogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY2FyZSBpZiBbZl0gZXZhbHVhdGVzIHRvIGEgcHJvbWlzZS4gSW5cbiAgICAgICBwYXJ0aWN1bGFyLCBpZiBbZiB2XSBldmFsdWF0ZXMgdG8gW3BdIGFuZCBbcF0gaXMgYWxyZWFkeSByZWplY3RlZCBvciB3aWxsXG4gICAgICAgYmUgcmVqZWN0IGxhdGVyLCBpdCBpcyBub3QgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoaXMgZnVuY3Rpb24gdG8gcGFzc1xuICAgICAgIHRoZSBleGNlcHRpb24gdG8gWyFhc3luY19leGNlcHRpb25faG9va10uICopXG4gICAgdHJ5IGYgdlxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+XG4gICAgICAhYXN5bmNfZXhjZXB0aW9uX2hvb2sgZXhuXG5cblxuXG4gIGV4Y2VwdGlvbiBDYW5jZWxlZFxuXG5cblxuICAoKiBSdW5zIHRoZSBjYWxsYmFja3MgKGZvcm1lcmx5KSBhc3NvY2lhdGVkIHRvIGEgcHJvbWlzZS4gQ2FuY2VsIGNhbGxiYWNrcyBhcmVcbiAgICAgcnVuIGZpcnN0LCBpZiB0aGUgcHJvbWlzZSB3YXMgY2FuY2VsZWQuIFRoZXNlIGFyZSBmb2xsb3dlZCBieSByZWd1bGFyXG4gICAgIGNhbGxiYWNrcy5cblxuICAgICBUaGUgcmVhc29uIGZvciB0aGUgXCJmb3JtZXJseVwiIGlzIHRoYXQgdGhlIHByb21pc2UncyBzdGF0ZSBoYXMgYWxyZWFkeSBiZWVuXG4gICAgIHNldCB0byBbRnVsZmlsbGVkIF9dIG9yIFtSZWplY3RlZCBfXSwgc28gdGhlIGNhbGxiYWNrcyBhcmUgbm8gbG9uZ2VyXG4gICAgIHJlYWNoYWJsZSB0aHJvdWdoIHRoZSBwcm9taXNlIHJlZmVyZW5jZS4gVGhpcyBpcyB3aHkgdGhlIGRpcmVjdCBbY2FsbGJhY2tzXVxuICAgICByZWNvcmQgbXVzdCBiZSBnaXZlbiB0byB0aGlzIGZ1bmN0aW9uLiAqKVxuICBsZXQgcnVuX2NhbGxiYWNrc1xuICAgICAgKGNhbGxiYWNrcyA6ICdhIGNhbGxiYWNrcylcbiAgICAgIChyZXN1bHQgOiAnYSByZXNvbHZlZF9zdGF0ZSkgOiB1bml0ID1cblxuICAgIGxldCBydW5fY2FuY2VsX2NhbGxiYWNrcyBmcyA9XG4gICAgICBsZXQgcmVjIGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyByZXN0ID1cbiAgICAgICAgbWF0Y2ggZnMgd2l0aFxuICAgICAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2VtcHR5IC0+XG4gICAgICAgICAgaXRlcl9saXN0IHJlc3RcbiAgICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jYWxsYmFjayAoc3RvcmFnZSwgZikgLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc3RvcmFnZTtcbiAgICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpO1xuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfcmVtb3ZlX3NlcXVlbmNlX25vZGUgbm9kZSAtPlxuICAgICAgICAgIEx3dF9zZXF1ZW5jZS5yZW1vdmUgbm9kZTtcbiAgICAgICAgICBpdGVyX2xpc3QgcmVzdFxuICAgICAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2NvbmNhdCAoZnMsIGZzJykgLT5cbiAgICAgICAgICBpdGVyX2NhbGxiYWNrX2xpc3QgZnMgKGZzJzo6cmVzdClcblxuICAgICAgYW5kIGl0ZXJfbGlzdCByZXN0ID1cbiAgICAgICAgbWF0Y2ggcmVzdCB3aXRoXG4gICAgICAgIHwgW10gLT4gKClcbiAgICAgICAgfCBmczo6cmVzdCAtPiBpdGVyX2NhbGxiYWNrX2xpc3QgZnMgcmVzdFxuXG4gICAgICBpblxuXG4gICAgICBpdGVyX2NhbGxiYWNrX2xpc3QgZnMgW11cbiAgICBpblxuXG4gICAgbGV0IHJ1bl9yZWd1bGFyX2NhbGxiYWNrcyBmcyA9XG4gICAgICBsZXQgcmVjIGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyByZXN0ID1cbiAgICAgICAgbWF0Y2ggZnMgd2l0aFxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eSAtPlxuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBmIC0+XG4gICAgICAgICAgZiByZXN1bHQ7XG4gICAgICAgICAgaXRlcl9saXN0IHJlc3RcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tcbiAgICAgICAgICAgIHtjb250ZW50cyA9IE5vbmV9IC0+XG4gICAgICAgICAgaXRlcl9saXN0IHJlc3RcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tcbiAgICAgICAgICAgIHtjb250ZW50cyA9IFNvbWUgZn0gLT5cbiAgICAgICAgICBmIHJlc3VsdDtcbiAgICAgICAgICBpdGVyX2xpc3QgcmVzdFxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9jb25jYXQgKGZzLCBmcycpIC0+XG4gICAgICAgICAgaXRlcl9jYWxsYmFja19saXN0IGZzIChmcyc6OnJlc3QpXG5cbiAgICAgIGFuZCBpdGVyX2xpc3QgcmVzdCA9XG4gICAgICAgIG1hdGNoIHJlc3Qgd2l0aFxuICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgIHwgZnM6OnJlc3QgLT4gaXRlcl9jYWxsYmFja19saXN0IGZzIHJlc3RcblxuICAgICAgaW5cblxuICAgICAgaXRlcl9jYWxsYmFja19saXN0IGZzIFtdXG4gICAgaW5cblxuICAgICgqIFBhdHRlcm4gbWF0Y2hpbmcgaXMgbXVjaCBmYXN0ZXIgdGhhbiBwb2x5bW9ycGhpYyBjb21wYXJpc29uLiAqKVxuICAgIGxldCBpc19jYW5jZWxlZCA9XG4gICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgfCBSZWplY3RlZCBDYW5jZWxlZCAtPiB0cnVlXG4gICAgICB8IFJlamVjdGVkIF8gLT4gZmFsc2VcbiAgICAgIHwgRnVsZmlsbGVkIF8gLT4gZmFsc2VcbiAgICBpblxuICAgIGlmIGlzX2NhbmNlbGVkIHRoZW5cbiAgICAgIHJ1bl9jYW5jZWxfY2FsbGJhY2tzIGNhbGxiYWNrcy5jYW5jZWxfY2FsbGJhY2tzO1xuICAgIHJ1bl9yZWd1bGFyX2NhbGxiYWNrcyBjYWxsYmFja3MucmVndWxhcl9jYWxsYmFja3NcblxuXG5cbiAgbGV0IGRlZmF1bHRfbWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoID0gNDJcblxuICBsZXQgY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoID0gcmVmIDBcblxuICB0eXBlIGRlZmVycmVkX2NhbGxiYWNrcyA9XG4gICAgRGVmZXJyZWQgOiAoJ2EgY2FsbGJhY2tzICogJ2EgcmVzb2x2ZWRfc3RhdGUpIC0+IGRlZmVycmVkX2NhbGxiYWNrc1xuICAgIFtAQG9jYW1sLnVuYm94ZWRdXG5cbiAgbGV0IGRlZmVycmVkX2NhbGxiYWNrcyA6IGRlZmVycmVkX2NhbGxiYWNrcyBRdWV1ZS50ID0gUXVldWUuY3JlYXRlICgpXG5cbiAgKCogQmVmb3JlIGVudGVyaW5nIGEgcmVzb2x1dGlvbiBsb29wLCBpdCBpcyBuZWNlc3NhcnkgdG8gdGFrZSBhIHNuYXBzaG90IG9mXG4gICAgIHRoZSBjdXJyZW50IHN0YXRlIG9mIHNlcXVlbmNlLWFzc29jaWF0ZWQgc3RvcmFnZS4gVGhpcyBpcyBiZWNhdXNlIG1hbnkgb2ZcbiAgICAgdGhlIGNhbGxiYWNrcyB0aGF0IHdpbGwgYmUgcnVuIHdpbGwgbW9kaWZ5IHRoZSBzdG9yYWdlLiBUaGUgc3RvcmFnZSBpc1xuICAgICByZXN0b3JlZCB0byB0aGUgc25hcHNob3Qgd2hlbiB0aGUgcmVzb2x1dGlvbiBsb29wIGlzIGV4aXRlZC4gKilcbiAgbGV0IGVudGVyX3Jlc29sdXRpb25fbG9vcCAoKSA9XG4gICAgY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoIDo9ICFjdXJyZW50X2NhbGxiYWNrX25lc3RpbmdfZGVwdGggKyAxO1xuICAgIGxldCBzdG9yYWdlX3NuYXBzaG90ID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuICAgIHN0b3JhZ2Vfc25hcHNob3RcblxuICBsZXQgbGVhdmVfcmVzb2x1dGlvbl9sb29wIChzdG9yYWdlX3NuYXBzaG90IDogc3RvcmFnZSkgOiB1bml0ID1cbiAgICBpZiAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoID0gMSB0aGVuIGJlZ2luXG4gICAgICB3aGlsZSBub3QgKFF1ZXVlLmlzX2VtcHR5IGRlZmVycmVkX2NhbGxiYWNrcykgZG9cbiAgICAgICAgbGV0IERlZmVycmVkIChjYWxsYmFja3MsIHJlc3VsdCkgPSBRdWV1ZS5wb3AgZGVmZXJyZWRfY2FsbGJhY2tzIGluXG4gICAgICAgIHJ1bl9jYWxsYmFja3MgY2FsbGJhY2tzIHJlc3VsdFxuICAgICAgZG9uZVxuICAgIGVuZDtcbiAgICBjdXJyZW50X2NhbGxiYWNrX25lc3RpbmdfZGVwdGggOj0gIWN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCAtIDE7XG4gICAgY3VycmVudF9zdG9yYWdlIDo9IHN0b3JhZ2Vfc25hcHNob3RcblxuICBsZXQgcnVuX2luX3Jlc29sdXRpb25fbG9vcCBmID1cbiAgICBsZXQgc3RvcmFnZV9zbmFwc2hvdCA9IGVudGVyX3Jlc29sdXRpb25fbG9vcCAoKSBpblxuICAgIGxldCByZXN1bHQgPSBmICgpIGluXG4gICAgbGVhdmVfcmVzb2x1dGlvbl9sb29wIHN0b3JhZ2Vfc25hcHNob3Q7XG4gICAgcmVzdWx0XG5cbiAgKCogVGhpcyBpcyBiYXNpY2FsbHkgYSBoYWNrIHRvIGZpeCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvaXNzdWVzLzQ4LlxuICAgICBJZiBjdXJyZW50bHkgcmVzb2x2aW5nIHByb21pc2VzLCBpdCBpbW1lZGlhdGVseSBleGl0cyBhbGwgcmVjdXJzaXZlXG4gICAgIGVudHJpZXMgb2YgdGhlIHJlc29sdXRpb24gbG9vcCwgZ29lcyB0byB0aGUgdG9wIGxldmVsLCBydW5zIGFueSBkZWZlcnJlZFxuICAgICBjYWxsYmFja3MsIGFuZCBleGl0cyB0aGUgdG9wLWxldmVsIHJlc29sdXRpb24gbG9vcC5cblxuICAgICBUaGUgbmFtZSBzaG91bGQgcHJvYmFibHkgYmUgW2FiYW9uZG9uX3Jlc29sdXRpb25fbG9vcF0uICopXG4gIGxldCBhYmFuZG9uX3dha2V1cHMgKCkgPVxuICAgIGlmICFjdXJyZW50X2NhbGxiYWNrX25lc3RpbmdfZGVwdGggPD4gMCB0aGVuXG4gICAgICBsZWF2ZV9yZXNvbHV0aW9uX2xvb3AgU3RvcmFnZV9tYXAuZW1wdHlcblxuXG5cbiAgbGV0IHJ1bl9jYWxsYmFja3Nfb3JfZGVmZXJfdGhlbVxuICAgICAgPyhhbGxvd19kZWZlcnJpbmcgPSB0cnVlKVxuICAgICAgPyhtYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGggPSBkZWZhdWx0X21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aClcbiAgICAgIGNhbGxiYWNrcyByZXN1bHQgPVxuXG4gICAgbGV0IHNob3VsZF9kZWZlciA9XG4gICAgICBhbGxvd19kZWZlcnJpbmdcbiAgICAgICYmICFjdXJyZW50X2NhbGxiYWNrX25lc3RpbmdfZGVwdGggPj0gbWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoXG4gICAgaW5cblxuICAgIGlmIHNob3VsZF9kZWZlciB0aGVuXG4gICAgICBRdWV1ZS5wdXNoIChEZWZlcnJlZCAoY2FsbGJhY2tzLCByZXN1bHQpKSBkZWZlcnJlZF9jYWxsYmFja3NcbiAgICBlbHNlXG4gICAgICBydW5faW5fcmVzb2x1dGlvbl9sb29wIChmdW4gKCkgLT5cbiAgICAgICAgcnVuX2NhbGxiYWNrcyBjYWxsYmFja3MgcmVzdWx0KVxuXG4gIGxldCByZXNvbHZlID9hbGxvd19kZWZlcnJpbmcgP21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aCBwIHJlc3VsdCA9XG4gICAgbGV0IFBlbmRpbmcgY2FsbGJhY2tzID0gcC5zdGF0ZSBpblxuICAgIGxldCBwID0gc2V0X3Byb21pc2Vfc3RhdGUgcCByZXN1bHQgaW5cblxuICAgIHJ1bl9jYWxsYmFja3Nfb3JfZGVmZXJfdGhlbVxuICAgICAgP2FsbG93X2RlZmVycmluZyA/bWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoIGNhbGxiYWNrcyByZXN1bHQ7XG5cbiAgICBwXG5cbiAgbGV0IHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgPyhydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGwgPSBmYWxzZSlcbiAgICAgIH5jYWxsYmFjazpmXG4gICAgICB+aWZfZGVmZXJyZWQgPVxuXG4gICAgaWYgcnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsIHRoZW5cbiAgICAgIGYgKClcblxuICAgIGVsc2VcbiAgICAgIGxldCBzaG91bGRfZGVmZXIgPVxuICAgICAgICAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoXG4gICAgICAgICAgPj0gZGVmYXVsdF9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGhcbiAgICAgIGluXG5cbiAgICAgIGlmIHNob3VsZF9kZWZlciB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBpbW1lZGlhdGVfcmVzdWx0LCBkZWZlcnJlZF9jYWxsYmFjaywgZGVmZXJyZWRfcmVzdWx0ID1cbiAgICAgICAgICBpZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICBsZXQgZGVmZXJyZWRfcmVjb3JkID1cbiAgICAgICAgICB7XG4gICAgICAgICAgICByZWd1bGFyX2NhbGxiYWNrcyA9XG4gICAgICAgICAgICAgIFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBkZWZlcnJlZF9jYWxsYmFjaztcbiAgICAgICAgICAgIGNhbmNlbF9jYWxsYmFja3MgPSBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eTtcbiAgICAgICAgICAgIGhvd190b19jYW5jZWwgPSBOb3RfY2FuY2VsYWJsZTtcbiAgICAgICAgICAgIGNsZWFudXBzX2RlZmVycmVkID0gMFxuICAgICAgICAgIH1cbiAgICAgICAgaW5cbiAgICAgICAgUXVldWUucHVzaFxuICAgICAgICAgIChEZWZlcnJlZCAoZGVmZXJyZWRfcmVjb3JkLCBkZWZlcnJlZF9yZXN1bHQpKSBkZWZlcnJlZF9jYWxsYmFja3M7XG4gICAgICAgIGltbWVkaWF0ZV9yZXN1bHRcbiAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBydW5faW5fcmVzb2x1dGlvbl9sb29wIChmdW4gKCkgLT5cbiAgICAgICAgICBmICgpKVxuZW5kXG5pbmNsdWRlIFJlc29sdXRpb25fbG9vcFxuXG5cblxubW9kdWxlIFJlc29sdmluZyA6XG5zaWdcbiAgdmFsIHdha2V1cF9sYXRlcl9yZXN1bHQgOiAnYSB1IC0+ICgnYSwgZXhuKSByZXN1bHQgLT4gdW5pdFxuICB2YWwgd2FrZXVwX2xhdGVyIDogJ2EgdSAtPiAnYSAtPiB1bml0XG4gIHZhbCB3YWtldXBfbGF0ZXJfZXhuIDogXyB1IC0+IGV4biAtPiB1bml0XG5cbiAgdmFsIHdha2V1cF9yZXN1bHQgOiAnYSB1IC0+ICgnYSwgZXhuKSByZXN1bHQgLT4gdW5pdFxuICB2YWwgd2FrZXVwIDogJ2EgdSAtPiAnYSAtPiB1bml0XG4gIHZhbCB3YWtldXBfZXhuIDogXyB1IC0+IGV4biAtPiB1bml0XG5cbiAgdmFsIGNhbmNlbCA6ICdhIHQgLT4gdW5pdFxuZW5kID1cbnN0cnVjdFxuICAoKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBkZXZpYXRlcyBmcm9tIHRoZSBcImlkZWFsXCIgY2FsbGJhY2sgZGVmZXJyYWxcbiAgICAgYmVoYXZpb3I6IGl0IHJ1bnMgY2FsbGJhY2tzIGRpcmVjdGx5IG9uIHRoZSBjdXJyZW50IHN0YWNrLiBJdCBzaG91bGRcbiAgICAgdGhlcmVmb3JlIGJlIHBvc3NpYmxlIHRvIGNhdXNlIGEgc3RhY2sgb3ZlcmZsb3cgdXNpbmcgdGhpcyBmdW5jdGlvbi4gKilcbiAgbGV0IHdha2V1cF9nZW5lcmFsIGFwaV9mdW5jdGlvbl9uYW1lIHIgcmVzdWx0ID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Jlc29sdmVyIHIgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBSZWplY3RlZCBDYW5jZWxlZCAtPlxuICAgICAgKClcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICBQcmludGYua3NwcmludGYgaW52YWxpZF9hcmcgXCJMd3QuJXNcIiBhcGlfZnVuY3Rpb25fbmFtZVxuICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgUHJpbnRmLmtzcHJpbnRmIGludmFsaWRfYXJnIFwiTHd0LiVzXCIgYXBpX2Z1bmN0aW9uX25hbWVcblxuICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICBsZXQgcmVzdWx0ID0gc3RhdGVfb2ZfcmVzdWx0IHJlc3VsdCBpblxuICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9IHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwIHJlc3VsdCBpblxuICAgICAgaWdub3JlIHBcblxuICBsZXQgd2FrZXVwX3Jlc3VsdCByIHJlc3VsdCA9IHdha2V1cF9nZW5lcmFsIFwid2FrZXVwX3Jlc3VsdFwiIHIgcmVzdWx0XG4gIGxldCB3YWtldXAgciB2ID0gd2FrZXVwX2dlbmVyYWwgXCJ3YWtldXBcIiByIChPayB2KVxuICBsZXQgd2FrZXVwX2V4biByIGV4biA9IHdha2V1cF9nZW5lcmFsIFwid2FrZXVwX2V4blwiIHIgKEVycm9yIGV4bilcblxuICBsZXQgd2FrZXVwX2xhdGVyX2dlbmVyYWwgYXBpX2Z1bmN0aW9uX25hbWUgciByZXN1bHQgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcmVzb2x2ZXIgciBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IFJlamVjdGVkIENhbmNlbGVkIC0+XG4gICAgICAoKVxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgIFByaW50Zi5rc3ByaW50ZiBpbnZhbGlkX2FyZyBcIkx3dC4lc1wiIGFwaV9mdW5jdGlvbl9uYW1lXG4gICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICBQcmludGYua3NwcmludGYgaW52YWxpZF9hcmcgXCJMd3QuJXNcIiBhcGlfZnVuY3Rpb25fbmFtZVxuXG4gICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgIGxldCByZXN1bHQgPSBzdGF0ZV9vZl9yZXN1bHQgcmVzdWx0IGluXG4gICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID1cbiAgICAgICAgcmVzb2x2ZSB+bWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoOjEgcCByZXN1bHQgaW5cbiAgICAgIGlnbm9yZSBwXG5cbiAgbGV0IHdha2V1cF9sYXRlcl9yZXN1bHQgciByZXN1bHQgPVxuICAgIHdha2V1cF9sYXRlcl9nZW5lcmFsIFwid2FrZXVwX2xhdGVyX3Jlc3VsdFwiIHIgcmVzdWx0XG4gIGxldCB3YWtldXBfbGF0ZXIgciB2ID1cbiAgICB3YWtldXBfbGF0ZXJfZ2VuZXJhbCBcIndha2V1cF9sYXRlclwiIHIgKE9rIHYpXG4gIGxldCB3YWtldXBfbGF0ZXJfZXhuIHIgZXhuID1cbiAgICB3YWtldXBfbGF0ZXJfZ2VuZXJhbCBcIndha2V1cF9sYXRlcl9leG5cIiByIChFcnJvciBleG4pXG5cblxuXG4gIHR5cGUgcGFja2VkX2NhbGxiYWNrcyA9XG4gICAgfCBQYWNrZWQgOiBfIGNhbGxiYWNrcyAtPiBwYWNrZWRfY2FsbGJhY2tzXG4gICAgW0BAb2NhbWwudW5ib3hlZF1cblxuICAoKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBkZXZpYXRlcyBmcm9tIHRoZSBcImlkZWFsXCIgY2FsbGJhY2sgZGVmZXJyYWxcbiAgICAgYmVoYXZpb3I6IGl0IHJ1bnMgY2FsbGJhY2tzIGRpcmVjdGx5IG9uIHRoZSBjdXJyZW50IHN0YWNrLiBJdCBzaG91bGRcbiAgICAgdGhlcmVmb3JlIGJlIHBvc3NpYmxlIHRvIGNhdXNlIGEgc3RhY2sgb3ZlcmZsb3cgdXNpbmcgdGhpcyBmdW5jdGlvbi4gKilcbiAgbGV0IGNhbmNlbCBwID1cbiAgICBsZXQgY2FuY2VsZWRfcmVzdWx0ID0gUmVqZWN0ZWQgQ2FuY2VsZWQgaW5cblxuICAgICgqIFdhbGtzIHRoZSBwcm9taXNlIGRlcGVuZGVuY3kgZ3JhcGggYmFja3dhcmRzLCBsb29raW5nIGZvciBjYW5jZWxhYmxlXG4gICAgICAgaW5pdGlhbCBwcm9taXNlcywgYW5kIGNhbmNlbHMgKG9ubHkpIHRoZW0uXG5cbiAgICAgICBGb3VuZCBpbml0aWFsIHByb21pc2VzIGFyZSBjYW5jZWxlZCBpbW1lZGlhdGVseSwgYXMgdGhleSBhcmUgZm91bmQsIGJ5XG4gICAgICAgc2V0dGluZyB0aGVpciBzdGF0ZSB0byBbUmVqZWN0ZWQgQ2FuY2VsZWRdLiBUaGlzIGlzIHRvIHByZXZlbnQgdGhlbSBmcm9tXG4gICAgICAgYmVpbmcgXCJmb3VuZCB0d2ljZVwiIGlmIHRoZXkgYXJlIHJlYWNoYWJsZSBieSB0d28gb3IgbW9yZSBkaXN0aW5jdCBwYXRoc1xuICAgICAgIHRocm91Z2ggdGhlIHByb21pc2UgZGVwZW5kZW5jeSBncmFwaC5cblxuICAgICAgIFRoZSBjYWxsYmFja3Mgb2YgdGhlc2UgaW5pdGlhbCBwcm9taXNlcyBhcmUgdGhlbiBydW4sIGluIGEgc2VwYXJhdGVcbiAgICAgICBwaGFzZS4gVGhlc2UgY2FsbGJhY2tzIHByb3BhZ2F0ZSBjYW5jZWxsYXRpb24gZm9yd2FyZHMgdG8gYW55IGRlcGVuZGVudFxuICAgICAgIHByb21pc2VzLiBTZWUgXCJDYW5jZWxsYXRpb25cIiBpbiB0aGUgT3ZlcnZpZXcuICopXG4gICAgbGV0IHByb3BhZ2F0ZV9jYW5jZWwgOiAoXywgXywgXykgcHJvbWlzZSAtPiBwYWNrZWRfY2FsbGJhY2tzIGxpc3QgPVxuICAgICAgICBmdW4gcCAtPlxuICAgICAgbGV0IHJlYyBjYW5jZWxfYW5kX2NvbGxlY3RfY2FsbGJhY2tzIDpcbiAgICAgICAgICAnYSAndSAnYy4gcGFja2VkX2NhbGxiYWNrcyBsaXN0IC0+ICgnYSwgJ3UsICdjKSBwcm9taXNlIC0+XG4gICAgICAgICAgICBwYWNrZWRfY2FsbGJhY2tzIGxpc3QgPVxuICAgICAgICAgIGZ1biAodHlwZSBjKSBjYWxsYmFja3NfYWNjdW11bGF0b3IgKHAgOiAoXywgXywgYykgcHJvbWlzZSkgLT5cblxuICAgICAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuICAgICAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICAgICAgKCogSWYgdGhlIHByb21pc2UgaXMgbm90IHN0aWxsIHBlbmRpbmcsIGl0IGNhbid0IGJlIGNhbmNlbGVkLiAqKVxuICAgICAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAgICAgY2FsbGJhY2tzX2FjY3VtdWxhdG9yXG4gICAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICAgIGNhbGxiYWNrc19hY2N1bXVsYXRvclxuXG4gICAgICAgIHwgUGVuZGluZyBjYWxsYmFja3MgLT5cbiAgICAgICAgICBtYXRjaCBjYWxsYmFja3MuaG93X3RvX2NhbmNlbCB3aXRoXG4gICAgICAgICAgfCBOb3RfY2FuY2VsYWJsZSAtPlxuICAgICAgICAgICAgY2FsbGJhY2tzX2FjY3VtdWxhdG9yXG4gICAgICAgICAgfCBDYW5jZWxfdGhpc19wcm9taXNlIC0+XG4gICAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID1cbiAgICAgICAgICAgICAgc2V0X3Byb21pc2Vfc3RhdGUgcCBjYW5jZWxlZF9yZXN1bHQgaW5cbiAgICAgICAgICAgIGlnbm9yZSBwO1xuICAgICAgICAgICAgKFBhY2tlZCBjYWxsYmFja3MpOjpjYWxsYmFja3NfYWNjdW11bGF0b3JcbiAgICAgICAgICB8IFByb3BhZ2F0ZV9jYW5jZWxfdG9fb25lIHAnIC0+XG4gICAgICAgICAgICBjYW5jZWxfYW5kX2NvbGxlY3RfY2FsbGJhY2tzIGNhbGxiYWNrc19hY2N1bXVsYXRvciBwJ1xuICAgICAgICAgIHwgUHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIHBzIC0+XG4gICAgICAgICAgICBMaXN0LmZvbGRfbGVmdCBjYW5jZWxfYW5kX2NvbGxlY3RfY2FsbGJhY2tzIGNhbGxiYWNrc19hY2N1bXVsYXRvciBwc1xuICAgICAgaW5cbiAgICAgIGNhbmNlbF9hbmRfY29sbGVjdF9jYWxsYmFja3MgW10gcFxuICAgIGluXG5cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBjYWxsYmFja3MgPSBwcm9wYWdhdGVfY2FuY2VsIHAgaW5cblxuICAgIGNhbGxiYWNrcyB8PiBMaXN0Lml0ZXIgKGZ1biAoUGFja2VkIGNhbGxiYWNrcykgLT5cbiAgICAgIHJ1bl9jYWxsYmFja3Nfb3JfZGVmZXJfdGhlbVxuICAgICAgICB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIGNhbGxiYWNrcyBjYW5jZWxlZF9yZXN1bHQpXG5lbmRcbmluY2x1ZGUgUmVzb2x2aW5nXG5cblxuXG5tb2R1bGUgVHJpdmlhbF9wcm9taXNlcyA6XG5zaWdcbiAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcbiAgdmFsIGZhaWwgOiBleG4gLT4gXyB0XG4gIHZhbCBvZl9yZXN1bHQgOiAoJ2EsIGV4bikgcmVzdWx0IC0+ICdhIHRcblxuICB2YWwgcmV0dXJuX3VuaXQgOiB1bml0IHRcbiAgdmFsIHJldHVybl90cnVlIDogYm9vbCB0XG4gIHZhbCByZXR1cm5fZmFsc2UgOiBib29sIHRcbiAgdmFsIHJldHVybl9ub25lIDogXyBvcHRpb24gdFxuICB2YWwgcmV0dXJuX3NvbWUgOiAnYSAtPiAnYSBvcHRpb24gdFxuICB2YWwgcmV0dXJuX29rIDogJ2EgLT4gKCdhLCBfKSByZXN1bHQgdFxuICB2YWwgcmV0dXJuX2Vycm9yIDogJ2UgLT4gKF8sICdlKSByZXN1bHQgdFxuICB2YWwgcmV0dXJuX25pbCA6IF8gbGlzdCB0XG5cbiAgdmFsIGZhaWxfd2l0aCA6IHN0cmluZyAtPiBfIHRcbiAgdmFsIGZhaWxfaW52YWxpZF9hcmcgOiBzdHJpbmcgLT4gXyB0XG5lbmQgPVxuc3RydWN0XG4gIGxldCByZXR1cm4gdiA9XG4gICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gRnVsZmlsbGVkIHZ9XG5cbiAgbGV0IG9mX3Jlc3VsdCByZXN1bHQgPVxuICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHN0YXRlX29mX3Jlc3VsdCByZXN1bHR9XG5cbiAgbGV0IGZhaWwgZXhuID1cbiAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSBSZWplY3RlZCBleG59XG5cbiAgbGV0IHJldHVybl91bml0ID0gcmV0dXJuICgpXG4gIGxldCByZXR1cm5fbm9uZSA9IHJldHVybiBOb25lXG4gIGxldCByZXR1cm5fc29tZSB4ID0gcmV0dXJuIChTb21lIHgpXG4gIGxldCByZXR1cm5fbmlsID0gcmV0dXJuIFtdXG4gIGxldCByZXR1cm5fdHJ1ZSA9IHJldHVybiB0cnVlXG4gIGxldCByZXR1cm5fZmFsc2UgPSByZXR1cm4gZmFsc2VcbiAgbGV0IHJldHVybl9vayB4ID0gcmV0dXJuIChPayB4KVxuICBsZXQgcmV0dXJuX2Vycm9yIHggPSByZXR1cm4gKEVycm9yIHgpXG5cbiAgbGV0IGZhaWxfd2l0aCBtc2cgPVxuICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IFJlamVjdGVkIChGYWlsdXJlIG1zZyl9XG5cbiAgbGV0IGZhaWxfaW52YWxpZF9hcmcgbXNnID1cbiAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSBSZWplY3RlZCAoSW52YWxpZF9hcmd1bWVudCBtc2cpfVxuZW5kXG5pbmNsdWRlIFRyaXZpYWxfcHJvbWlzZXNcblxuXG5cbm1vZHVsZSBQZW5kaW5nX3Byb21pc2VzIDpcbnNpZ1xuICAoKiBJbnRlcm5hbCAqKVxuICB2YWwgbmV3X3BlbmRpbmcgOlxuICAgIGhvd190b19jYW5jZWw6aG93X3RvX2NhbmNlbCAtPiAoJ2EsIHVuZGVybHlpbmcsIHBlbmRpbmcpIHByb21pc2VcbiAgdmFsIHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCA6IF8gdCBsaXN0IC0+IGhvd190b19jYW5jZWxcblxuICAoKiBJbml0aWFsIHBlbmRpbmcgcHJvbWlzZXMgKHB1YmxpYykgKilcbiAgdmFsIHdhaXQgOiB1bml0IC0+ICdhIHQgKiAnYSB1XG4gIHZhbCB0YXNrIDogdW5pdCAtPiAnYSB0ICogJ2EgdVxuXG4gIHZhbCBhZGRfdGFza19yIDogJ2EgdSBMd3Rfc2VxdWVuY2UudCAtPiAnYSB0XG4gIHZhbCBhZGRfdGFza19sIDogJ2EgdSBMd3Rfc2VxdWVuY2UudCAtPiAnYSB0XG5cbiAgdmFsIHByb3RlY3RlZCA6ICdhIHQgLT4gJ2EgdFxuICB2YWwgbm9fY2FuY2VsIDogJ2EgdCAtPiAnYSB0XG5lbmQgPVxuc3RydWN0XG4gIGxldCBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbCA9XG4gICAgbGV0IHN0YXRlID1cbiAgICAgIFBlbmRpbmcge1xuICAgICAgICByZWd1bGFyX2NhbGxiYWNrcyA9IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eTtcbiAgICAgICAgY2FuY2VsX2NhbGxiYWNrcyA9IENhbmNlbF9jYWxsYmFja19saXN0X2VtcHR5O1xuICAgICAgICBob3dfdG9fY2FuY2VsO1xuICAgICAgICBjbGVhbnVwc19kZWZlcnJlZCA9IDA7XG4gICAgICB9XG4gICAgaW5cbiAgICB7c3RhdGV9XG5cbiAgbGV0IHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcyA9XG4gICAgKCogVXNpbmcgYSBkaXJ0eSBjYXN0IGhlcmUgdG8gYXZvaWQgcmVidWlsZGluZyB0aGUgbGlzdCA6KCBOb3QgYm90aGVyaW5nXG4gICAgICAgd2l0aCB0aGUgaW52YXJpYW50cywgYmVjYXVzZSBbUHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsXSBwYWNrcyB0aGVtLFxuICAgICAgIGFuZCBjb2RlIHRoYXQgbWF0Y2hlcyBvbiBbUHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsXSBkb2Vzbid0IGNhcmUgYWJvdXRcbiAgICAgICB0aGVtIGFueXdheS4gKilcbiAgICBsZXQgY2FzdF9wcm9taXNlX2xpc3QgOiAnYSB0IGxpc3QgLT4gKCdhLCBfLCBfKSBwcm9taXNlIGxpc3QgPSBPYmoubWFnaWMgaW5cbiAgICBQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgKGNhc3RfcHJvbWlzZV9saXN0IHBzKVxuXG5cblxuICBsZXQgd2FpdCAoKSA9XG4gICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDpOb3RfY2FuY2VsYWJsZSBpblxuICAgIHRvX3B1YmxpY19wcm9taXNlIHAsIHRvX3B1YmxpY19yZXNvbHZlciBwXG5cbiAgbGV0IHRhc2sgKCkgPVxuICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6Q2FuY2VsX3RoaXNfcHJvbWlzZSBpblxuICAgIHRvX3B1YmxpY19wcm9taXNlIHAsIHRvX3B1YmxpY19yZXNvbHZlciBwXG5cblxuXG5cbiAgbGV0IGNhc3Rfc2VxdWVuY2Vfbm9kZVxuICAgICAgKG5vZGUgOiAnYSB1IEx3dF9zZXF1ZW5jZS5ub2RlKVxuICAgICAgKF9hY3R1YWxfY29udGVudDooJ2EsICd1LCAnYykgcHJvbWlzZSlcbiAgICAgICAgOiAoJ2EsICd1LCAnYykgcHJvbWlzZSBMd3Rfc2VxdWVuY2Uubm9kZSA9XG4gICAgT2JqLm1hZ2ljIG5vZGVcblxuICBsZXQgYWRkX3Rhc2tfciBzZXF1ZW5jZSA9XG4gICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDpDYW5jZWxfdGhpc19wcm9taXNlIGluXG4gICAgbGV0IG5vZGUgPSBMd3Rfc2VxdWVuY2UuYWRkX3IgKHRvX3B1YmxpY19yZXNvbHZlciBwKSBzZXF1ZW5jZSBpblxuICAgIGxldCBub2RlID0gY2FzdF9zZXF1ZW5jZV9ub2RlIG5vZGUgcCBpblxuXG4gICAgbGV0IFBlbmRpbmcgY2FsbGJhY2tzID0gcC5zdGF0ZSBpblxuICAgIGNhbGxiYWNrcy5jYW5jZWxfY2FsbGJhY2tzIDwtXG4gICAgICBDYW5jZWxfY2FsbGJhY2tfbGlzdF9yZW1vdmVfc2VxdWVuY2Vfbm9kZSBub2RlO1xuXG4gICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gIGxldCBhZGRfdGFza19sIHNlcXVlbmNlID1cbiAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOkNhbmNlbF90aGlzX3Byb21pc2UgaW5cbiAgICBsZXQgbm9kZSA9IEx3dF9zZXF1ZW5jZS5hZGRfbCAodG9fcHVibGljX3Jlc29sdmVyIHApIHNlcXVlbmNlIGluXG4gICAgbGV0IG5vZGUgPSBjYXN0X3NlcXVlbmNlX25vZGUgbm9kZSBwIGluXG5cbiAgICBsZXQgUGVuZGluZyBjYWxsYmFja3MgPSBwLnN0YXRlIGluXG4gICAgY2FsbGJhY2tzLmNhbmNlbF9jYWxsYmFja3MgPC1cbiAgICAgIENhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIG5vZGU7XG5cbiAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cblxuXG4gIGxldCBwcm90ZWN0ZWQgcCA9XG4gICAgbGV0IEludGVybmFsIHBfaW50ZXJuYWwgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwX2ludGVybmFsKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPiBwXG4gICAgfCBSZWplY3RlZCBfIC0+IHBcblxuICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICBsZXQgcCcgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDpDYW5jZWxfdGhpc19wcm9taXNlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcgPSBtYXlfbm93X2JlX3Byb3h5IHAnIGluXG4gICAgICAgIGxldCBwJyA9IHVuZGVybHlpbmcgcCcgaW5cbiAgICAgICAgKCogSW4gdGhpcyBjYWxsYmFjaywgW3AnXSB3aWxsIGVpdGhlciBzdGlsbCBpdHNlbGYgYmUgcGVuZGluZywgb3IgaXRcbiAgICAgICAgICAgd2lsbCBoYXZlIGJlY29tZSBhIHByb3h5IGZvciBhIHBlbmRpbmcgcHJvbWlzZS4gVGhlIHJlYXNvbmluZyBmb3JcbiAgICAgICAgICAgdGhpcyBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgaW4gdGhlIGNvbW1lbnQgYXQgW21heV9ub3dfYmVfcHJveHldLiBUaGVcbiAgICAgICAgICAgZGlmZmVyZW5jZXMgYXJlOlxuXG4gICAgICAgICAgIC0gW3AnXSAqaXMqIGFuIGluaXRpYWwgcHJvbWlzZSwgc28gaXQgKmNhbiogZ2V0IGNhbmNlbGVkLiBIb3dldmVyLCBpZlxuICAgICAgICAgICAgIGl0IGRvZXMsIHRoZSBbb25fY2FuY2VsXSBoYW5kbGVyIGluc3RhbGxlZCBiZWxvdyB3aWxsIHJlbW92ZSB0aGlzXG4gICAgICAgICAgICAgY2FsbGJhY2suXG4gICAgICAgICAgIC0gW3AnXSBuZXZlciBnZXRzIHBhc3NlZCB0byBbbWFrZV9pbnRvX3Byb3h5XSwgdGhlIG9ubHkgZWZmZWN0IG9mXG4gICAgICAgICAgICAgd2hpY2ggaXMgdGhhdCBpdCBjYW5ub3QgYmUgdGhlIHVuZGVybHlpbmcgcHJvbWlzZSBvZiBhbm90aGVyXG4gICAgICAgICAgICAgKHByb3h5KSBwcm9taXNlLiBTbywgW3AnXSBjYW4gb25seSBhcHBlYXIgYXQgdGhlIGhlYWQgb2YgYSBjaGFpbiBvZlxuICAgICAgICAgICAgIFtQcm94eSBfXSBsaW5rcywgYW5kIGl0J3Mgbm90IG5lY2Vzc2FyeSB0byB3b3JyeSBhYm91dCB3aGV0aGVyIHRoZVxuICAgICAgICAgICAgIGluZHVjdGl2ZSByZWFzb25pbmcgYXQgW21heV9ub3dfYmVfcHJveHldIGFwcGxpZXMuICopXG5cbiAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcgPVxuICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJyBwX3Jlc3VsdCBpblxuICAgICAgICBpZ25vcmUgcCdcbiAgICAgIGluXG5cbiAgICAgIGxldCByZW1vdmVfdGhlX2NhbGxiYWNrID1cbiAgICAgICAgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2FuZF9naXZlX3JlbW92ZV9mdW5jdGlvblxuICAgICAgICAgIFtwXSBjYWxsYmFja1xuICAgICAgaW5cblxuICAgICAgbGV0IFBlbmRpbmcgcCdfY2FsbGJhY2tzID0gcCcuc3RhdGUgaW5cbiAgICAgIGFkZF9jYW5jZWxfY2FsbGJhY2sgcCdfY2FsbGJhY2tzIHJlbW92ZV90aGVfY2FsbGJhY2s7XG5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHAnXG5cbiAgbGV0IG5vX2NhbmNlbCBwID1cbiAgICBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHBfaW50ZXJuYWwpLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+IHBcbiAgICB8IFJlamVjdGVkIF8gLT4gcFxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgcCcgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDpOb3RfY2FuY2VsYWJsZSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcF9yZXN1bHQgPVxuICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnID0gbWF5X25vd19iZV9wcm94eSBwJyBpblxuICAgICAgICBsZXQgcCcgPSB1bmRlcmx5aW5nIHAnIGluXG4gICAgICAgICgqIEluIHRoaXMgY2FsbGJhY2ssIFtwJ10gd2lsbCBlaXRoZXIgc3RpbGwgaXRzZWxmIGJlIHBlbmRpbmcsIG9yIGl0XG4gICAgICAgICAgIHdpbGwgaGF2ZSBiZWNvbWUgYSBwcm94eSBmb3IgYSBwZW5kaW5nIHByb21pc2UuIFRoZSByZWFzb25pbmcgZm9yXG4gICAgICAgICAgIHRoaXMgaXMgYXMgaW4gW3Byb3RlY3RlZF0gYW5kIFttYXlfbm93X2JlX3Byb3h5XSwgYnV0IGV2ZW4gc2ltcGxlcixcbiAgICAgICAgICAgYmVjYXVzZSBbcCddIGlzIG5vdCBjYW5jZWxhYmxlLiAqKVxuXG4gICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnID1cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcgcF9yZXN1bHQgaW5cbiAgICAgICAgaWdub3JlIHAnXG4gICAgICBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcblxuICAgICAgdG9fcHVibGljX3Byb21pc2UgcCdcbmVuZFxuaW5jbHVkZSBQZW5kaW5nX3Byb21pc2VzXG5cblxuXG5tb2R1bGUgU2VxdWVudGlhbF9jb21wb3NpdGlvbiA6XG5zaWdcbiAgKCogTWFpbiBpbnRlcmZhY2UgKHB1YmxpYykgKilcbiAgdmFsIGJpbmQgOiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XG4gIHZhbCBtYXAgOiAoJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICBleHRlcm5hbCByZXJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmVyYWlzZVwiXG4gIHZhbCBjYXRjaCA6ICh1bml0IC0+ICdhIHQpIC0+IChleG4gLT4gJ2EgdCkgLT4gJ2EgdFxuICB2YWwgZmluYWxpemUgOiAodW5pdCAtPiAnYSB0KSAtPiAodW5pdCAtPiB1bml0IHQpIC0+ICdhIHRcbiAgdmFsIHRyeV9iaW5kIDogKHVuaXQgLT4gJ2EgdCkgLT4gKCdhIC0+ICdiIHQpIC0+IChleG4gLT4gJ2IgdCkgLT4gJ2IgdFxuXG4gICgqIENhbmNlbCBjYWxsYmFja3MgKHB1YmxpYykuICopXG4gIHZhbCBvbl9jYW5jZWwgOiAnYSB0IC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiBOb24tcHJvbWlzZSBjYWxsYmFja3MgKHB1YmxpYykgKilcbiAgdmFsIG9uX3N1Y2Nlc3MgOiAnYSB0IC0+ICgnYSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBvbl9mYWlsdXJlIDogXyB0IC0+IChleG4gLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgb25fdGVybWluYXRpb24gOiBfIHQgLT4gKHVuaXQgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgb25fYW55IDogJ2EgdCAtPiAoJ2EgLT4gdW5pdCkgLT4gKGV4biAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCogQmFja3RyYWNlIHN1cHBvcnQgKGludGVybmFsOyBmb3IgdXNlIGJ5IHRoZSBQUFgpICopXG4gIHZhbCBiYWNrdHJhY2VfYmluZCA6XG4gICAgKGV4biAtPiBleG4pIC0+ICdhIHQgLT4gKCdhIC0+ICdiIHQpIC0+ICdiIHRcbiAgdmFsIGJhY2t0cmFjZV9jYXRjaCA6XG4gICAgKGV4biAtPiBleG4pIC0+ICh1bml0IC0+ICdhIHQpIC0+IChleG4gLT4gJ2EgdCkgLT4gJ2EgdFxuICB2YWwgYmFja3RyYWNlX2ZpbmFsaXplIDpcbiAgICAoZXhuIC0+IGV4bikgLT4gKHVuaXQgLT4gJ2EgdCkgLT4gKHVuaXQgLT4gdW5pdCB0KSAtPiAnYSB0XG4gIHZhbCBiYWNrdHJhY2VfdHJ5X2JpbmQgOlxuICAgIChleG4gLT4gZXhuKSAtPiAodW5pdCAtPiAnYSB0KSAtPiAoJ2EgLT4gJ2IgdCkgLT4gKGV4biAtPiAnYiB0KSAtPiAnYiB0XG5lbmQgPVxuc3RydWN0XG4gICgqIFRoZXJlIGFyZSBmaXZlIHByaW1hcnkgc2VxdWVudGlhbCBjb21wb3NpdGlvbiBmdW5jdGlvbnM6IFtiaW5kXSwgW21hcF0sXG4gICAgIFtjYXRjaF0sIFtmaW5hbGl6ZV0sIGFuZCBbdHJ5X2JpbmRdLiBPZiB0aGVzZSwgW3RyeV9iaW5kXSBpcyB0aGUgbW9zdFxuICAgICBnZW5lcmFsIC0tIGFsbCB0aGUgb3RoZXJzIGNhbiBiZSBpbXBsZW1lbnRlZCBpbiB0ZXJtcyBvZiBpdC5cblxuICAgICBMd3QgY29uZmxhdGVzIGNvbmN1cnJlbmN5IHdpdGggZXJyb3IgcHJvcGFnYXRpb24uIElmIEx3dCBkaWQgbm90IGRvIHRoaXMsXG4gICAgIHRoZXJlIHdvdWxkIGJlIG9ubHkgdHdvIHByaW1hcnkgZnVuY3Rpb25zOiBbYmluZF0gYW5kIFttYXBdLCBhbmQsIG9mIHRoZXNlXG4gICAgIHR3bywgW2JpbmRdIGlzIHRoZSBtb3N0IGdlbmVyYWwuIFNpbmNlIFtiaW5kXSBpcyB0aGUgbW9zdCByZWxldmFudFxuICAgICBzcGVjaWZpY2FsbHkgdG8gY29uY3VycmVuY3ksIGFuZCBpcyBhbHNvIHRoZSBtb3N0IGZhbWlsaWFyIGZ1bmN0aW9uIGluIEx3dCxcbiAgICAgaXRzIGltcGxlbWVudGF0aW9uIHNlcnZlcyBhcyBhIGtpbmQgb2YgXCJtb2RlbFwiIGZvciB0aGUgcmVzdC4gSXQgaXMgdGhlIG1vc3RcbiAgICAgY29tbWVudGVkLCBhbmQgYWxsIHRoZSBvdGhlciBmdW5jdGlvbnMgZm9sbG93IGEgc2ltaWxhciBwYXR0ZXJuIHRvIFtiaW5kXS5cblxuICAgICBGb3VyIG9mIHRoZSBwcmltYXJ5IGZ1bmN0aW9ucyBoYXZlIFtiYWNrdHJhY2VfKl0gdmVyc2lvbnMsIHdoaWNoIGFyZSBub3RcbiAgICAgdHJ1bHkgcHVibGljLCBhbmQgZXhpc3QgdG8gc3VwcG9ydCB0aGUgUFBYLiBbYmFja3RyYWNlX21hcF0gZG9lcyBub3QgZXhpc3RcbiAgICAgYmVjYXVzZSB0aGUgUFBYIGRvZXMgbm90IG5lZWQgaXQuXG5cbiAgICAgVGhlIHJlbWFpbmluZyBmb3VyIGZ1bmN0aW9ucyBpbiB0aGlzIHNlY3Rpb24gYXR0YWNoIFwibG93ZXItbGV2ZWwtaXNoXCJcbiAgICAgbm9uLXByb21pc2UtcHJvZHVjaW5nIGNhbGxiYWNrcyB0byBwcm9taXNlczogdGhlc2UgYXJlIHRoZSBbb25fKl1cbiAgICAgZnVuY3Rpb25zLiBPZiB0aGVzZSwgW29uX2FueV0gaXMgdGhlIG1vc3QgZ2VuZXJhbC4gSWYgTHd0IGRpZCBub3QgY29uZmxhdGVcbiAgICAgY29uY3VycmVuY3kgd2l0aCBlcnJvciBoYW5kbGluZywgdGhlcmUgd291bGQgb25seSBiZSBvbmU6IFtvbl9zdWNjZXNzXS4gKilcblxuXG5cbiAgKCogTWFrZXMgW351c2VyX3Byb3ZpZGVkX3Byb21pc2VdIGludG8gYSBwcm94eSBvZiBbfm91dGVyX3Byb21pc2VdLiBBZnRlclxuICAgICBbbWFrZV9pbnRvX3Byb3h5XSwgdGhlc2UgdHdvIHByb21pc2UgcmVmZXJlbmNlcyBcImJlaGF2ZSBpZGVudGljYWxseS5cIlxuXG4gICAgIE5vdGUgdGhhdCB0aGlzIGlzIG5vdCBzeW1tZXRyaWM6IFt1c2VyX3Byb3ZpZGVkX3Byb21pc2VdIGFsd2F5cyBiZWNvbWVzIHRoZVxuICAgICBwcm94eS4gW21ha2VfaW50b19wcm94eV0gaXMgY2FsbGVkIG9ubHkgYnkgW2JpbmRdIGFuZCBzaW1pbGFyIGZ1bmN0aW9ucyBpblxuICAgICB0aGlzIG1vZHVsZS4gVGhpcyBtZWFucyB0aGF0OlxuXG4gICAgIC0gdGhlIG9ubHkgd2F5IGZvciBhIHByb21pc2UgdG8gYmVjb21lIGEgcHJveHkgaXMgYnkgYmVpbmcgcmV0dXJuZWQgZnJvbVxuICAgICAgIHRoZSBjYWxsYmFjayBnaXZlbiBieSB0aGUgdXNlciB0byBbYmluZF0sIG9yIGEgc2ltaWxhciBmdW5jdGlvbiwgYW5kXG4gICAgIC0gdGhlIG9ubHkgd2F5IGZvciBhIHByb21pc2UgdG8gYmVjb21lIHVuZGVybHlpbmcgZm9yIGEgcHJvbWlzZSBvdGhlciB0aGFuXG4gICAgICAgaXRzZWxmIGlzIHRvIGJlIHRoZSBvdXRlciBwcm9taXNlIG9yaWdpbmFsbHkgcmV0dXJuZWQgdG8gdGhlIHVzZXIgZnJvbVxuICAgICAgIFtiaW5kXSwgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uLlxuXG4gICAgIFRoZXNlIHR3byBmYWN0cyBhcmUgaW1wb3J0YW50IGZvciByZWFzb25pbmcgYWJvdXQgaG93IGFuZCB3aGljaCBwcm9taXNlc1xuICAgICBjYW4gYmVjb21lIHByb3hpZXMsIHVuZGVybHlpbmcsIGV0Yy47IGluIHBhcnRpY3VsYXIsIGl0IGlzIHVzZWQgaW4gdGhlXG4gICAgIGFyZ3VtZW50IGluIFttYXlfbm93X2JlX3Byb3h5XSBmb3IgY29ycmVjdCBwcmVkaWN0aW9ucyBhYm91dCBzdGF0ZSBjaGFuZ2VzLlxuXG4gICAgIFt+b3V0ZXJfcHJvbWlzZV0gaXMgYWx3YXlzIGEgcGVuZGluZyBwcm9taXNlIHdoZW4gW21ha2VfaW50b19wcm94eV0gaXNcbiAgICAgY2FsbGVkOyBmb3IgdGhlIGV4cGxhbmF0aW9uLCBzZWUgW21heV9ub3dfYmVfcHJveHldICh0aG91Z2ggdGhlIGNhbGxlciBvZlxuICAgICBbbWFrZV9pbnRvX3Byb3h5XSBhbHdheXMgY2FsbHMgW3VuZGVybHlpbmddIGZpcnN0IHRvIHBhc3MgdGhlIHVuZGVybHlpbmdcbiAgICAgcGVuZGluZyBwcm9taXNlIHRvIFttYWtlX2ludG9fcHJveHldKS5cblxuICAgICBUaGUgcmVhc29ucyBwcm94eWluZyBpcyB1c2VkLCBpbnN0ZWFkIG9mIGFkZGluZyBhIGNhbGxiYWNrIHRvXG4gICAgIFt+dXNlcl9wcm92aWRlZF9wcm9taXNlXSB0byByZXNvbHZlIFt+b3V0ZXJfcHJvbWlzZV0gd2hlbiB0aGUgZm9ybWVyXG4gICAgIGJlY29tZXMgcmVzb2x2ZWQgcHJvYmFibHkgYXJlOlxuXG4gICAgIC0gUHJvbWlzZXMgaGF2ZSBtb3JlIGJlaGF2aW9ycyB0aGFuIHJlc29sdXRpb24uIE9uZSB3b3VsZCBoYXZlIHRvIGFkZCBhXG4gICAgICAgY2FuY2VsbGF0aW9uIGhhbmRsZXIgdG8gW35vdXRlcl9wcm9taXNlXSB0byBwcm9wYWdhdGUgdGhlIGNhbmNlbGxhdGlvblxuICAgICAgIGJhY2sgdG8gW351c2VyX3Byb3ZpZGVkX3Byb21pc2VdLCBmb3IgZXhhbXBsZS4gSXQgbWF5IGJlIGVhc2llciB0byBqdXN0XG4gICAgICAgdGhpbmsgb2YgdGhlbSBhcyB0aGUgc2FtZSBwcm9taXNlLlxuICAgICAtIElmIHVzaW5nIGNhbGxiYWNrcywgcmVzb2x2aW5nIFt+dXNlcl9wcm92aWRlZF9wcm9taXNlXSB3b3VsZCBub3RcbiAgICAgICBpbW1lZGlhdGVseSByZXNvbHZlIFt+b3V0ZXJfcHJvbWlzZV0uIEFub3RoZXIgY2FsbGJhY2sgYWRkZWQgdG9cbiAgICAgICBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0gbWlnaHQgc2VlIFt+dXNlcl9wcm92aWRlZF9wcm9taXNlXSByZXNvbHZlZCxcbiAgICAgICBidXQgW35vdXRlcl9wcm9taXNlXSBzdGlsbCBwZW5kaW5nLCBkZXBlbmRpbmcgb24gdGhlIG9yZGVyIGluIHdoaWNoXG4gICAgICAgY2FsbGJhY2tzIGFyZSBydW4uICopXG4gIGxldCBtYWtlX2ludG9fcHJveHlcbiAgICAgICh0eXBlIGMpXG4gICAgICB+KG91dGVyX3Byb21pc2UgOiAoJ2EsIHVuZGVybHlpbmcsIHBlbmRpbmcpIHByb21pc2UpXG4gICAgICB+KHVzZXJfcHJvdmlkZWRfcHJvbWlzZSA6ICgnYSwgXywgYykgcHJvbWlzZSlcbiAgICAgICAgOiAoJ2EsIHVuZGVybHlpbmcsIGMpIHN0YXRlX2NoYW5nZWQgPVxuXG4gICAgKCogVXNpbmcgW3AnXSBhcyBpdCdzIHRoZSBuYW1lIHVzZWQgaW5zaWRlIFtiaW5kXSwgZXRjLiwgZm9yIHByb21pc2VzIHdpdGhcbiAgICAgICB0aGlzIHJvbGUgLS0gW3AnXSBpcyB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgdXNlcidzIGZ1bmN0aW9uLiAqKVxuICAgIGxldCBwJyA9IHVuZGVybHlpbmcgdXNlcl9wcm92aWRlZF9wcm9taXNlIGluXG5cbiAgICBpZiBpZGVudGljYWwgcCcgb3V0ZXJfcHJvbWlzZSB0aGVuXG4gICAgICBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnXG4gICAgICAoKiBXZSByZWFsbHkgd2FudCB0byByZXR1cm4gW1N0YXRlX21heV9oYXZlX2NoYW5nZWQgb3V0ZXJfcHJvbWlzZV0sIGJ1dFxuICAgICAgICAgdGhlIHJlZmVyZW5jZSB0aHJvdWdoIFtwJ10gaGFzIHRoZSByaWdodCB0eXBlLiAqKVxuXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggcCcuc3RhdGUgd2l0aFxuICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2Ugb3V0ZXJfcHJvbWlzZSBwJy5zdGF0ZVxuICAgICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBvdXRlcl9wcm9taXNlIHAnLnN0YXRlXG5cbiAgICAgIHwgUGVuZGluZyBwJ19jYWxsYmFja3MgLT5cbiAgICAgICAgbGV0IFBlbmRpbmcgb3V0ZXJfY2FsbGJhY2tzID0gb3V0ZXJfcHJvbWlzZS5zdGF0ZSBpblxuXG4gICAgICAgIG1lcmdlX2NhbGxiYWNrcyB+ZnJvbTpwJ19jYWxsYmFja3MgfmludG86b3V0ZXJfY2FsbGJhY2tzO1xuICAgICAgICBvdXRlcl9jYWxsYmFja3MuaG93X3RvX2NhbmNlbCA8LSBwJ19jYWxsYmFja3MuaG93X3RvX2NhbmNlbDtcblxuICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJyA9XG4gICAgICAgICAgc2V0X3Byb21pc2Vfc3RhdGUgcCcgKFByb3h5IG91dGVyX3Byb21pc2UpIGluXG4gICAgICAgIGlnbm9yZSBwJztcblxuICAgICAgICBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIG91dGVyX3Byb21pc2VcbiAgICAgICAgKCogVGhlIHN0YXRlIGhhc24ndCBhY3R1YWxseSBjaGFuZ2VkLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byB3cmFwXG4gICAgICAgICAgIFtvdXRlcl9wcm9taXNlXSBmb3IgdHlwZSBjaGVja2luZy4gKilcblxuICAgICAgICAoKiBUaGUgc3RhdGUgb2YgW3AnXSBtYXkgaW5zdGVhZCBoYXZlIGNoYW5nZWQgLS0gaXQgbWF5IGhhdmUgYmVjb21lIGFcbiAgICAgICAgICAgcHJveHkuIEhvd2V2ZXIsIGNhbGxlcnMgb2YgW21ha2VfaW50b19wcm94eV0gZG9uJ3Qga25vdyBpZlxuICAgICAgICAgICBbdXNlcl9wcm92aWRlZF9wcm9taXNlXSB3YXMgYSBwcm94eSBvciBub3QgKHRoYXQncyB3aHkgd2UgY2FsbFxuICAgICAgICAgICB1bmRlcmx5aW5nIG9uIGl0IGF0IHRoZSB0b3Agb2YgdGhpcyBmdW5jdGlvbiwgdG8gZ2V0IFtwJ10pLiBXZSBjYW5cbiAgICAgICAgICAgdGhlcmVmb3JlIHRha2UgYSBkYW5nZXJvdXMgc2hvcnRjdXQgYW5kIG5vdCBib3RoZXIgcmV0dXJuaW5nIGEgbmV3XG4gICAgICAgICAgIHJlZmVyZW5jZSB0byBbdXNlcl9wcm92aWRlZF9wcm9taXNlXSBmb3Igc2hhZG93aW5nLiAqKVxuXG5cblxuICAoKiBNYWludGFpbmVyJ3Mgbm90ZTogYSBsb3Qgb2YgdGhlIGNvZGUgYmVsb3cgY2FuIHByb2JhYmx5IGJlIGRlZHVwbGljYXRlZCBpblxuICAgICBzb21lIHdheSwgZXNwZWNpYWxseSBpZiBhc3N1bWluZyBGbGFtYmRhLiAqKVxuXG4gIGxldCBiaW5kIHAgZiA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgKCogSW4gY2FzZSBbTHd0LmJpbmRdIG5lZWRzIHRvIGRlZmVyIHRoZSBjYWxsIHRvIFtmXSwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlXG4gICAgICAgY2FsbGVkIHRvIGNyZWF0ZTpcblxuICAgICAgIDEuIFRoZSBwcm9taXNlLCBbcCcnXSwgdGhhdCBtdXN0IGJlIHJldHVybmVkIHRvIHRoZSBjYWxsZXIgaW1tZWRpYXRlbHkuXG4gICAgICAgMi4gVGhlIGNhbGxiYWNrIHRoYXQgcmVzb2x2ZXMgW3AnJ10uXG5cbiAgICAgICBbTHd0LmJpbmRdIGRlZmVycyB0aGUgY2FsbCB0byBbZl0gaW4gdHdvIGNpcmN1bXN0YW5jZXM6XG5cbiAgICAgICAxLiBUaGUgcHJvbWlzZSBbcF0gaXMgcGVuZGluZy5cbiAgICAgICAyLiBUaGUgcHJvbWlzZSBbcF0gaXMgZnVsZmlsbGVkLCBidXQgdGhlIGN1cnJlbnQgY2FsbGJhY2sgY2FsbCBuZXN0aW5nXG4gICAgICAgICAgZGVwdGggaXMgc3VjaCB0aGF0IHRoZSBjYWxsIHRvIFtmXSBtdXN0IGdvIGludG8gdGhlIGNhbGxiYWNrIHF1ZXVlLCBpblxuICAgICAgICAgIG9yZGVyIHRvIGF2b2lkIHN0YWNrIG92ZXJmbG93LlxuXG4gICAgICBNZWNoYW5pc20gKDIpIGlzIGN1cnJlbnRseSBkaXNhYmxlZC4gSXQgbWF5IGJlIHVzZWQgaW4gYW4gYWx0ZXJuYXRpdmUgTHd0XG4gICAgICBBUEkuXG5cbiAgICAgIEZ1bmN0aW9ucyBvdGhlciB0aGFuIFtMd3QuYmluZF0gaGF2ZSBhbmFsb2dvdXMgZGVmZXJyYWwgYmVoYXZpb3IuICopXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuICAgICAgKCogVGhlIHJlc3VsdCBwcm9taXNlIGlzIGEgZnJlc2ggcGVuZGluZyBwcm9taXNlLlxuXG4gICAgICAgICBJbml0aWFsbHksIHRyeWluZyB0byBjYW5jZWwgdGhpcyBmcmVzaCBwZW5kaW5nIHByb21pc2UgW3AnJ10gd2lsbFxuICAgICAgICAgcHJvcGFnYXRlIHRoZSBjYW5jZWxsYXRpb24gYXR0ZW1wdCB0byBbcF0gKGJhY2t3YXJkcyB0aHJvdWdoIHRoZVxuICAgICAgICAgcHJvbWlzZSBkZXBlbmRlbmN5IGdyYXBoKS4gSWYvd2hlbiBbcF0gaXMgZnVsZmlsbGVkLCBMd3Qgd2lsbCBjYWxsIHRoZVxuICAgICAgICAgdXNlcidzIGNhbGxiYWNrIFtmXSBiZWxvdywgd2hpY2ggd2lsbCBwcm92aWRlIGEgbmV3IHByb21pc2UgW3AnXSwgYW5kXG4gICAgICAgICBbcCddIHdpbGwgYmVjb21lIGEgcHJveHkgb2YgW3AnJ10uIEF0IHRoYXQgcG9pbnQsIHRyeWluZyB0byBjYW5jZWxcbiAgICAgICAgIFtwJyddIHdpbGwgYmUgZXF1aXZhbGVudCB0byB0cnlpbmcgdG8gY2FuY2VsIFtwJ10sIHNvIHRoZSBiZWhhdmlvciB3aWxsXG4gICAgICAgICBkZXBlbmQgb24gaG93IHRoZSB1c2VyIG9idGFpbmVkIFtwJ10uICopXG5cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcF9yZXN1bHQgPVxuICAgICAgICBtYXRjaCBwX3Jlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9XG4gICAgICAgICAgICB0cnkgZiB2IHdpdGggZXhuXG4gICAgICAgICAgICB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuICAgICAgICAgICgqIFJ1biB0aGUgdXNlcidzIGZ1bmN0aW9uIFtmXS4gKilcblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cbiAgICAgICAgICAoKiBbcCcnXSB3YXMgYW4gdW5kZXJseWluZyBwcm9taXNlIHdoZW4gaXQgd2FzIGNyZWF0ZWQgYWJvdmUsIGJ1dCBpdFxuICAgICAgICAgICAgIG1heSBoYXZlIGJlY29tZSBhIHByb3h5IGJ5IHRoZSB0aW1lIHRoaXMgY29kZSBpcyBiZWluZyBleGVjdXRlZC5cbiAgICAgICAgICAgICBIb3dldmVyLCBpdCBpcyBzdGlsbCBlaXRoZXIgYW4gdW5kZXJseWluZyBwZW5kaW5nIHByb21pc2UsIG9yIGFcbiAgICAgICAgICAgICBwcm94eSBmb3IgYSBwZW5kaW5nIHByb21pc2UuIFRoZXJlZm9yZSwgW21heV9ub3dfYmVfcHJveHldIHByb2R1Y2VzXG4gICAgICAgICAgICAgYSByZWZlcmVuY2Ugd2l0aCB0aGUgcmlnaHQgdHlwZSB2YXJpYWJsZXMuIFdlIGltbWVkaWF0ZWx5IGdldFxuICAgICAgICAgICAgIFtwJyddJ3MgY3VycmVudCB1bmRlcmx5aW5nIHByb21pc2UuICopXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgbWFrZV9pbnRvX3Byb3h5IH5vdXRlcl9wcm9taXNlOnAnJyB+dXNlcl9wcm92aWRlZF9wcm9taXNlOnAnIGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuICAgICAgICAgICgqIE1ha2UgdGhlIG91dGVyIHByb21pc2UgW3AnJ10gYmVoYXZpb3JhbGx5IGlkZW50aWNhbCB0byB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgIFtwJ10gcmV0dXJuZWQgYnkgW2ZdIGJ5IG1ha2luZyBbcCddIGludG8gYSBwcm94eSBvZiBbcCcnXS4gKilcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcF9yZXN1bHQgLT5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnJyBwX3Jlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGYgdilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPSBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrO1xuICAgICAgcCcnXG5cbiAgbGV0IGJhY2t0cmFjZV9iaW5kIGFkZF9sb2MgcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSA9XG4gICAgICBsZXQgcCcnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KFByb3BhZ2F0ZV9jYW5jZWxfdG9fb25lIHApIGluXG5cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcF9yZXN1bHQgPVxuICAgICAgICBtYXRjaCBwX3Jlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9XG4gICAgICAgICAgICB0cnkgZiB2XG4gICAgICAgICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgICAgICAgICAgICBmYWlsIChhZGRfbG9jIGV4bikgaW5cbiAgICAgICAgICBsZXQgSW50ZXJuYWwgcCcgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgbWFrZV9pbnRvX3Byb3h5IH5vdXRlcl9wcm9taXNlOnAnJyB+dXNlcl9wcm92aWRlZF9wcm9taXNlOnAnIGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJycgKFJlamVjdGVkIChhZGRfbG9jIGV4bikpIGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuICAgICAgaW5cblxuICAgICAgKHRvX3B1YmxpY19wcm9taXNlIHAnJywgY2FsbGJhY2spXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gZiB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSBSZWplY3RlZCAoYWRkX2xvYyBleG4pfVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgKHAnJywgY2FsbGJhY2spID0gY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcbiAgICAgIHAnJ1xuXG4gIGxldCBtYXAgZiBwID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSA9XG4gICAgICBsZXQgcCcnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KFByb3BhZ2F0ZV9jYW5jZWxfdG9fb25lIHApIGluXG5cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcF9yZXN1bHQgPVxuICAgICAgICBtYXRjaCBwX3Jlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJydfcmVzdWx0ID1cbiAgICAgICAgICAgIHRyeSBGdWxmaWxsZWQgKGYgdikgd2l0aCBleG5cbiAgICAgICAgICAgIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IFJlamVjdGVkIGV4blxuICAgICAgICAgIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnJyBwJydfcmVzdWx0IGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyBwX3Jlc3VsdCAtPlxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcnIHBfcmVzdWx0IGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuICAgICAgaW5cblxuICAgICAgKHRvX3B1YmxpY19wcm9taXNlIHAnJywgY2FsbGJhY2spXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT5cbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZVxuICAgICAgICAgICAge3N0YXRlID1cbiAgICAgICAgICAgICAgdHJ5IEZ1bGZpbGxlZCAoZiB2KVxuICAgICAgICAgICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBSZWplY3RlZCBleG59KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBleHRlcm5hbCByZXJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmVyYWlzZVwiXG5cbiAgbGV0IGNhdGNoIGYgaCA9XG4gICAgbGV0IHAgPVxuICAgICAgdHJ5IGYgKClcbiAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG4gICAgaW5cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSA9XG4gICAgICBsZXQgcCcnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KFByb3BhZ2F0ZV9jYW5jZWxfdG9fb25lIHApIGluXG5cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcF9yZXN1bHQgPVxuICAgICAgICBtYXRjaCBwX3Jlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIF8gYXMgcF9yZXN1bHQgLT5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnJyBwX3Jlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwJydcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID1cbiAgICAgICAgICAgIHRyeSBoIGV4blxuICAgICAgICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaCBleG4pXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgKHAnJywgY2FsbGJhY2spID0gY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcbiAgICAgIHAnJ1xuXG4gIGxldCBiYWNrdHJhY2VfY2F0Y2ggYWRkX2xvYyBmIGggPVxuICAgIGxldCBwID1cbiAgICAgIHRyeSBmICgpXG4gICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuICAgIGluXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCBfIGFzIHBfcmVzdWx0IC0+XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJycgcF9yZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9XG4gICAgICAgICAgICB0cnkgaCBleG5cbiAgICAgICAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+XG4gICAgICAgICAgICAgIGZhaWwgKGFkZF9sb2MgZXhuKVxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoIChhZGRfbG9jIGV4bikpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgKHAnJywgY2FsbGJhY2spID0gY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcbiAgICAgIHAnJ1xuXG4gIGxldCB0cnlfYmluZCBmIGYnIGggPVxuICAgIGxldCBwID1cbiAgICAgIHRyeSBmICgpXG4gICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuICAgIGluXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPVxuICAgICAgICAgICAgdHJ5IGYnIHZcbiAgICAgICAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgSW50ZXJuYWwgcCcgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgbWFrZV9pbnRvX3Byb3h5IH5vdXRlcl9wcm9taXNlOnAnJyB+dXNlcl9wcm92aWRlZF9wcm9taXNlOnAnIGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPVxuICAgICAgICAgICAgdHJ5IGggZXhuXG4gICAgICAgICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGYnIHYpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaCBleG4pXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgKHAnJywgY2FsbGJhY2spID0gY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcbiAgICAgIHAnJ1xuXG4gIGxldCBiYWNrdHJhY2VfdHJ5X2JpbmQgYWRkX2xvYyBmIGYnIGggPVxuICAgIGxldCBwID1cbiAgICAgIHRyeSBmICgpXG4gICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuICAgIGluXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPVxuICAgICAgICAgICAgdHJ5IGYnIHZcbiAgICAgICAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+XG4gICAgICAgICAgICAgIGZhaWwgKGFkZF9sb2MgZXhuKVxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID1cbiAgICAgICAgICAgIHRyeSBoIGV4blxuICAgICAgICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT5cbiAgICAgICAgICAgICAgZmFpbCAoYWRkX2xvYyBleG4pXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgSW50ZXJuYWwgcCcgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgbWFrZV9pbnRvX3Byb3h5IH5vdXRlcl9wcm9taXNlOnAnJyB+dXNlcl9wcm92aWRlZF9wcm9taXNlOnAnIGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuICAgICAgaW5cblxuICAgICAgKHRvX3B1YmxpY19wcm9taXNlIHAnJywgY2FsbGJhY2spXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gZicgdilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoIChhZGRfbG9jIGV4bikpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgKHAnJywgY2FsbGJhY2spID0gY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcbiAgICAgIHAnJ1xuXG4gIGxldCBmaW5hbGl6ZSBmIGYnID1cbiAgICB0cnlfYmluZCBmXG4gICAgICAoZnVuIHggLT4gYmluZCAoZicgKCkpIChmdW4gKCkgLT4gcmV0dXJuIHgpKVxuICAgICAgKGZ1biBlIC0+IGJpbmQgKGYnICgpKSAoZnVuICgpIC0+IGZhaWwgZSkpXG5cbiAgbGV0IGJhY2t0cmFjZV9maW5hbGl6ZSBhZGRfbG9jIGYgZicgPVxuICAgIGJhY2t0cmFjZV90cnlfYmluZCBhZGRfbG9jIGZcbiAgICAgIChmdW4geCAtPiBiaW5kIChmJyAoKSkgKGZ1biAoKSAtPiByZXR1cm4geCkpXG4gICAgICAoZnVuIGUgLT4gYmluZCAoZicgKCkpIChmdW4gKCkgLT4gZmFpbCAoYWRkX2xvYyBlKSkpXG5cblxuXG4gIGxldCBvbl9jYW5jZWwgcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IFJlamVjdGVkIENhbmNlbGVkIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgKCkpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgKCgpLCAoZnVuIF8gLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiAoKSksIEZ1bGZpbGxlZCAoKSkpXG5cbiAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgICgpXG5cbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAoKVxuXG4gICAgfCBQZW5kaW5nIGNhbGxiYWNrcyAtPlxuICAgICAgYWRkX2NhbmNlbF9jYWxsYmFjayBjYWxsYmFja3MgZlxuXG5cblxuICBsZXQgb25fc3VjY2VzcyBwIGYgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSA9XG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgZnVuIHJlc3VsdCAtPlxuICAgICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG4gICAgICAgICAgaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiB2XG5cbiAgICAgICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICAgICAgKClcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIHYpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAoKCksIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgKClcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2tcblxuICBsZXQgb25fZmFpbHVyZSBwIGYgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSA9XG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgZnVuIHJlc3VsdCAtPlxuICAgICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAgICAgKClcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgICAgIGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgZXhuXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICgpXG5cbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIGV4bilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgICgoKSwgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFja1xuXG4gIGxldCBvbl90ZXJtaW5hdGlvbiBwIGYgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSA9XG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgZnVuIF9yZXN1bHQgLT5cbiAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG4gICAgICAgIGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgKClcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgKCkpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAoKCksIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2tcblxuICBsZXQgb25fYW55IHAgZiBnID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGZ1biByZXN1bHQgLT5cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgICAgIGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgdlxuXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG4gICAgICAgICAgaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZyBleG5cbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIHYpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAoKCksIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGcgZXhuKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5lbmRcbmluY2x1ZGUgU2VxdWVudGlhbF9jb21wb3NpdGlvblxuXG5cbigqIFRoaXMgYmVsb25ncyB3aXRoIHRoZSBbcHJvdGVjdGVkXSBhbmQgc3VjaCwgYnV0IGl0IGRlcGVuZHMgb24gcHJpbWl0aXZlcyBmcm9tXG4gICBbU2VxdWVudGlhbF9jb21wb3NpdGlvbl0uICopXG5sZXQgd3JhcF9pbl9jYW5jZWxhYmxlIHAgPVxuIGxldCBJbnRlcm5hbCBwX2ludGVybmFsID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gbGV0IHBfdW5kZXJseWluZyA9IHVuZGVybHlpbmcgcF9pbnRlcm5hbCBpblxuIG1hdGNoIHBfdW5kZXJseWluZy5zdGF0ZSB3aXRoXG4gfCBGdWxmaWxsZWQgXyAtPiBwXG4gfCBSZWplY3RlZCBfIC0+IHBcbiB8IFBlbmRpbmcgXyAtPlxuICAgbGV0IHAnLCByID0gdGFzayAoKSBpblxuICAgb25fY2FuY2VsIHAnIChmdW4gKCkgLT4gY2FuY2VsIHApO1xuICAgb25fYW55IHAgKHdha2V1cCByKSAod2FrZXVwX2V4biByKTtcbiAgIHAnXG5cblxubW9kdWxlIENvbmN1cnJlbnRfY29tcG9zaXRpb24gOlxuc2lnXG4gIHZhbCBkb250X3dhaXQgOiAodW5pdCAtPiBfIHQpIC0+IChleG4gLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgYXN5bmMgOiAodW5pdCAtPiBfIHQpIC0+IHVuaXRcbiAgdmFsIGlnbm9yZV9yZXN1bHQgOiBfIHQgLT4gdW5pdFxuXG4gIHZhbCBib3RoIDogJ2EgdCAtPiAnYiB0IC0+ICgnYSAqICdiKSB0XG4gIHZhbCBqb2luIDogdW5pdCB0IGxpc3QgLT4gdW5pdCB0XG4gIHZhbCBhbGwgOiAoJ2EgdCkgbGlzdCAtPiAoJ2EgbGlzdCkgdFxuXG4gIHZhbCBjaG9vc2UgOiAnYSB0IGxpc3QgLT4gJ2EgdFxuICB2YWwgcGljayA6ICdhIHQgbGlzdCAtPiAnYSB0XG5cbiAgdmFsIG5jaG9vc2UgOiAnYSB0IGxpc3QgLT4gJ2EgbGlzdCB0XG4gIHZhbCBucGljayA6ICdhIHQgbGlzdCAtPiAnYSBsaXN0IHRcblxuICB2YWwgbmNob29zZV9zcGxpdCA6ICdhIHQgbGlzdCAtPiAoJ2EgbGlzdCAqICdhIHQgbGlzdCkgdFxuZW5kID1cbnN0cnVjdFxuICBleHRlcm5hbCByZXJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmVyYWlzZVwiXG5cbiAgbGV0IGRvbnRfd2FpdCBmIGggPVxuICAgIGxldCBwID1cbiAgICAgIHRyeSBmICgpXG4gICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuICAgIGluXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAoKVxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICBoIGV4blxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgY2FsbGJhY2sgcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICAgICgpXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgaCBleG5cbiAgICAgIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5cbiAgbGV0IGFzeW5jIGYgPVxuICAgIGxldCBwID1cbiAgICAgIHRyeSBmICgpXG4gICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuICAgIGluXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAoKVxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAhYXN5bmNfZXhjZXB0aW9uX2hvb2sgZXhuXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayByZXN1bHQgPVxuICAgICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAgICAgKClcbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICAhYXN5bmNfZXhjZXB0aW9uX2hvb2sgZXhuXG4gICAgICBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFja1xuXG4gIGxldCBpZ25vcmVfcmVzdWx0IHAgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgKClcbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgcmVyYWlzZSBleG5cblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IGNhbGxiYWNrIHJlc3VsdCA9XG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgICAoKVxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgICFhc3luY19leGNlcHRpb25faG9vayBleG5cbiAgICAgIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5cblxuXG4gIGxldCBqb2luIHBzID1cbiAgICBsZXQgcCcgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDoocHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIHBzKSBpblxuXG4gICAgbGV0IG51bWJlcl9wZW5kaW5nX2luX3BzID0gcmVmIDAgaW5cbiAgICBsZXQgam9pbl9yZXN1bHQgPSByZWYgKEZ1bGZpbGxlZCAoKSkgaW5cblxuICAgICgqIENhbGxiYWNrIGF0dGFjaGVkIHRvIGVhY2ggcHJvbWlzZSBpbiBbcHNdIHRoYXQgaXMgc3RpbGwgcGVuZGluZyBhdCB0aGVcbiAgICAgICB0aW1lIFtqb2luXSBpcyBjYWxsZWQuICopXG4gICAgbGV0IGNhbGxiYWNrIG5ld19yZXN1bHQgPVxuICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJyA9IG1heV9ub3dfYmVfcHJveHkgcCcgaW5cblxuICAgICAgYmVnaW4gbWF0Y2ggbmV3X3Jlc3VsdCB3aXRoXG4gICAgICB8IEZ1bGZpbGxlZCAoKSAtPiAoKVxuICAgICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICAoKiBGb3IgdGhlIGZpcnN0IHByb21pc2UgaW4gW3BzXSB0byBiZSByZWplY3RlZCwgc2V0IHRoZSByZXN1bHQgb2YgdGhlXG4gICAgICAgICBbam9pbl0gdG8gcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZSBleGNlcHRpb24uLiAqKVxuICAgICAgICBtYXRjaCAham9pbl9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCAoKSAtPiBqb2luX3Jlc3VsdCA6PSBuZXdfcmVzdWx0XG4gICAgICAgIHwgUmVqZWN0ZWQgXyAtPiAoKVxuICAgICAgZW5kO1xuXG4gICAgICAoKiBJbiBhbGwgY2FzZXMsIGRlY3JlbWVudCB0aGUgbnVtYmVyIG9mIHByb21pc2VzIHN0aWxsIHBlbmRpbmcsIGFuZFxuICAgICAgICAgcmVzb2x2ZSB0aGUgW2pvaW5dIG9uY2UgYWxsIHByb21pc2VzIHJlc29sdmUuICopXG4gICAgICBudW1iZXJfcGVuZGluZ19pbl9wcyA6PSAhbnVtYmVyX3BlbmRpbmdfaW5fcHMgLSAxO1xuICAgICAgaWYgIW51bWJlcl9wZW5kaW5nX2luX3BzID0gMCB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBwJyA9IHVuZGVybHlpbmcgcCcgaW5cbiAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcgPVxuICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSAodW5kZXJseWluZyBwJykgIWpvaW5fcmVzdWx0IGluXG4gICAgICAgIGlnbm9yZSBwJ1xuICAgICAgZW5kXG4gICAgaW5cblxuICAgICgqIEF0dGFjaCB0aGUgYWJvdmUgY2FsbGJhY2suIFNpbXVsdGFuZW91c2x5IGNvdW50IGhvdyBtYW55IHBlbmRpbmcgcHJvbWlzZXNcbiAgICAgICB0aGVyZSBhcmUgaW4gW3BzXSAoaW5pdGlhbGx5KS4gSWYgdGhhdCBudW1iZXIgaXMgemVybywgdGhlIFtqb2luXSBtdXN0XG4gICAgICAgcmVzb2x2ZSBpbW1lZGlhdGVseS4gKilcbiAgICBsZXQgcmVjIGF0dGFjaF9jYWxsYmFja19vcl9yZXNvbHZlX2ltbWVkaWF0ZWx5IHBzID1cbiAgICAgIG1hdGNoIHBzIHdpdGhcbiAgICAgIHwgW10gLT5cbiAgICAgICAgaWYgIW51bWJlcl9wZW5kaW5nX2luX3BzID0gMCB0aGVuXG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gIWpvaW5fcmVzdWx0fVxuICAgICAgICBlbHNlXG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2UgcCdcblxuICAgICAgfCBwOjpwcyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICAgICAgbnVtYmVyX3BlbmRpbmdfaW5fcHMgOj0gIW51bWJlcl9wZW5kaW5nX2luX3BzICsgMTtcbiAgICAgICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrO1xuICAgICAgICAgIGF0dGFjaF9jYWxsYmFja19vcl9yZXNvbHZlX2ltbWVkaWF0ZWx5IHBzXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHBfcmVzdWx0IC0+XG4gICAgICAgICAgKCogQXMgaW4gdGhlIGNhbGxiYWNrIGFib3ZlLCBidXQgZm9yIGFscmVhZHktcmVzb2x2ZWQgcHJvbWlzZXMgaW5cbiAgICAgICAgICAgICBbcHNdOiByZWplY3QgdGhlIFtqb2luXSB3aXRoIHRoZSBzYW1lIGV4Y2VwdGlvbiBhcyBpbiB0aGUgZmlyc3RcbiAgICAgICAgICAgICByZWplY3RlZCBwcm9taXNlIGZvdW5kLiBbam9pbl0gc3RpbGwgd2FpdHMgZm9yIGFueSBwZW5kaW5nIHByb21pc2VzXG4gICAgICAgICAgICAgYmVmb3JlIGFjdHVhbGx5IHJlc29sdmluZywgdGhvdWdoLiAqKVxuICAgICAgICAgIGJlZ2luIG1hdGNoICFqb2luX3Jlc3VsdCB3aXRoXG4gICAgICAgICAgfCBGdWxmaWxsZWQgKCkgLT4gam9pbl9yZXN1bHQgOj0gcF9yZXN1bHQ7XG4gICAgICAgICAgfCBSZWplY3RlZCBfIC0+ICgpXG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIGF0dGFjaF9jYWxsYmFja19vcl9yZXNvbHZlX2ltbWVkaWF0ZWx5IHBzXG5cbiAgICAgICAgfCBGdWxmaWxsZWQgKCkgLT5cbiAgICAgICAgICBhdHRhY2hfY2FsbGJhY2tfb3JfcmVzb2x2ZV9pbW1lZGlhdGVseSBwc1xuICAgIGluXG5cbiAgICBhdHRhY2hfY2FsbGJhY2tfb3JfcmVzb2x2ZV9pbW1lZGlhdGVseSBwc1xuXG4gICgqIHRoaXMgaXMgMyB3b3Jkcywgc21hbGxlciB0aGFuIHRoZSAyIHRpbWVzIDIgd29yZHMgYSBwYWlyIG9mIHJlZmVyZW5jZXNcbiAgICAgd291bGQgdGFrZS4gKilcbiAgdHlwZSAoJ2EsJ2IpIHBhaXIgPSB7XG4gICAgbXV0YWJsZSB4MTogJ2Egb3B0aW9uO1xuICAgIG11dGFibGUgeDI6ICdiIG9wdGlvbjtcbiAgfVxuXG4gIGxldCBib3RoIHAxIHAyID1cbiAgICBsZXQgcGFpciA9IHt4MSA9IE5vbmU7IHgyID0gTm9uZX0gaW5cbiAgICBsZXQgcDEnID0gYmluZCBwMSAoZnVuIHYgLT4gcGFpci54MSA8LSBTb21lIHY7IHJldHVybl91bml0KSBpblxuICAgIGxldCBwMicgPSBiaW5kIHAyIChmdW4gdiAtPiBwYWlyLngyIDwtIFNvbWUgdjsgcmV0dXJuX3VuaXQpIGluXG4gICAgam9pbiBbcDEnOyBwMiddIHw+IG1hcCAoZnVuICgpIC0+XG4gICAgICBtYXRjaCBwYWlyLngxLCBwYWlyLngyIHdpdGhcbiAgICAgIHwgU29tZSB2MSwgU29tZSB2MiAtPiB2MSwgdjJcbiAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG5cbiAgbGV0IGFsbCBwcyA9XG4gICAgbWF0Y2ggcHMgd2l0aFxuICAgIHwgW10gLT4gcmV0dXJuX25pbFxuICAgIHwgW3hdIC0+IG1hcCAoZnVuIHkgLT4gW3ldKSB4XG4gICAgfCBbeDsgeV0gLT4gbWFwIChmdW4gKHgsIHkpIC0+IFt4OyB5XSkgKGJvdGggeCB5KVxuICAgIHwgXyAtPlxuICAgICAgbGV0IHZzID0gQXJyYXkubWFrZSAoTGlzdC5sZW5ndGggcHMpIE5vbmUgaW5cbiAgICAgIHBzXG4gICAgICB8PiBMaXN0Lm1hcGkgKGZ1biBpbmRleCBwIC0+XG4gICAgICAgIGJpbmQgcCAoZnVuIHYgLT4gdnMuKGluZGV4KSA8LSBTb21lIHY7IHJldHVybl91bml0KSlcbiAgICAgIHw+IGpvaW5cbiAgICAgIHw+IG1hcCAoZnVuICgpIC0+XG4gICAgICAgICAgbGV0IHJlYyB0b19saXN0X3Vub3B0IGkgYWNjID1cbiAgICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgICAgYWNjXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIEFycmF5LnVuc2FmZV9nZXQgdnMgaSB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgICAgfCBTb21lIHggLT4gdG9fbGlzdF91bm9wdCAoaSAtIDEpICh4OjphY2MpXG4gICAgICAgICAgaW5cbiAgICAgICAgICB0b19saXN0X3Vub3B0IChBcnJheS5sZW5ndGggdnMgLSAxKSBbXSlcblxuICAoKiBNYWludGFpbmVyJ3Mgbm90ZTogdGhlIG5leHQgZmV3IGZ1bmN0aW9ucyBhcmUgaGVscGVycyBmb3IgW2Nob29zZV0gYW5kXG4gICAgIFtwaWNrXS4gUGVyaGFwcyB0aGV5IHNob3VsZCBiZSBmYWN0b3JlZCBpbnRvIHNvbWUga2luZCBvZiBnZW5lcmljXG4gICAgIFtjaG9vc2VdL1twaWNrXSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggbWF5IGFjdHVhbGx5IGJlIG9wdGltYWwgYW55d2F5IHdpdGhcbiAgICAgRmxhbWJkYS4gKilcblxuICBsZXQgY291bnRfcmVzb2x2ZWRfcHJvbWlzZXNfaW4gKHBzIDogJ2EgdCBsaXN0KSA9XG4gICAgbGV0IHJlYyBjb3VudF9hbmRfZ2F0aGVyX3JlamVjdGVkIHRvdGFsIHJlamVjdGVkIHBzID1cbiAgICAgICBtYXRjaCBwcyB3aXRoXG4gICAgICAgfCBbXSAtPiBFcnJvciAodG90YWwsIHJlamVjdGVkKVxuICAgICAgIHwgcCA6OiBwcyAtPlxuICAgICAgICAgICAgbGV0IEludGVybmFsIHEgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHEpLnN0YXRlIHdpdGhcbiAgICAgICAgICAgIHwgRnVsZmlsbGVkIF8gLT4gY291bnRfYW5kX2dhdGhlcl9yZWplY3RlZCB0b3RhbCByZWplY3RlZCBwc1xuICAgICAgICAgICAgfCBSZWplY3RlZCBfIC0+IGNvdW50X2FuZF9nYXRoZXJfcmVqZWN0ZWQgKHRvdGFsICsgMSkgKHAgOjogcmVqZWN0ZWQpIHBzXG4gICAgICAgICAgICB8IFBlbmRpbmcgXyAtPiBjb3VudF9hbmRfZ2F0aGVyX3JlamVjdGVkIHRvdGFsIHJlamVjdGVkIHBzXG4gICAgaW5cbiAgICBsZXQgcmVjIGNvdW50X2Z1bGZpbGxlZCB0b3RhbCBwcyA9XG4gICAgICAgbWF0Y2ggcHMgd2l0aFxuICAgICAgIHwgW10gLT4gT2sgdG90YWxcbiAgICAgICB8IHAgOjogcHMgLT5cbiAgICAgICAgICAgIGxldCBJbnRlcm5hbCBxID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgICAgICBtYXRjaCAodW5kZXJseWluZyBxKS5zdGF0ZSB3aXRoXG4gICAgICAgICAgICB8IEZ1bGZpbGxlZCBfIC0+IGNvdW50X2Z1bGZpbGxlZCAodG90YWwgKyAxKSBwc1xuICAgICAgICAgICAgfCBSZWplY3RlZCBfIC0+IGNvdW50X2FuZF9nYXRoZXJfcmVqZWN0ZWQgMSBbcF0gcHNcbiAgICAgICAgICAgIHwgUGVuZGluZyBfIC0+IGNvdW50X2Z1bGZpbGxlZCB0b3RhbCBwc1xuICAgIGluXG4gICAgY291bnRfZnVsZmlsbGVkIDAgcHNcblxuICAoKiBFdmFsdWF0ZXMgdG8gdGhlIFtuXXRoIHByb21pc2UgaW4gW3BzXSwgYW1vbmcgb25seSB0aG9zZSBwcm9taXNlcyBpbiBbcHNdXG4gICAgIHRoYXQgYXJlIHJlc29sdmVkLiBUaGUgY2FsbGVyIGlzIGV4cGVjdGVkIHRvIGVuc3VyZSB0aGF0IHRoZXJlIGFyZSBhdFxuICAgICBsZWFzdCBbbl0gcmVzb2x2ZWQgcHJvbWlzZXMgaW4gW3BzXS4gKilcbiAgbGV0IHJlYyBudGhfcmVzb2x2ZWQgKHBzIDogJ2EgdCBsaXN0KSAobiA6IGludCkgOiAnYSB0ID1cbiAgICBtYXRjaCBwcyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgYXNzZXJ0IGZhbHNlXG5cbiAgICB8IHA6OnBzIC0+XG4gICAgICBsZXQgSW50ZXJuYWwgcCcgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHAnKS5zdGF0ZSB3aXRoXG4gICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICBudGhfcmVzb2x2ZWQgcHMgblxuXG4gICAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAgIGlmIG4gPD0gMCB0aGVuIHBcbiAgICAgICAgZWxzZSBudGhfcmVzb2x2ZWQgcHMgKG4gLSAxKVxuICAgICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICAgIGlmIG4gPD0gMCB0aGVuIHBcbiAgICAgICAgZWxzZSBudGhfcmVzb2x2ZWQgcHMgKG4gLSAxKVxuXG4gICgqIExpa2UgW250aF9yZXNvbHZlZF0sIGJ1dCBjYW5jZWxzIGFsbCBwZW5kaW5nIHByb21pc2VzIGZvdW5kIHdoaWxlXG4gICAgIHRyYXZlcnNpbmcgW3BzXS4gKilcbiAgbGV0IHJlYyBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIChwcyA6ICdhIHQgbGlzdCkgKG4gOiBpbnQpIDogJ2EgdCA9XG4gICAgbWF0Y2ggcHMgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIGFzc2VydCBmYWxzZVxuXG4gICAgfCBwOjpwcyAtPlxuICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICBtYXRjaCAodW5kZXJseWluZyBwJykuc3RhdGUgd2l0aFxuICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgY2FuY2VsIHA7XG4gICAgICAgIG50aF9yZXNvbHZlZF9hbmRfY2FuY2VsX3BlbmRpbmcgcHMgblxuXG4gICAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAgIGlmIG4gPD0gMCB0aGVuIChMaXN0Lml0ZXIgY2FuY2VsIHBzOyBwKVxuICAgICAgICBlbHNlIG50aF9yZXNvbHZlZF9hbmRfY2FuY2VsX3BlbmRpbmcgcHMgKG4gLSAxKVxuICAgICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICAgIGlmIG4gPD0gMCB0aGVuIChMaXN0Lml0ZXIgY2FuY2VsIHBzOyBwKVxuICAgICAgICBlbHNlIG50aF9yZXNvbHZlZF9hbmRfY2FuY2VsX3BlbmRpbmcgcHMgKG4gLSAxKVxuXG4gICgqIFRoZSBQUk5HIHN0YXRlIGlzIGluaXRpYWxpemVkIHdpdGggYSBjb25zdGFudCB0byBtYWtlIG5vbi1JTy1iYXNlZCBwcm9ncmFtc1xuICAgICBkZXRlcm1pbmlzdGljLiAqKVxuICAoKiBNYWludGFpbmVyJ3Mgbm90ZTogaXMgdGhpcyBuZWNlc3Nhcnk/ICopXG4gIGxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2UgW3x8XSlcblxuICBsZXQgY2hvb3NlIHBzID1cbiAgICBpZiBwcyA9IFtdIHRoZW5cbiAgICAgIGludmFsaWRfYXJnXG4gICAgICAgIFwiTHd0LmNob29zZSBbXSB3b3VsZCByZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXCI7XG4gICAgbWF0Y2ggY291bnRfcmVzb2x2ZWRfcHJvbWlzZXNfaW4gcHMgd2l0aFxuICAgIHwgT2sgMCAtPlxuICAgICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDoocHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIHBzKSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcmVzdWx0ID1cbiAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluXG4gICAgICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG4gICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPVxuICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwIHJlc3VsdCBpblxuICAgICAgICBpZ25vcmUgcFxuICAgICAgaW5cbiAgICAgIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja190b19lYWNoX29mIHBzIGNhbGxiYWNrO1xuXG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgICB8IE9rIDEgLT5cbiAgICAgIG50aF9yZXNvbHZlZCBwcyAwXG5cbiAgICB8IE9rIG4gLT5cbiAgICAgIG50aF9yZXNvbHZlZCBwcyAoUmFuZG9tLlN0YXRlLmludCAoTGF6eS5mb3JjZSBwcm5nKSBuKVxuXG4gICAgfCBFcnJvciAobiwgcHMpIC0+XG4gICAgICBudGhfcmVzb2x2ZWQgcHMgKFJhbmRvbS5TdGF0ZS5pbnQgKExhenkuZm9yY2UgcHJuZykgbilcblxuICBsZXQgcGljayBwcyA9XG4gICAgaWYgcHMgPSBbXSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkx3dC5waWNrIFtdIHdvdWxkIHJldHVybiBhIHByb21pc2UgdGhhdCBpcyBwZW5kaW5nIGZvcmV2ZXJcIjtcbiAgICBtYXRjaCBjb3VudF9yZXNvbHZlZF9wcm9taXNlc19pbiBwcyB3aXRoXG4gICAgfCBPayAwIC0+XG4gICAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMpIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayByZXN1bHQgPVxuICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAgPSBtYXlfbm93X2JlX3Byb3h5IHAgaW5cbiAgICAgICAgTGlzdC5pdGVyIGNhbmNlbCBwcztcbiAgICAgICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cbiAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9XG4gICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAgcmVzdWx0IGluXG4gICAgICAgIGlnbm9yZSBwXG4gICAgICBpblxuICAgICAgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX3RvX2VhY2hfb2YgcHMgY2FsbGJhY2s7XG5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICAgIHwgT2sgMSAtPlxuICAgICAgbnRoX3Jlc29sdmVkX2FuZF9jYW5jZWxfcGVuZGluZyBwcyAwXG5cbiAgICB8IE9rIG4gLT5cbiAgICAgIG50aF9yZXNvbHZlZF9hbmRfY2FuY2VsX3BlbmRpbmcgcHNcbiAgICAgICAgKFJhbmRvbS5TdGF0ZS5pbnQgKExhenkuZm9yY2UgcHJuZykgbilcblxuICAgIHwgRXJyb3IgKG4sIHFzKSAtPlxuICAgICAgTGlzdC5pdGVyIGNhbmNlbCBwcztcbiAgICAgIG50aF9yZXNvbHZlZCBxcyAoUmFuZG9tLlN0YXRlLmludCAoTGF6eS5mb3JjZSBwcm5nKSBuKVxuXG5cblxuICAoKiBJZiBbbmNob29zZSBwc10gb3IgW25waWNrIHBzXSBmb3VuZCBhbGwgcHJvbWlzZXMgaW4gW3BzXSBwZW5kaW5nLCB0aGVcbiAgICAgY2FsbGJhY2sgYWRkZWQgdG8gZWFjaCBwcm9taXNlIGluIFtwc10gZXZlbnR1YWxseSBjYWxscyB0aGlzIGZ1bmN0aW9uLiBUaGVcbiAgICAgZnVuY3Rpb24gY29sbGVjdHMgcHJvbWlzZXMgaW4gW3BzXSB0aGF0IGhhdmUgYmVjb21lIGZ1bGZpbGxlZCwgb3IgZmluZHMgb25lXG4gICAgIHByb21pc2UgaW4gW3BzXSB0aGF0IGhhcyBiZWVuIHJlamVjdGVkLiBJdCB0aGVuIHJldHVybnMgdGhlIGRlc2lyZWQgc3RhdGVcbiAgICAgb2YgdGhlIGZpbmFsIHByb21pc2U6IGVpdGhlciB0aGUgbGlzdCBvZiByZXN1bHRzIGNvbGxlY3RlZCwgb3IgdGhlXG4gICAgIGV4Y2VwdGlvbiBmb3VuZC4gKilcbiAgbGV0IHJlYyBjb2xsZWN0X2Z1bGZpbGxlZF9wcm9taXNlc19hZnRlcl9wZW5kaW5nXG4gICAgICAocmVzdWx0cyA6ICdhIGxpc3QpXG4gICAgICAocHMgOiAnYSB0IGxpc3QpIDpcbiAgICAgICAgKCdhIGxpc3QgcmVzb2x2ZWRfc3RhdGUpID1cblxuICAgIG1hdGNoIHBzIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBGdWxmaWxsZWQgKExpc3QucmV2IHJlc3VsdHMpXG5cbiAgICB8IHA6OnBzIC0+XG4gICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuXG4gICAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgIGNvbGxlY3RfZnVsZmlsbGVkX3Byb21pc2VzX2FmdGVyX3BlbmRpbmcgKHY6OnJlc3VsdHMpIHBzXG5cbiAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgcmVzdWx0XG5cbiAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgIGNvbGxlY3RfZnVsZmlsbGVkX3Byb21pc2VzX2FmdGVyX3BlbmRpbmcgcmVzdWx0cyBwc1xuXG4gIGxldCBuY2hvb3NlIHBzID1cbiAgICAoKiBJZiBhdCBsZWFzdCBvbmUgcHJvbWlzZSBpbiBbcHNdIGlzIGZvdW5kIGZ1bGZpbGxlZCwgdGhpcyBmdW5jdGlvbiBpc1xuICAgICAgIGNhbGxlZCB0byBmaW5kIGFsbCBzdWNoIHByb21pc2VzLiAqKVxuICAgIGlmIHBzID0gW10gdGhlblxuICAgICAgaW52YWxpZF9hcmdcbiAgICAgICAgXCJMd3QubmNob29zZSBbXSB3b3VsZCByZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXCI7XG4gICAgbGV0IHJlYyBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgYWNjIHBzID1cbiAgICAgIG1hdGNoIHBzIHdpdGhcbiAgICAgIHwgW10gLT5cbiAgICAgICAgcmV0dXJuIChMaXN0LnJldiBhY2MpXG5cbiAgICAgIHwgcDo6cHMgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkICh2OjphY2MpIHBzXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCBhY2MgcHNcbiAgICBpblxuXG4gICAgKCogTG9va3MgZm9yIGFscmVhZHktcmVzb2x2ZWQgcHJvbWlzZXMgaW4gW3BzXS4gSWYgbm9uZSBhcmUgZnVsZmlsbGVkIG9yXG4gICAgICAgcmVqZWN0ZWQsIGFkZHMgYSBjYWxsYmFjayB0byBhbGwgcHJvbWlzZXMgaW4gW3BzXSAoYWxsIG9mIHdoaWNoIGFyZVxuICAgICAgIHBlbmRpbmcpLiAqKVxuICAgIGxldCByZWMgY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcHMnID1cbiAgICAgIG1hdGNoIHBzJyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgICAgICBsZXQgY2FsbGJhY2sgX3Jlc3VsdCA9XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluXG4gICAgICAgICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cbiAgICAgICAgICBsZXQgcmVzdWx0ID0gY29sbGVjdF9mdWxmaWxsZWRfcHJvbWlzZXNfYWZ0ZXJfcGVuZGluZyBbXSBwcyBpblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPVxuICAgICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAgcmVzdWx0IGluXG4gICAgICAgICAgaWdub3JlIHBcbiAgICAgICAgaW5cbiAgICAgICAgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX3RvX2VhY2hfb2YgcHMgY2FsbGJhY2s7XG5cbiAgICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgICB8IHA6OnBzIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCBbdl0gcHNcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgICAgY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcHNcbiAgICBpblxuXG4gICAgbGV0IHAgPSBjaGVja19mb3JfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyBwcyBpblxuICAgIHBcblxuICAoKiBTZWUgW25jaG9vc2VdLiBUaGlzIGZ1bmN0aW9uIGRpZmZlcnMgb25seSBpbiBoYXZpbmcgYWRkaXRpb25hbCBjYWxscyB0b1xuICAgICBbY2FuY2VsXS4gKilcbiAgbGV0IG5waWNrIHBzID1cbiAgICBpZiBwcyA9IFtdIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiTHd0Lm5waWNrIFtdIHdvdWxkIHJldHVybiBhIHByb21pc2UgdGhhdCBpcyBwZW5kaW5nIGZvcmV2ZXJcIjtcbiAgICBsZXQgcmVjIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCBhY2MgcHMnID1cbiAgICAgIG1hdGNoIHBzJyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIExpc3QuaXRlciBjYW5jZWwgcHM7XG4gICAgICAgIHJldHVybiAoTGlzdC5yZXYgYWNjKVxuXG4gICAgICB8IHA6OnBzJyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgKHY6OmFjYykgcHMnXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIExpc3QuaXRlciBjYW5jZWwgcHM7XG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkIGFjYyBwcydcbiAgICBpblxuXG4gICAgbGV0IHJlYyBjaGVja19mb3JfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyBwcycgPVxuICAgICAgbWF0Y2ggcHMnIHdpdGhcbiAgICAgIHwgW10gLT5cbiAgICAgICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDoocHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIHBzKSBpblxuXG4gICAgICAgIGxldCBjYWxsYmFjayBfcmVzdWx0ID1cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAgPSBtYXlfbm93X2JlX3Byb3h5IHAgaW5cbiAgICAgICAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuICAgICAgICAgIGxldCByZXN1bHQgPSBjb2xsZWN0X2Z1bGZpbGxlZF9wcm9taXNlc19hZnRlcl9wZW5kaW5nIFtdIHBzIGluXG4gICAgICAgICAgTGlzdC5pdGVyIGNhbmNlbCBwcztcbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwIHJlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwXG4gICAgICAgIGluXG4gICAgICAgIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja190b19lYWNoX29mIHBzIGNhbGxiYWNrO1xuXG4gICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICAgICAgfCBwOjpwcycgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkIFt2XSBwcydcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgICAgTGlzdC5pdGVyIGNhbmNlbCBwcztcbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgICBjaGVja19mb3JfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyBwcydcbiAgICBpblxuXG4gICAgbGV0IHAgPSBjaGVja19mb3JfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyBwcyBpblxuICAgIHBcblxuXG5cbiAgKCogU2FtZSBnZW5lcmFsIHBhdHRlcm4gYXMgW25waWNrXSBhbmQgW25jaG9vc2VdLiAqKVxuICBsZXQgbmNob29zZV9zcGxpdCBwcyA9XG4gICAgaWYgcHMgPSBbXSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ1xuICAgICAgICBcIkx3dC5uY2hvb3NlX3NwbGl0IFtdIHdvdWxkIHJldHVybiBhIHByb21pc2UgdGhhdCBpcyBwZW5kaW5nIGZvcmV2ZXJcIjtcbiAgICBsZXQgcmVjIGZpbmlzaFxuICAgICAgICAodG9fcmVzb2x2ZSA6ICgnYSBsaXN0ICogJ2EgdCBsaXN0LCB1bmRlcmx5aW5nLCBwZW5kaW5nKSBwcm9taXNlKVxuICAgICAgICAoZnVsZmlsbGVkIDogJ2EgbGlzdClcbiAgICAgICAgKHBlbmRpbmcgOiAnYSB0IGxpc3QpXG4gICAgICAgIChwcyA6ICdhIHQgbGlzdClcbiAgICAgICAgICA6ICgnYSBsaXN0ICogJ2EgdCBsaXN0LCB1bmRlcmx5aW5nLCByZXNvbHZlZCkgc3RhdGVfY2hhbmdlZCA9XG5cbiAgICAgIG1hdGNoIHBzIHdpdGhcbiAgICAgIHwgW10gLT5cbiAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHRvX3Jlc29sdmVcbiAgICAgICAgICAoRnVsZmlsbGVkIChMaXN0LnJldiBmdWxmaWxsZWQsIExpc3QucmV2IHBlbmRpbmcpKVxuXG4gICAgICB8IHA6OnBzIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwX2ludGVybmFsID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHBfaW50ZXJuYWwpLnN0YXRlIHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGZpbmlzaCB0b19yZXNvbHZlICh2OjpmdWxmaWxsZWQpIHBlbmRpbmcgcHNcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHRvX3Jlc29sdmUgcmVzdWx0XG5cbiAgICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgICBmaW5pc2ggdG9fcmVzb2x2ZSBmdWxmaWxsZWQgKHA6OnBlbmRpbmcpIHBzXG4gICAgaW5cblxuICAgIGxldCByZWMgY29sbGVjdF9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHJlc3VsdHMgcGVuZGluZyBwcyA9XG4gICAgICBtYXRjaCBwcyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgICgqIE1haW50YWluZXIncyBub3RlOiBzaG91bGQgdGhlIHBlbmRpbmcgcHJvbWlzZSBsaXN0IGFsc28gYmVcbiAgICAgICAgICAgcmV2ZXJzZWQ/IEl0IGlzIHJldmVyc2VkIGluIGZpbmlzaC4gKilcbiAgICAgICAgcmV0dXJuIChMaXN0LnJldiByZXN1bHRzLCBwZW5kaW5nKVxuXG4gICAgICB8IHA6OnBzIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwX2ludGVybmFsID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHBfaW50ZXJuYWwpLnN0YXRlIHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyAodjo6cmVzdWx0cykgcGVuZGluZyBwc1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcmVzdWx0cyAocDo6cGVuZGluZykgcHNcbiAgICBpblxuXG4gICAgbGV0IHJlYyBjaGVja19mb3JfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyBwZW5kaW5nX2FjYyBwcycgPVxuICAgICAgbWF0Y2ggcHMnIHdpdGhcbiAgICAgIHwgW10gLT5cbiAgICAgICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDoocHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIHBzKSBpblxuXG4gICAgICAgIGxldCBjYWxsYmFjayBfcmVzdWx0ID1cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAgPSBtYXlfbm93X2JlX3Byb3h5IHAgaW5cbiAgICAgICAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPSBmaW5pc2ggcCBbXSBbXSBwcyBpblxuICAgICAgICAgIGlnbm9yZSBwXG4gICAgICAgIGluXG4gICAgICAgIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja190b19lYWNoX29mIHBzIGNhbGxiYWNrO1xuXG4gICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICAgICAgfCBwOjpwcycgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHBfaW50ZXJuYWwgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcF9pbnRlcm5hbCkuc3RhdGUgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIFt2XSBwZW5kaW5nX2FjYyBwcydcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgICAgY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgKHA6OnBlbmRpbmdfYWNjKSBwcydcbiAgICBpblxuXG4gICAgbGV0IHAgPSBjaGVja19mb3JfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyBbXSBwcyBpblxuICAgIHBcbmVuZFxuaW5jbHVkZSBDb25jdXJyZW50X2NvbXBvc2l0aW9uXG5cblxuXG5tb2R1bGUgTWlzY2VsbGFuZW91cyA6XG5zaWdcbiAgKCogUHJvbWlzZSBzdGF0ZSBxdWVyeSAqKVxuICB0eXBlICdhIHN0YXRlID1cbiAgICB8IFJldHVybiBvZiAnYVxuICAgIHwgRmFpbCBvZiBleG5cbiAgICB8IFNsZWVwXG5cbiAgdmFsIHN0YXRlIDogJ2EgdCAtPiAnYSBzdGF0ZVxuICB2YWwgaXNfc2xlZXBpbmcgOiAnYSB0IC0+IGJvb2xcbiAgdmFsIGRlYnVnX3N0YXRlX2lzIDogJ2Egc3RhdGUgLT4gJ2EgdCAtPiBib29sIHRcblxuICAoKiBGdW5jdGlvbiBsaWZ0ZXJzICopXG4gIHZhbCBhcHBseSA6ICgnYSAtPiAnYiB0KSAtPiAnYSAtPiAnYiB0XG5cbiAgdmFsIHdyYXAgOlxuICAgICh1bml0IC0+ICdiKSAtPlxuICAgICdiIHRcbiAgdmFsIHdyYXAxIDpcbiAgICAoJ2ExIC0+ICdiKSAtPlxuICAgICgnYTEgLT4gJ2IgdClcbiAgdmFsIHdyYXAyIDpcbiAgICAoJ2ExIC0+ICdhMiAtPiAnYikgLT5cbiAgICAoJ2ExIC0+ICdhMiAtPiAnYiB0KVxuICB2YWwgd3JhcDMgOlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYikgLT5cbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2IgdClcbiAgdmFsIHdyYXA0IDpcbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdiKSAtPlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2IgdClcbiAgdmFsIHdyYXA1IDpcbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYikgLT5cbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYiB0KVxuICB2YWwgd3JhcDYgOlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdhNiAtPiAnYikgLT5cbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2IgdClcbiAgdmFsIHdyYXA3IDpcbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2E3IC0+ICdiKSAtPlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdhNiAtPiAnYTcgLT4gJ2IgdClcblxuICAoKiBQYXVzZWQgcHJvbWlzZXMgKilcbiAgdmFsIHBhdXNlIDogdW5pdCAtPiB1bml0IHRcbiAgdmFsIHdha2V1cF9wYXVzZWQgOiB1bml0IC0+IHVuaXRcbiAgdmFsIHBhdXNlZF9jb3VudCA6IHVuaXQgLT4gaW50XG4gIHZhbCByZWdpc3Rlcl9wYXVzZV9ub3RpZmllciA6IChpbnQgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgYWJhbmRvbl9wYXVzZWQgOiB1bml0IC0+IHVuaXRcblxuICAoKiBJbnRlcm5hbCBpbnRlcmZhY2UgZm9yIG90aGVyIG1vZHVsZXMgaW4gTHd0ICopXG4gIHZhbCBwb2xsIDogJ2EgdCAtPiAnYSBvcHRpb25cbmVuZCA9XG5zdHJ1Y3RcbiAgdHlwZSAnYSBzdGF0ZSA9XG4gICAgfCBSZXR1cm4gb2YgJ2FcbiAgICB8IEZhaWwgb2YgZXhuXG4gICAgfCBTbGVlcFxuXG4gIGV4dGVybmFsIHJlcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyZXJhaXNlXCJcblxuICBsZXQgc3RhdGUgcCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgdiAtPiBSZXR1cm4gdlxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+IEZhaWwgZXhuXG4gICAgfCBQZW5kaW5nIF8gLT4gU2xlZXBcblxuICBsZXQgZGVidWdfc3RhdGVfaXMgZXhwZWN0ZWRfc3RhdGUgcCA9XG4gICAgcmV0dXJuIChzdGF0ZSBwID0gZXhwZWN0ZWRfc3RhdGUpXG5cbiAgbGV0IGlzX3NsZWVwaW5nIHAgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT4gZmFsc2VcbiAgICB8IFJlamVjdGVkIF8gLT4gZmFsc2VcbiAgICB8IFBlbmRpbmcgXyAtPiB0cnVlXG5cbiAgbGV0IHBvbGwgcCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgfCBSZWplY3RlZCBlIC0+IHJlcmFpc2UgZVxuICAgIHwgRnVsZmlsbGVkIHYgLT4gU29tZSB2XG4gICAgfCBQZW5kaW5nIF8gLT4gTm9uZVxuXG5cblxuICBsZXQgYXBwbHkgZiB4ID1cbiAgICB0cnkgZiB4IHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXAgZiA9XG4gICAgdHJ5IHJldHVybiAoZiAoKSlcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwMSBmIHgxID1cbiAgICB0cnkgcmV0dXJuIChmIHgxKVxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXAyIGYgeDEgeDIgPVxuICAgIHRyeSByZXR1cm4gKGYgeDEgeDIpXG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDMgZiB4MSB4MiB4MyA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSB4MiB4MylcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwNCBmIHgxIHgyIHgzIHg0ID1cbiAgICB0cnkgcmV0dXJuIChmIHgxIHgyIHgzIHg0KVxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXA1IGYgeDEgeDIgeDMgeDQgeDUgPVxuICAgIHRyeSByZXR1cm4gKGYgeDEgeDIgeDMgeDQgeDUpXG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDYgZiB4MSB4MiB4MyB4NCB4NSB4NiA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSB4MiB4MyB4NCB4NSB4NilcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwNyBmIHgxIHgyIHgzIHg0IHg1IHg2IHg3ID1cbiAgICB0cnkgcmV0dXJuIChmIHgxIHgyIHgzIHg0IHg1IHg2IHg3KVxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG5cblxuXG4gIGxldCBwYXVzZV9ob29rID0gcmVmIGlnbm9yZVxuXG4gIGxldCBwYXVzZWQgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpXG4gIGxldCBwYXVzZWRfY291bnQgPSByZWYgMFxuXG4gIGxldCBwYXVzZSAoKSA9XG4gICAgbGV0IHAgPSBhZGRfdGFza19yIHBhdXNlZCBpblxuICAgIGluY3IgcGF1c2VkX2NvdW50O1xuICAgICFwYXVzZV9ob29rICFwYXVzZWRfY291bnQ7XG4gICAgcFxuXG4gIGxldCB3YWtldXBfcGF1c2VkICgpID1cbiAgICBpZiBMd3Rfc2VxdWVuY2UuaXNfZW1wdHkgcGF1c2VkIHRoZW5cbiAgICAgIHBhdXNlZF9jb3VudCA6PSAwXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHRtcCA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCkgaW5cbiAgICAgIEx3dF9zZXF1ZW5jZS50cmFuc2Zlcl9yIHBhdXNlZCB0bXA7XG4gICAgICBwYXVzZWRfY291bnQgOj0gMDtcbiAgICAgIEx3dF9zZXF1ZW5jZS5pdGVyX2wgKGZ1biByIC0+IHdha2V1cCByICgpKSB0bXBcbiAgICBlbmRcblxuICBsZXQgcmVnaXN0ZXJfcGF1c2Vfbm90aWZpZXIgZiA9IHBhdXNlX2hvb2sgOj0gZlxuXG4gIGxldCBhYmFuZG9uX3BhdXNlZCAoKSA9XG4gICAgTHd0X3NlcXVlbmNlLmNsZWFyIHBhdXNlZDtcbiAgICBwYXVzZWRfY291bnQgOj0gMFxuXG4gIGxldCBwYXVzZWRfY291bnQgKCkgPSAhcGF1c2VkX2NvdW50XG5lbmRcbmluY2x1ZGUgTWlzY2VsbGFuZW91c1xuXG5tb2R1bGUgTGV0X3N5bnRheCA9XG5zdHJ1Y3RcbiAgbW9kdWxlIExldF9zeW50YXggPVxuICBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IG1hcCB0IH5mID0gbWFwIGYgdFxuICAgIGxldCBiaW5kIHQgfmYgPSBiaW5kIHQgZlxuICAgIGxldCBib3RoID0gYm90aFxuXG4gICAgbW9kdWxlIE9wZW5fb25fcmhzID1cbiAgICBzdHJ1Y3RcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIEluZml4ID1cbnN0cnVjdFxuICBsZXQgKD4+PSkgPSBiaW5kXG4gIGxldCAoPTw8KSBmIHAgPSBiaW5kIHAgZlxuICBsZXQgKD58PSkgcCBmID0gbWFwIGYgcFxuICBsZXQgKD18PCkgPSBtYXBcbiAgbGV0ICg8Jj4pIHAgcCcgPSBqb2luIFtwOyBwJ11cbiAgbGV0ICg8Pz4pIHAgcCcgPSBjaG9vc2UgW3A7IHAnXVxuXG4gIGluY2x1ZGUgTGV0X3N5bnRheFxuZW5kXG5pbmNsdWRlICggSW5maXggOiBtb2R1bGUgdHlwZSBvZiBJbmZpeCB3aXRoIG1vZHVsZSBMZXRfc3ludGF4IDo9IExldF9zeW50YXguTGV0X3N5bnRheCApXG5cbm1vZHVsZSBTeW50YXggPVxuc3RydWN0XG4gIGxldCAobGV0KikgPSBiaW5kXG4gIGxldCAoYW5kKikgPSBib3RoXG5cbiAgbGV0IChsZXQrKSB4IGYgPSBtYXAgZiB4XG4gIGxldCAoYW5kKykgPSBib3RoXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMzc3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Imx3dC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiTHd0IiwiU3RkbGliX0xpc3QiLCJPZmYiLCJjcmVhdGUiLCJwYXJhbSIsImlzX29uIiwic3dpdGNoIiwiY2hlY2siLCJhZGRfaG9vayIsImhvb2siLCJtYXRjaCIsIm9zIiwiYWRkX2hvb2tfb3JfZXhlYyIsInR1cm5fb2ZmIiwiaG9va3MiLCJ3aXRoX3N3aXRjaCIsImZuIiwiTHd0X3N3aXRjaCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvanNlby8ub3BhbS80LjEzLjEvbGliL2x3dC9sd3Rfc3dpdGNoLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxZQUFBQyxPQUFBQyxPQ2lCZ0Isd0JBQWdDO0FBQUEsWUFBQUMsTUFBQUMsVUFHOUMsMEJBRWlCO0FBQUEsWUFBQUMsTUFBQUg7QUFBQUEsSUFFUCwyQkFDa0I7QUFBQSxJQUNPO0FBQUEsR0FBRTtBQUFBLFlBQUFJLFNBQUFGLFVBQUFHO0FBQUFBLElBR3JDLGVBTUU7QUFBQSxRQUFBQyxRQU5GO0FBQUEsZ0JBSUU7QUFBQSxRQUFBQyxLQUpGO0FBQUEsSUFFRTtBQUFBO0FBQUEsR0FJRTtBQUFBLFlBQUFDLGlCQUFBTixVQUFBRztBQUFBQSxJQUdKLGVBT0U7QUFBQSxRQUFBQyxRQVBGO0FBQUEsZ0JBS0UsMEJBRWU7QUFBQSxRQUFBQyxLQVBqQjtBQUFBLElBRUU7QUFBQSxJQUNBO0FBQUEsR0FJZTtBQUFBLFlBQUFFLFNBQUFQO0FBQUFBLFFBQUEsTUFHakI7QUFBQSxjQUtFO0FBQUEsUUFBQVEsUUFMRjtBQUFBLElBRUU7QUFBQTtBQUFBO0FBQUEsT0FDUztBQUFBO0FBQUEsa0JBQUFMLE1BQXVCLG1DQUFpQjtBQUFBO0FBQUEsSUFBUSwrQkFFMUM7QUFBQTtBQUFBLFlBQUFNLFlBQUFDO0FBQUFBLFFBQUFWLFdBR0o7QUFBQSxJQUNiO0FBQUE7QUFBQSxzQkFBQUYsT0FDYSwrQkFBUztBQUFBLHNCQUFBQSxPQUNULHlCQUFlLEdBQUM7QUFBQTtBQUFBO0FBQUEsSUFBQWE7QUFBQUEsTUQzRC9CIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbmV4Y2VwdGlvbiBPZmZcblxudHlwZSBvbl9zd2l0Y2ggPSB7XG4gIG11dGFibGUgaG9va3MgOiAodW5pdCAtPiB1bml0IEx3dC50KSBsaXN0O1xufVxuXG50eXBlIHN0YXRlID1cbiAgfCBTdF9vbiBvZiBvbl9zd2l0Y2hcbiAgfCBTdF9vZmZcblxudHlwZSB0ID0geyBtdXRhYmxlIHN0YXRlIDogc3RhdGUgfVxuXG5sZXQgY3JlYXRlICgpID0geyBzdGF0ZSA9IFN0X29uIHsgaG9va3MgPSBbXSB9IH1cblxubGV0IGlzX29uIHN3aXRjaCA9XG4gIG1hdGNoIHN3aXRjaC5zdGF0ZSB3aXRoXG4gIHwgU3Rfb24gXyAtPiB0cnVlXG4gIHwgU3Rfb2ZmIC0+IGZhbHNlXG5cbmxldCBjaGVjayA9IGZ1bmN0aW9uXG4gIHwgU29tZXsgc3RhdGUgPSBTdF9vZmYgfSAtPiByYWlzZSBPZmZcbiAgfCBTb21lIHtzdGF0ZSA9IFN0X29uIF99IHwgTm9uZSAtPiAoKVxuXG5sZXQgYWRkX2hvb2sgc3dpdGNoIGhvb2sgPVxuICBtYXRjaCBzd2l0Y2ggd2l0aFxuICB8IFNvbWUgeyBzdGF0ZSA9IFN0X29uIG9zIH0gLT5cbiAgICBvcy5ob29rcyA8LSBob29rIDo6IG9zLmhvb2tzXG4gIHwgU29tZSB7IHN0YXRlID0gU3Rfb2ZmIH0gLT5cbiAgICByYWlzZSBPZmZcbiAgfCBOb25lIC0+XG4gICAgKClcblxubGV0IGFkZF9ob29rX29yX2V4ZWMgc3dpdGNoIGhvb2sgPVxuICBtYXRjaCBzd2l0Y2ggd2l0aFxuICB8IFNvbWUgeyBzdGF0ZSA9IFN0X29uIG9zIH0gLT5cbiAgICBvcy5ob29rcyA8LSBob29rIDo6IG9zLmhvb2tzO1xuICAgIEx3dC5yZXR1cm5fdW5pdFxuICB8IFNvbWUgeyBzdGF0ZSA9IFN0X29mZiB9IC0+XG4gICAgaG9vayAoKVxuICB8IE5vbmUgLT5cbiAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IHR1cm5fb2ZmIHN3aXRjaCA9XG4gIG1hdGNoIHN3aXRjaC5zdGF0ZSB3aXRoXG4gIHwgU3Rfb24geyBob29rcyA9IGhvb2tzIH0gLT5cbiAgICBzd2l0Y2guc3RhdGUgPC0gU3Rfb2ZmO1xuICAgIEx3dC5qb2luIChMaXN0Lm1hcCAoZnVuIGhvb2sgLT4gTHd0LmFwcGx5IGhvb2sgKCkpIGhvb2tzKVxuICB8IFN0X29mZiAtPlxuICAgIEx3dC5yZXR1cm5fdW5pdFxuXG5sZXQgd2l0aF9zd2l0Y2ggZm4gPVxuICBsZXQgc3dpdGNoID0gY3JlYXRlICgpIGluXG4gIEx3dC5maW5hbGl6ZVxuICAgIChmdW4gKCkgLT4gZm4gc3dpdGNoKVxuICAgIChmdW4gKCkgLT4gdHVybl9vZmYgc3dpdGNoKVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NTgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHd0LmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiTHd0IiwiU3RkbGliX0xpc3QiLCJTdGRsaWJfUHJpbnRmIiwiU3RkbGliIiwicmV0dXJuX25pbCIsImVtcHR5IiwicGFyYW0iLCJyZXR1cm4iLCJ4IiwicmV0dXJuX2x3dCIsImNvbnMiLCJ0IiwiY29uc19sd3QiLCJzZXExIiwic2VxMiIsIm5leHQiLCJhcHBlbmQiLCJzZXEiLCJtYXAiLCJtYXBfcyIsInkiLCJmaWx0ZXJfbWFwIiwiZmlsdGVyX21hcF9zIiwib2siLCJmaWx0ZXIiLCJmaWx0ZXJfcyIsImZsYXRfbWFwX2FwcCIsInRhaWwiLCJmbGF0X21hcCIsImZvbGRfbGVmdCIsImFjYyIsImF1eCIsImZvbGRfbGVmdF9zIiwiaXRlciIsIml0ZXJfcyIsIml0ZXJfcCIsInAiLCJpdGVyX24iLCJvcHQiLCJzdGgiLCJtYXhfY29uY3VycmVuY3kiLCJtZXNzYWdlIiwibG9vcCIsInJ1bm5pbmciLCJhdmFpbGFibGUiLCJlbHQiLCJjb21wbGV0ZSIsInVuZm9sZCIsInUiLCJ2YWwiLCJleGMiLCJtYXRjaCIsInVuZm9sZF9sd3QiLCJvZl9saXN0IiwibCIsImgiLCJ0b19saXN0Iiwib2Zfc2VxIiwiZXhuIiwib2Zfc2VxX2x3dCIsIkx3dF9zZXEiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2pzZW8vLm9wYW0vNC4xMy4xL2xpYi9sd3QvbHd0X3NlcS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGFDWWlCO0FBQUE7QUFBQSxNQUFjO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxNQUFBQyxPQUVGLGtCQUFVO0FBQUEsWUFBQUMsU0FBQUMsR0FBQUYs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RHZUVjtBQUFBLEtDNlR5QjtBQUFBLE1BQWdDO0FBQUEsS0FBSjtBQUFBO0FBQUEsSUFOakQsVUFDYTtBQUFBLFFBQUFuQyxPQURiLFFBQUFQLElBQUE7QUFBQSxJQUdHO0FBQUE7QUFBQTtBQUFBLHNCQUFBQTtBQUFBQSx1QkFBQU8sT0FBQSxLQUNXO0FBQUEsY0FDWDtBQUFBLGFBQWMsRUFDbUQ7QUFBQTtBQUFBO0FBQUEsSUFBQTZDO0FBQUFBLE1BalR6QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEWi9CIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbm9wZW4gTHd0LlN5bnRheFxub3BlbiBMd3QuSW5maXhcblxudHlwZSArJ2Egbm9kZSA9IE5pbCB8IENvbnMgb2YgJ2EgKiAnYSB0XG5cbmFuZCAnYSB0ID0gdW5pdCAtPiAnYSBub2RlIEx3dC50XG5cbmxldCByZXR1cm5fbmlsID0gTHd0LnJldHVybiBOaWxcblxubGV0IGVtcHR5IDogJ2EgdCA9IGZ1biAoKSAtPiByZXR1cm5fbmlsXG5cbmxldCByZXR1cm4gKHggOiAnYSkgOiAnYSB0ID0gZnVuICgpIC0+IEx3dC5yZXR1cm4gKENvbnMgKHgsIGVtcHR5KSlcblxubGV0IHJldHVybl9sd3QgKHggOiAnYSBMd3QudCkgOiAnYSB0ID0gZnVuICgpIC0+XG4gICBsZXQrIHggPSB4IGluXG4gICBDb25zICh4LCBlbXB0eSlcblxubGV0IGNvbnMgeCB0ICgpID0gTHd0LnJldHVybiAoQ29ucyAoeCwgdCkpXG5cbmxldCBjb25zX2x3dCB4IHQgKCkgPVxuICAgbGV0KyB4ID0geCBpblxuICAgQ29ucyAoeCwgdClcblxuKCogQSBub3RlIG9uIHJlY3Vyc2luZyB0aHJvdWdoIHRoZSBzZXFzOlxuICAgV2hlbiB0cmF2ZXJzaW5nIGEgc2VxLCB0aGUgZmlyc3QgdGltZSB3ZSBldmFsdWF0ZSBhIHN1c3BlbmRlZCBub2RlIHdlIGFyZVxuICAgb24gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IGJpbmQgKD4+PSkuIEluIHRoYXQgY2FzZSwgd2UgdXNlIGFwcGx5IHRvIGNhcHR1cmVcbiAgIGV4Y2VwdGlvbnMgaW50byBwcm9taXNlIHJlamVjdGlvbi5cblxuICAgVGhpcyBpcyBvbmx5IG5lZWRlZCBvbiB0aGUgZmlyc3QgaXRlcmF0aW9uIGJlY2F1c2Ugd2UgYXJlIHdpdGhpbiBhIGNhbGxiYWNrXG4gICBwYXNzZWQgdG8gTHd0IG9uIHRoZSByaWdodC1oYW5kIHNpZGUgb2YgYSBiaW5kIGFmdGVyIHRoYXQuXG5cbiAgIFRocm91Z2hvdXQgdGhpcyBmaWxlIHdlIHVzZSB0aGUgc2FtZSBjb2RlIHBhdHRlcm4gdG8gYWNoaWV2ZSB0aGlzOiB3ZVxuICAgc2hhZG93IHRoZSByZWN1cnNpdmUgdHJhdmVyc2FsIGZ1bmN0aW9uIHdpdGggYW4gaWRlbnRpY2FsLWJ1dC1mb3ItdGhlLWFwcGx5XG4gICBub24tcmVjdXJzaXZlIGNvcHkuICopXG5cbmxldCByZWMgYXBwZW5kIHNlcTEgc2VxMiAoKSA9XG4gIHNlcTEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHNlcTIgKClcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBMd3QucmV0dXJuIChDb25zICh4LCBhcHBlbmQgbmV4dCBzZXEyKSlcbmxldCBhcHBlbmQgc2VxMSBzZXEyICgpID1cbiAgTHd0LmFwcGx5IHNlcTEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHNlcTIgKClcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBMd3QucmV0dXJuIChDb25zICh4LCBhcHBlbmQgbmV4dCBzZXEyKSlcblxubGV0IHJlYyBtYXAgZiBzZXEgKCkgPVxuICBzZXEgKCkgPnw9IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBsZXQgeCA9IGYgeCBpblxuICAgICAgQ29ucyAoeCwgbWFwIGYgbmV4dClcbmxldCBtYXAgZiBzZXEgKCkgPVxuICBMd3QuYXBwbHkgc2VxICgpID58PSBmdW5jdGlvblxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbGV0IHggPSBmIHggaW5cbiAgICAgIENvbnMgKHgsIG1hcCBmIG5leHQpXG5cbmxldCByZWMgbWFwX3MgZiBzZXEgKCkgPVxuICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbGV0KyB4ID0gZiB4IGluXG4gICAgICBDb25zICh4LCBtYXBfcyBmIG5leHQpXG5sZXQgbWFwX3MgZiBzZXEgKCkgPVxuICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCsgeCA9IGYgeCBpblxuICAgICAgQ29ucyAoeCwgbWFwX3MgZiBuZXh0KVxuXG5sZXQgcmVjIGZpbHRlcl9tYXAgZiBzZXEgKCkgPVxuICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPiAoXG4gICAgICBsZXQgeCA9IGYgeCBpblxuICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICB8IE5vbmUgLT4gZmlsdGVyX21hcCBmIG5leHQgKClcbiAgICAgIHwgU29tZSB5IC0+IEx3dC5yZXR1cm4gKENvbnMgKHksIGZpbHRlcl9tYXAgZiBuZXh0KSApKVxubGV0IGZpbHRlcl9tYXAgZiBzZXEgKCkgPVxuICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gKFxuICAgICAgbGV0IHggPSBmIHggaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBuZXh0ICgpXG4gICAgICB8IFNvbWUgeSAtPiBMd3QucmV0dXJuIChDb25zICh5LCBmaWx0ZXJfbWFwIGYgbmV4dCkgKSlcblxubGV0IHJlYyBmaWx0ZXJfbWFwX3MgZiBzZXEgKCkgPVxuICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPiAoXG4gICAgICBsZXQqIHggPSBmIHggaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXBfcyBmIG5leHQgKClcbiAgICAgIHwgU29tZSB5IC0+IEx3dC5yZXR1cm4gKENvbnMgKHksIGZpbHRlcl9tYXBfcyBmIG5leHQpICkpXG5sZXQgZmlsdGVyX21hcF9zIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+IChcbiAgICAgIGxldCogeCA9IGYgeCBpblxuICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICB8IE5vbmUgLT4gZmlsdGVyX21hcF9zIGYgbmV4dCAoKVxuICAgICAgfCBTb21lIHkgLT4gTHd0LnJldHVybiAoQ29ucyAoeSwgZmlsdGVyX21hcF9zIGYgbmV4dCkgKSlcblxubGV0IHJlYyBmaWx0ZXIgZiBzZXEgKCkgPVxuICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbGV0IG9rID0gZiB4IGluXG4gICAgICBpZiBvayB0aGVuIEx3dC5yZXR1cm4gKENvbnMgKHgsIGZpbHRlciBmIG5leHQpKSBlbHNlIGZpbHRlciBmIG5leHQgKClcbmxldCBmaWx0ZXIgZiBzZXEgKCkgPVxuICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCBvayA9IGYgeCBpblxuICAgICAgaWYgb2sgdGhlbiBMd3QucmV0dXJuIChDb25zICh4LCBmaWx0ZXIgZiBuZXh0KSkgZWxzZSBmaWx0ZXIgZiBuZXh0ICgpXG5cbmxldCByZWMgZmlsdGVyX3MgZiBzZXEgKCkgPVxuICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbGV0KiBvayA9IGYgeCBpblxuICAgICAgaWYgb2sgdGhlbiBMd3QucmV0dXJuIChDb25zICh4LCBmaWx0ZXJfcyBmIG5leHQpKSBlbHNlIGZpbHRlcl9zIGYgbmV4dCAoKVxubGV0IGZpbHRlcl9zIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBsZXQqIG9rID0gZiB4IGluXG4gICAgICBpZiBvayB0aGVuIEx3dC5yZXR1cm4gKENvbnMgKHgsIGZpbHRlcl9zIGYgbmV4dCkpIGVsc2UgZmlsdGVyX3MgZiBuZXh0ICgpXG5cbmxldCByZWMgZmxhdF9tYXAgZiBzZXEgKCkgPVxuICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgZmxhdF9tYXBfYXBwIGYgKGYgeCkgbmV4dCAoKVxuXG4oKiB0aGlzIGlzIFthcHBlbmQgc2VxIChmbGF0X21hcCBmIHRhaWwpXSAqKVxuYW5kIGZsYXRfbWFwX2FwcCBmIHNlcSB0YWlsICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiBmbGF0X21hcCBmIHRhaWwgKClcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBMd3QucmV0dXJuIChDb25zICh4LCBmbGF0X21hcF9hcHAgZiBuZXh0IHRhaWwpKVxuXG5sZXQgZmxhdF9tYXAgZiBzZXEgKCkgPVxuICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGZsYXRfbWFwX2FwcCBmIChmIHgpIG5leHQgKClcblxubGV0IGZvbGRfbGVmdCBmIGFjYyBzZXEgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyBzZXEgPVxuICAgIHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiBMd3QucmV0dXJuIGFjY1xuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0IGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgYXV4IGYgYWNjIG5leHRcbiAgaW5cbiAgbGV0IGF1eCBmIGFjYyBzZXEgPVxuICAgIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LnJldHVybiBhY2NcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGF1eCBmIGFjYyBuZXh0XG4gIGluXG4gIGF1eCBmIGFjYyBzZXFcblxubGV0IGZvbGRfbGVmdF9zIGYgYWNjIHNlcSA9XG4gIGxldCByZWMgYXV4IGYgYWNjIHNlcSA9XG4gICAgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQqIGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgYXV4IGYgYWNjIG5leHRcbiAgaW5cbiAgbGV0IGF1eCBmIGFjYyBzZXEgPVxuICAgIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LnJldHVybiBhY2NcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCogYWNjID0gZiBhY2MgeCBpblxuICAgICAgICBhdXggZiBhY2MgbmV4dFxuICBpblxuICBhdXggZiBhY2Mgc2VxXG5cbmxldCBpdGVyIGYgc2VxID1cbiAgbGV0IHJlYyBhdXggc2VxID1cbiAgICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LnJldHVybl91bml0XG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBmIHg7XG4gICAgICAgIGF1eCBuZXh0XG4gIGluXG4gIGxldCBhdXggc2VxID1cbiAgICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm5fdW5pdFxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgZiB4O1xuICAgICAgICBhdXggbmV4dFxuICBpblxuICBhdXggc2VxXG5cbmxldCBpdGVyX3MgZiBzZXEgPVxuICBsZXQgcmVjIGF1eCBzZXEgPVxuICAgIHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiBMd3QucmV0dXJuX3VuaXRcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCogKCkgPSBmIHggaW5cbiAgICAgICAgYXV4IG5leHRcbiAgaW5cbiAgbGV0IGF1eCBzZXEgPVxuICAgIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LnJldHVybl91bml0XG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQqICgpID0gZiB4IGluXG4gICAgICAgIGF1eCBuZXh0XG4gIGluXG4gIGF1eCBzZXFcblxubGV0IGl0ZXJfcCBmIHNlcSA9XG4gIGxldCByZWMgYXV4IGFjYyBzZXEgPVxuICAgIHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiBMd3Quam9pbiBhY2NcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCBwID0gZiB4IGluXG4gICAgICAgIGF1eCAocDo6YWNjKSBuZXh0XG4gIGluXG4gIGxldCBhdXggYWNjIHNlcSA9XG4gICAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiBMd3Quam9pbiBhY2NcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCBwID0gZiB4IGluXG4gICAgICAgIGF1eCAocDo6YWNjKSBuZXh0XG4gIGluXG4gIGF1eCBbXSBzZXFcblxubGV0IGl0ZXJfbiA/KG1heF9jb25jdXJyZW5jeSA9IDEpIGYgc2VxID1cbiAgYmVnaW5cbiAgICBpZiBtYXhfY29uY3VycmVuY3kgPD0gMCB0aGVuXG4gICAgICBsZXQgbWVzc2FnZSA9XG4gICAgICAgIFByaW50Zi5zcHJpbnRmXG4gICAgICAgICAgXCJMd3Rfc2VxLml0ZXJfbjogbWF4X2NvbmN1cnJlbmN5IG11c3QgYmUgPiAwLCAlZCBnaXZlblwiXG4gICAgICAgICAgbWF4X2NvbmN1cnJlbmN5XG4gICAgICBpblxuICAgICAgaW52YWxpZF9hcmcgbWVzc2FnZVxuICBlbmQ7XG4gIGxldCByZWMgbG9vcCBydW5uaW5nIGF2YWlsYWJsZSBzZXEgPVxuICAgIGJlZ2luXG4gICAgICBpZiBhdmFpbGFibGUgPiAwIHRoZW4gKFxuICAgICAgICBMd3QucmV0dXJuIChydW5uaW5nLCBhdmFpbGFibGUpXG4gICAgICApXG4gICAgICBlbHNlIChcbiAgICAgICAgTHd0Lm5jaG9vc2Vfc3BsaXQgcnVubmluZyA+Pj0gZnVuIChjb21wbGV0ZSwgcnVubmluZykgLT5cbiAgICAgICAgTHd0LnJldHVybiAocnVubmluZywgYXZhaWxhYmxlICsgTGlzdC5sZW5ndGggY29tcGxldGUpXG4gICAgICApXG4gICAgZW5kID4+PSBmdW4gKHJ1bm5pbmcsIGF2YWlsYWJsZSkgLT5cbiAgICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT5cbiAgICAgIEx3dC5qb2luIHJ1bm5pbmdcbiAgICB8IENvbnMgKGVsdCwgc2VxKSAtPlxuICAgICAgbG9vcCAoZiBlbHQgOjogcnVubmluZykgKHByZWQgYXZhaWxhYmxlKSBzZXFcbiAgaW5cbiAgKCogYmVjYXVzZSB0aGUgcmVjdXJzaW9uIGlzIG1vcmUgY29tcGxpY2F0ZWQgaGVyZSwgd2UgYXBwbHkgdGhlIHNlcSBkaXJlY3RseSBhdFxuICAgICB0aGUgY2FsbC1zaXRlIGluc3RlYWQgKilcbiAgbG9vcCBbXSBtYXhfY29uY3VycmVuY3kgKGZ1biAoKSAtPiBMd3QuYXBwbHkgc2VxICgpKVxuXG5sZXQgcmVjIHVuZm9sZCBmIHUgKCkgPVxuICBtYXRjaCBmIHUgd2l0aFxuICB8IE5vbmUgLT4gcmV0dXJuX25pbFxuICB8IFNvbWUgKHgsIHUnKSAtPiBMd3QucmV0dXJuIChDb25zICh4LCB1bmZvbGQgZiB1JykpXG4gIHwgZXhjZXB0aW9uIGV4YyB3aGVuIEx3dC5FeGNlcHRpb25fZmlsdGVyLnJ1biBleGMgLT4gTHd0LnJlcmFpc2UgZXhjXG5cbmxldCByZWMgdW5mb2xkX2x3dCBmIHUgKCkgPVxuICBsZXQqIHggPSBmIHUgaW5cbiAgbWF0Y2ggeCB3aXRoXG4gIHwgTm9uZSAtPiByZXR1cm5fbmlsXG4gIHwgU29tZSAoeCwgdScpIC0+IEx3dC5yZXR1cm4gKENvbnMgKHgsIHVuZm9sZF9sd3QgZiB1JykpXG5sZXQgdW5mb2xkX2x3dCBmIHUgKCkgPVxuICBsZXQqIHggPSBMd3QuYXBwbHkgZiB1IGluXG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4gcmV0dXJuX25pbFxuICB8IFNvbWUgKHgsIHUnKSAtPiBMd3QucmV0dXJuIChDb25zICh4LCB1bmZvbGRfbHd0IGYgdScpKVxuXG5sZXQgcmVjIG9mX2xpc3QgbCAoKSA9XG4gIEx3dC5yZXR1cm4gKG1hdGNoIGwgd2l0aCBbXSAtPiBOaWwgfCBoIDo6IHQgLT4gQ29ucyAoaCwgb2ZfbGlzdCB0KSlcblxubGV0IHRvX2xpc3QgKHNlcSA6ICdhIHQpID1cbiAgbGV0IHJlYyBhdXggZiBzZXEgPVxuICAgIEx3dC5iaW5kIChzZXEgKCkpIChmdW5jdGlvblxuICAgICAgfCBOaWwgLT4gTHd0LnJldHVybiAoZiBbXSlcbiAgICAgIHwgQ29ucyAoaCwgdCkgLT4gYXV4IChmdW4geCAtPiBmIChoIDo6IHgpKSB0KVxuICBpblxuICBhdXggKGZ1biB4IC0+IHgpIChMd3QuYXBwbHkgc2VxKVxuXG5sZXQgcmVjIG9mX3NlcSBzZXEgKCkgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IFNlcS5OaWwgLT4gcmV0dXJuX25pbFxuICB8IFNlcS5Db25zICh4LCBuZXh0KSAtPlxuICAgIEx3dC5yZXR1cm4gKENvbnMgKHgsIChvZl9zZXEgbmV4dCkpKVxuICB8IGV4Y2VwdGlvbiBleG4gd2hlbiBMd3QuRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IEx3dC5yZXJhaXNlIGV4blxuXG5sZXQgcmVjIG9mX3NlcV9sd3QgKHNlcTogJ2EgTHd0LnQgU2VxLnQpOiAnYSB0ID0gZnVuICgpIC0+XG4gICAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IFNlcS5OaWwgLT4gcmV0dXJuX25pbFxuICAgIHwgU2VxLkNvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgbGV0KyB4ID0geCBpblxuICAgICAgIGxldCBuZXh0ID0gb2Zfc2VxX2x3dCBuZXh0IGluXG4gICAgICAgQ29ucyAoeCwgbmV4dClcbmxldCBvZl9zZXFfbHd0IChzZXE6ICdhIEx3dC50IFNlcS50KTogJ2EgdCA9IGZ1biAoKSAtPlxuICAgIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBTZXEuTmlsIC0+IHJldHVybl9uaWxcbiAgICB8IFNlcS5Db25zICh4LCBuZXh0KSAtPlxuICAgICAgIGxldCsgeCA9IHggaW5cbiAgICAgICBsZXQgbmV4dCA9IG9mX3NlcV9sd3QgbmV4dCBpblxuICAgICAgIENvbnMgKHgsIG5leHQpXG4gICAgfCBleGNlcHRpb24gZXhjIHdoZW4gTHd0LkV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4YyAtPiBMd3QucmVyYWlzZSBleGNcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMDU3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Imx3dC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY3N0X2Jsb2NrZWQiLCJjc3RfY2xvc2UiLCJjc3RfY2xvc2VkIiwiY3N0X2NvdW50IiwiY3N0X3B1c2giLCJjc3RfcmVzaXplIiwiY3N0X3NldF9yZWZlcmVuY2UiLCJjc3Rfc2l6ZSIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNSIsImEzIiwiYTQiLCJkdW1teSIsImdsb2JhbF9kYXRhIiwic2hhcmVkIiwiTHd0IiwiU3RkbGliX0xpc3QiLCJTdGRsaWJfQnVmZmVyIiwiU3RkbGliX1ByaW50ZiIsIlN0ZGxpYiIsIkNhbWxpbnRlcm5hbE9PIiwiU3RkbGliX1N0cmluZyIsIlN0ZGxpYl9BcnJheSIsIkNsb3NlZCIsIkZ1bGwiLCJFbXB0eSIsImNzdF9Md3Rfc3RyZWFtX2Nsb25lIiwiY3N0X0x3dF9zdHJlYW1fYm91bmRlZF9wdXNoX3JlIiwibmV3X25vZGUiLCJwYXJhbSIsIm5vZGUiLCJjbG9uZSIsInMiLCJmcm9tX3NvdXJjZSIsInNvdXJjZSIsIm1hdGNoIiwiY2xvc2UiLCJjbG9zZWQiLCJmcm9tIiwiZnJvbV9kaXJlY3QiLCJpc19jbG9zZWQiLCJlbnF1ZXVlIiwiZSIsImxhc3QiLCJuZXdfbGFzdCIsImNyZWF0ZV93aXRoX3JlZmVyZW5jZSIsInB1c2hfc2lnbmFsX3Jlc29sdmVyIiwicHVzaF9zaWduYWwiLCJ0IiwicHVzaCIsIngiLCJvbGRfcHVzaF9zaWduYWxfcmVzb2x2ZXIiLCJuZXdfcHVzaF9zaWduYWxfcmVzb2x2ZXIiLCJuZXdfd2FpdGVyIiwicmV0dXJuIiwiYSIsInN0cmVhbSIsInJldHVybl9sd3QiLCJleGMiLCJvZl9zZXEiLCJnZXQiLCJlbHQiLCJvZl9sd3Rfc2VxIiwiY3JlYXRlIiwib2ZfaXRlciIsIml0ZXIiLCJpIiwib2ZfbGlzdCIsImwiLCJvZl9hcnJheSIsIm9mX3N0cmluZyIsIm5vdGlmeV9wdXNoZXIiLCJpbmZvIiwib2xkX3dha2VuZXIiLCJ3YWtlbmVyIiwid2FpdGVyIiwiYm91bmRlZF9wdXNoX2ltcGwiLCJzZWxmXzEiLCJzaXplIiwiZXhuIiwibmV3X3dha2VuZXIiLCJjc3RfTHd0X3N0cmVhbV9jcmVhdGVfYm91bmRlZCIsImNzdF9Md3Rfc3RyZWFtX3BhcnNlIiwiY3JlYXRlX2JvdW5kZWQiLCJwdXNoX3dha2VuZXIiLCJwdXNoX3dhaXRlciIsIndha2VuZXJfY2VsbCIsImZlZWQiLCJ0aHJlYWQiLCJjb25zdW1lIiwicGVla19yZWMiLCJwZWVrIiwibnBlZWtfcmVjIiwiYWNjIiwibiIsIm5wZWVrIiwiZ2V0X3JlYyIsImdldF9leG5fcmVjIiwidmFsdWUiLCJ3cmFwX2V4biIsIm5nZXRfcmVjIiwibmdldCIsImdldF93aGlsZV9yZWMiLCJ0ZXN0IiwiZ2V0X3doaWxlIiwiZ2V0X3doaWxlX3NfcmVjIiwiZ2V0X3doaWxlX3MiLCJuZXh0X3JlYyIsIm5leHQiLCJsYXN0X25ld19yZWMiLCJsYXN0X25ldyIsInRvX2xpc3RfcmVjIiwidG9fbGlzdCIsInRvX3N0cmluZ19yZWMiLCJidWYiLCJ0b19zdHJpbmciLCJqdW5rIiwibmp1bmtfcmVjIiwibmp1bmsiLCJqdW5rX3doaWxlX3JlYyIsImp1bmtfd2hpbGUiLCJqdW5rX3doaWxlX3NfcmVjIiwianVua193aGlsZV9zIiwianVua19hdmFpbGFibGUiLCJqdW5rX29sZCIsImdldF9hdmFpbGFibGUiLCJnZXRfYXZhaWxhYmxlX3VwX3RvIiwiaXNfZW1wdHkiLCJtYXAiLCJtYXBfcyIsImZpbHRlciIsImZpbHRlcl9zIiwiZmlsdGVyX21hcCIsImZpbHRlcl9tYXBfcyIsIm1hcF9saXN0IiwicGVuZGluZ3MiLCJtYXBfbGlzdF9zIiwiZmxhdHRlbiIsImZvbGRfcmVjIiwiZm9sZCIsImZvbGRfc19yZWMiLCJmb2xkX3MiLCJpdGVyX3JlYyIsIml0ZXJfc19yZWMiLCJpdGVyX3MiLCJpdGVyX3BfcmVjIiwicmVzIiwicmVzdCIsIml0ZXJfcCIsIml0ZXJfbiIsIm9wdCIsInN0aCIsIm1heF9jb25jdXJyZW5jeSIsIm1lc3NhZ2UiLCJsb29wIiwicnVubmluZyIsImF2YWlsYWJsZSIsImNvbXBsZXRlIiwiZmluZF9yZWMiLCJmaW5kIiwiZmluZF9zX3JlYyIsImZpbmRfcyIsImZpbmRfbWFwX3JlYyIsImZpbmRfbWFwIiwiZmluZF9tYXBfc19yZWMiLCJmaW5kX21hcF9zIiwiY29tYmluZSIsInMxIiwiczIiLCJ0MSIsInQyIiwibjEiLCJuMiIsIngyIiwieDEiLCJhcHBlbmQiLCJjdXJyZW50X3MiLCJjb25jYXQiLCJzX3RvcCIsImNob29zZSIsInN0cmVhbXMiLCJwYXJzZSIsImhleGR1bXAiLCJudW0iLCJwb3MiLCJjaCIsIkx3dF9zdHJlYW0iXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2pzZW8vLm9wYW0vNC4xMy4xL2xpYi9sd3QvbHd0X3N0cmVhbS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFB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QUFBQTtBQUFBLElBRWIsaUJBQVM7QUFBQTtBQUFBLFlBQUFpSCxNQUFBckosR0FBQTdCO0FBQUFBLElBR1Qsa0JBQ3FCO0FBQUEsUUFBQTJCLE9BRXJCO0FBQUEsSUFDQTtBQUFBO0FBQUEsc0JBQUFELE9BQ2EsdUJBQUc7QUFBQSxzQkFBQWtEO0FBQUFBLGNBRVg7QUFBQSxjQUNBO0FBQUEsYUFBZSxFQUFDO0FBQUE7QUFBQSxZQUFBdUcsUUFBQTlIO0FBQUFBLFFBQUEwRCxNQUdYLGtDQUFBcUUsTUFBZ0I7QUFBQSxJQUMxQjtBQUFBLHNCQUFBMUo7QUFBQUEsa0JBQUEsTUFDRTtBQUFBLGNBQWM7QUFBQTtBQUFBO0FBQUEsZ0NBQUF1QztBQUFBQSx3QkFBSyxRQUVqQjtBQUFBLHdCQUVBO0FBQUEsd0JBQ0E7QUFBQSx3QkFBaUM7QUFBQSw0QkFBQW9ILE1Ba0JqQyxHQUFBM0osUUFBQTtBQUFBO0FBQUEseUJBaEJjO0FBQUEsNkJBQUF1QyxNQUFBLFVBQUFsQixJQUFBO0FBQUEseUJBSVYsY0FBZ0I7QUFBQSx5QkFDaEI7QUFBQSw2QkFBQXNJLFFBQXdDO0FBQUE7QUFBQTtBQUFBO0FBQUEsNEJBQUFBLFFBSHhDO0FBQUE7QUFBQSx5QkFNRjtBQUFBLHlCQUFpQjtBQUFBLDBCQUViO0FBQUE7QUFBQSwwQkFFQTtBQUFBLDZCQUFBQSxRQUNGO0FBQUE7QUFBQTtBQUFBLHdCQUlKO0FBQUEsd0JBQ0E7QUFBQTtBQUFBLG1DQUFBQztBQUFBQTtBQUFBQTtBQUFBQSw0QkFBcUIsb0NBQTBEO0FBQUEsc0NBQVE7QUFBQTtBQUFBLDJCQUFsRSw4Q0FBc0U7QUFBQTtBQUFBO0FBQUEsd0JBQzNGO0FBQUEsa0NBQ2dCO0FBQUEsd0JBQXFCLDhCQUFDO0FBQUE7QUFBQSxlQUN2QztBQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNRDFsQ0wiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5vcGVuIEx3dC5JbmZpeFxuXG5leGNlcHRpb24gQ2xvc2VkXG5leGNlcHRpb24gRnVsbFxuZXhjZXB0aW9uIEVtcHR5XG5cbigqIEEgbm9kZSBpbiBhIHF1ZXVlIG9mIHBlbmRpbmcgZGF0YS4gKilcbnR5cGUgJ2Egbm9kZSA9IHtcbiAgbXV0YWJsZSBuZXh0IDogJ2Egbm9kZTtcbiAgKCogTmV4dCBub2RlIGluIHRoZSBxdWV1ZS4gRm9yIHRoZSBsYXN0IG5vZGUgaXQgcG9pbnRzIHRvIGl0c2VsZi4gKilcbiAgbXV0YWJsZSBkYXRhIDogJ2Egb3B0aW9uO1xuICAoKiBEYXRhIG9mIHRoaXMgbm9kZS4gRm9yIHRoZSBsYXN0IG5vZGUgaXQgaXMgYWx3YXlzIFtOb25lXS4gKilcbn1cblxuKCogTm90ZTogYSBxdWV1ZSBmb3IgYW4gZXhoYXVzdGVkIHN0cmVhbSBpcyByZXByZXNlbnRlZCBieSBhIG5vZGVcbiAgIGNvbnRhaW5pbmcgW05vbmVdIGZvbGxvd2VkIGJ5IGEgbm9kZSB3aXRoIGl0c2VsZiBhcyBuZXh0IGFuZCBbTm9uZV1cbiAgIGFzIGRhdGEuICopXG5cbmxldCBuZXdfbm9kZSAoKSA9XG4gIGxldCByZWMgbm9kZSA9IHsgbmV4dCA9IG5vZGU7IGRhdGEgPSBOb25lIH0gaW5cbiAgbm9kZVxuXG4oKiBUeXBlIG9mIGEgc3RyZWFtIHNvdXJjZSB1c2luZyBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBuZXcgZWxlbWVudHMuICopXG50eXBlICdhIGZyb20gPSB7XG4gIGZyb21fY3JlYXRlIDogdW5pdCAtPiAnYSBvcHRpb24gTHd0LnQ7XG4gICgqIEZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIG5ldyBlbGVtZW50cy4gKilcbiAgbXV0YWJsZSBmcm9tX3RocmVhZCA6IHVuaXQgTHd0LnQ7XG4gICgqIFRocmVhZCB3aGljaDpcblxuICAgICAtIHdhaXQgZm9yIHRoZSB0aHJlYWQgcmV0dXJuZWQgYnkgdGhlIGxhc3QgY2FsbCB0byBbZnJvbV9uZXh0XSxcbiAgICAgLSBhZGQgdGhlIG5leHQgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZS5cblxuICAgICBJZiBpdCBpcyBhIHNsZWVwaW5nIHRocmVhZCwgdGhlbiBpdCBtdXN0IGJlIHVzZWQgaW5zdGVhZCBvZiBjcmVhdGluZyBhXG4gICAgIG5ldyBvbmUgd2l0aCBbZnJvbV9jcmVhdGVdLiAqKVxufVxuXG4oKiBUeXBlIG9mIGEgc3RyZWFtIHNvdXJjZSBmb3IgcHVzaCBzdHJlYW1zLiAqKVxudHlwZSBwdXNoID0ge1xuICBtdXRhYmxlIHB1c2hfc2lnbmFsIDogdW5pdCBMd3QudDtcbiAgKCogVGhyZWFkIHNpZ25hbGVkIHdoZW4gYSBuZXcgZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgc3RyZWFtLiAqKVxuICBtdXRhYmxlIHB1c2hfd2FpdGluZyA6IGJvb2w7XG4gICgqIElzIGEgdGhyZWFkIHdhaXRpbmcgb24gW3B1c2hfc2lnbmFsXSA/ICopXG4gIG11dGFibGUgcHVzaF9leHRlcm5hbCA6IE9iai50IFtAb2NhbWwud2FybmluZyBcIi02OVwiXTtcbiAgKCogUmVmZXJlbmNlIHRvIGFuIGV4dGVybmFsIHNvdXJjZS4gKilcbn1cblxuKCogVHlwZSBvZiBhIHN0cmVhbSBzb3VyY2UgZm9yIGJvdW5kZWQtcHVzaCBzdHJlYW1zLiAqKVxudHlwZSAnYSBwdXNoX2JvdW5kZWQgPSB7XG4gIG11dGFibGUgcHVzaGJfc2lnbmFsIDogdW5pdCBMd3QudDtcbiAgKCogVGhyZWFkIHNpZ25hbGVkIHdoZW4gYSBuZXcgZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgc3RyZWFtLiAqKVxuICBtdXRhYmxlIHB1c2hiX3dhaXRpbmcgOiBib29sO1xuICAoKiBJcyBhIHRocmVhZCB3YWl0aW5nIG9uIFtwdXNoYl9zaWduYWxdID8gKilcbiAgbXV0YWJsZSBwdXNoYl9zaXplIDogaW50O1xuICAoKiBTaXplIG9mIHRoZSBxdWV1ZS4gKilcbiAgbXV0YWJsZSBwdXNoYl9jb3VudCA6IGludDtcbiAgKCogQ3VycmVudCBsZW5ndGggb2YgdGhlIHF1ZXVlLiAqKVxuICBtdXRhYmxlIHB1c2hiX3BlbmRpbmcgOiAnYSBvcHRpb247XG4gICgqIFRoZSBuZXh0IGVsZW1lbnQgdG8gcHVzaCBpZiBhIHRocmVhZCBibG9ja2VkIG9uIHB1c2guIFdlIHN0b3JlIGl0XG4gICAgIGhlcmUgdG8gYmUgc3VyZSBpdCB3aWxsIGJlIHRoZSBmaXJzdCBlbGVtZW50IHRvIGJlIGFkZGVkIHdoZW5cbiAgICAgc3BhY2UgYmVjb21lcyBhdmFpbGFibGUuICopXG4gIG11dGFibGUgcHVzaGJfcHVzaF93YWl0ZXIgOiB1bml0IEx3dC50O1xuICBtdXRhYmxlIHB1c2hiX3B1c2hfd2FrZW5lciA6IHVuaXQgTHd0LnU7XG4gICgqIFRocmVhZCBibG9ja2VkIG9uIHB1c2guICopXG4gIG11dGFibGUgcHVzaGJfZXh0ZXJuYWwgOiBPYmoudCBbQG9jYW1sLndhcm5pbmcgXCItNjlcIl07XG4gICgqIFJlZmVyZW5jZSB0byBhbiBleHRlcm5hbCBzb3VyY2UuICopXG59XG5cbigqIFNvdXJjZSBvZiBhIHN0cmVhbS4gKilcbnR5cGUgJ2Egc291cmNlID1cbiAgfCBGcm9tIG9mICdhIGZyb21cbiAgfCBGcm9tX2RpcmVjdCBvZiAodW5pdCAtPiAnYSBvcHRpb24pXG4gIHwgUHVzaCBvZiBwdXNoXG4gIHwgUHVzaF9ib3VuZGVkIG9mICdhIHB1c2hfYm91bmRlZFxuXG50eXBlICdhIHQgPSB7XG4gIHNvdXJjZSA6ICdhIHNvdXJjZTtcbiAgKCogVGhlIHNvdXJjZSBvZiB0aGUgc3RyZWFtLiAqKVxuICBjbG9zZSA6IHVuaXQgTHd0LnU7XG4gICgqIEEgd2FrZW5lciBmb3IgYSB0aHJlYWQgdGhhdCBzbGVlcHMgdW50aWwgdGhlIHN0cmVhbSBpcyBjbG9zZWQuICopXG4gIGNsb3NlZCA6IHVuaXQgTHd0LnQ7XG4gICgqIEEgd2FpdGVyIGZvciBhIHRocmVhZCB0aGF0IHNsZWVwcyB1bnRpbCB0aGUgc3RyZWFtIGlzIGNsb3NlZC4gKilcbiAgbXV0YWJsZSBub2RlIDogJ2Egbm9kZTtcbiAgKCogUG9pbnRlciB0byBmaXJzdCBwZW5kaW5nIGVsZW1lbnQsIG9yIHRvIFtsYXN0XSBpZiB0aGVyZSBpcyBub1xuICAgICBwZW5kaW5nIGVsZW1lbnQuICopXG4gIGxhc3QgOiAnYSBub2RlIHJlZjtcbiAgKCogTm9kZSBtYXJraW5nIHRoZSBlbmQgb2YgdGhlIHF1ZXVlIG9mIHBlbmRpbmcgZWxlbWVudHMuICopXG59XG5cbmNsYXNzIHR5cGUgWydhXSBib3VuZGVkX3B1c2ggPSBvYmplY3RcbiAgbWV0aG9kIHNpemUgOiBpbnRcbiAgbWV0aG9kIHJlc2l6ZSA6IGludCAtPiB1bml0XG4gIG1ldGhvZCBwdXNoIDogJ2EgLT4gdW5pdCBMd3QudFxuICBtZXRob2QgY2xvc2UgOiB1bml0XG4gIG1ldGhvZCBjb3VudCA6IGludFxuICBtZXRob2QgYmxvY2tlZCA6IGJvb2xcbiAgbWV0aG9kIGNsb3NlZCA6IGJvb2xcbiAgbWV0aG9kIHNldF9yZWZlcmVuY2UgOiAnYS4gJ2EgLT4gdW5pdFxuZW5kXG5cbigqIFRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gY2xvbmVzIGlzIHRoZSBwb2ludGVyIHRvIHRoZSBmaXJzdFxuICAgcGVuZGluZyBlbGVtZW50LiAqKVxubGV0IGNsb25lIHMgPVxuICAobWF0Y2ggcy5zb3VyY2Ugd2l0aFxuICAgfCBQdXNoX2JvdW5kZWQgXyAtPiBpbnZhbGlkX2FyZyBcIkx3dF9zdHJlYW0uY2xvbmVcIlxuICAgfCBGcm9tIF8gfCBGcm9tX2RpcmVjdCBfIHwgUHVzaCBfIC0+ICgpKTtcbiAge1xuICAgIHNvdXJjZSA9IHMuc291cmNlO1xuICAgIGNsb3NlID0gcy5jbG9zZTtcbiAgICBjbG9zZWQgPSBzLmNsb3NlZDtcbiAgICBub2RlID0gcy5ub2RlO1xuICAgIGxhc3QgPSBzLmxhc3Q7XG4gIH1cblxubGV0IGZyb21fc291cmNlIHNvdXJjZSA9XG4gIGxldCBub2RlID0gbmV3X25vZGUgKCkgaW5cbiAgbGV0IGNsb3NlZCwgY2xvc2UgPSBMd3Qud2FpdCAoKSBpblxuICB7IHNvdXJjZSA7IGNsb3NlIDsgY2xvc2VkIDsgbm9kZSA7IGxhc3QgPSByZWYgbm9kZSB9XG5cbmxldCBmcm9tIGYgPVxuICBmcm9tX3NvdXJjZSAoRnJvbSB7IGZyb21fY3JlYXRlID0gZjsgZnJvbV90aHJlYWQgPSBMd3QucmV0dXJuX3VuaXQgfSlcblxubGV0IGZyb21fZGlyZWN0IGYgPVxuICBmcm9tX3NvdXJjZSAoRnJvbV9kaXJlY3QgZilcblxubGV0IGNsb3NlZCBzID0gcy5jbG9zZWRcblxubGV0IGlzX2Nsb3NlZCBzID1cbiAgbm90IChMd3QuaXNfc2xlZXBpbmcgKGNsb3NlZCBzKSlcblxubGV0IGVucXVldWUnIGUgbGFzdCA9XG4gIGxldCBub2RlID0gIWxhc3RcbiAgYW5kIG5ld19sYXN0ID0gbmV3X25vZGUgKCkgaW5cbiAgbm9kZS5kYXRhIDwtIGU7XG4gIG5vZGUubmV4dCA8LSBuZXdfbGFzdDtcbiAgbGFzdCA6PSBuZXdfbGFzdFxuXG5sZXQgZW5xdWV1ZSBlIHMgPVxuICBlbnF1ZXVlJyBlIHMubGFzdFxuXG5sZXQgY3JlYXRlX3dpdGhfcmVmZXJlbmNlICgpID1cbiAgKCogQ3JlYXRlIHRoZSBzb3VyY2UgZm9yIG5vdGlmaWNhdGlvbnMgb2YgbmV3IGVsZW1lbnRzLiAqKVxuICBsZXQgc291cmNlLCBwdXNoX3NpZ25hbF9yZXNvbHZlciA9XG4gICAgbGV0IHB1c2hfc2lnbmFsLCBwdXNoX3NpZ25hbF9yZXNvbHZlciA9IEx3dC53YWl0ICgpIGluXG4gICAgKHsgcHVzaF9zaWduYWw7XG4gICAgICAgcHVzaF93YWl0aW5nID0gZmFsc2U7XG4gICAgICAgcHVzaF9leHRlcm5hbCA9IE9iai5yZXByICgpIH0sXG4gICAgIHJlZiBwdXNoX3NpZ25hbF9yZXNvbHZlcilcbiAgaW5cbiAgbGV0IHQgPSBmcm9tX3NvdXJjZSAoUHVzaCBzb3VyY2UpIGluXG4gICgqIFtwdXNoXSBzaG91bGQgbm90IGNsb3NlIG92ZXIgW3RdIHNvIHRoYXQgaXQgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGV2ZW5cbiAgICogdGhlcmUgYXJlIHN0aWxsIHJlZmVyZW5jZXMgdG8gW3B1c2hdLiBVbnBhY2sgYWxsIHRoZSBjb21wb25lbnRzIG9mIFt0XVxuICAgKiB0aGF0IFtwdXNoXSBuZWVkcyBhbmQgcmVmZXJlbmNlIHRob3NlIGlkZW50aWZpZXJzIGluc3RlYWQuICopXG4gIGxldCBjbG9zZSA9IHQuY2xvc2UgYW5kIGNsb3NlZCA9IHQuY2xvc2VkIGFuZCBsYXN0ID0gdC5sYXN0IGluXG4gICgqIFRoZSBwdXNoIGZ1bmN0aW9uLiBJdCBkb2VzIG5vdCBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdHJlYW0uICopXG4gIGxldCBwdXNoIHggPVxuICAgIGlmIG5vdCAoTHd0LmlzX3NsZWVwaW5nIGNsb3NlZCkgdGhlbiByYWlzZSBDbG9zZWQ7XG4gICAgKCogUHVzaCB0aGUgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBxdWV1ZS4gKilcbiAgICBlbnF1ZXVlJyB4IGxhc3Q7XG4gICAgKCogU2VuZCBhIHNpZ25hbCBpZiBhdCBsZWFzdCBvbmUgdGhyZWFkIGlzIHdhaXRpbmcgZm9yIGEgbmV3XG4gICAgICAgZWxlbWVudC4gKilcbiAgICBpZiBzb3VyY2UucHVzaF93YWl0aW5nIHRoZW4gYmVnaW5cbiAgICAgIHNvdXJjZS5wdXNoX3dhaXRpbmcgPC0gZmFsc2U7XG4gICAgICAoKiBVcGRhdGUgdGhyZWFkcy4gKilcbiAgICAgIGxldCBvbGRfcHVzaF9zaWduYWxfcmVzb2x2ZXIgPSAhcHVzaF9zaWduYWxfcmVzb2x2ZXIgaW5cbiAgICAgIGxldCBuZXdfd2FpdGVyLCBuZXdfcHVzaF9zaWduYWxfcmVzb2x2ZXIgPSBMd3Qud2FpdCAoKSBpblxuICAgICAgc291cmNlLnB1c2hfc2lnbmFsIDwtIG5ld193YWl0ZXI7XG4gICAgICBwdXNoX3NpZ25hbF9yZXNvbHZlciA6PSBuZXdfcHVzaF9zaWduYWxfcmVzb2x2ZXI7XG4gICAgICAoKiBTaWduYWwgdGhhdCBhIG5ldyB2YWx1ZSBoYXMgYmVlbiByZWNlaXZlZC4gKilcbiAgICAgIEx3dC53YWtldXBfbGF0ZXIgb2xkX3B1c2hfc2lnbmFsX3Jlc29sdmVyICgpXG4gICAgZW5kO1xuICAgICgqIERvIHRoaXMgYXQgdGhlIGVuZCBpbiBjYXNlIG9uZSBvZiB0aGUgZnVuY3Rpb24gcmFpc2UgYW5cbiAgICAgICBleGNlcHRpb24uICopXG4gICAgaWYgeCA9IE5vbmUgdGhlbiBMd3Qud2FrZXVwIGNsb3NlICgpXG4gIGluXG4gICh0LCBwdXNoLCBmdW4geCAtPiBzb3VyY2UucHVzaF9leHRlcm5hbCA8LSBPYmoucmVwciB4KVxuXG5sZXQgcmV0dXJuIGEgPVxuICBsZXQgc3RyZWFtLCBwdXNoLCBfID0gY3JlYXRlX3dpdGhfcmVmZXJlbmNlICgpIGluXG4gIHB1c2ggKFNvbWUgYSk7XG4gIHB1c2ggTm9uZTtcbiAgc3RyZWFtXG5cbmxldCByZXR1cm5fbHd0IGEgPVxuICBsZXQgc291cmNlLCBwdXNoLCBfID0gY3JlYXRlX3dpdGhfcmVmZXJlbmNlICgpIGluXG4gIEx3dC5kb250X3dhaXRcbiAgICAoZnVuICgpIC0+XG4gICAgICBMd3QuYmluZCBhIChmdW4geCAtPlxuICAgICAgICBwdXNoIChTb21lIHgpO1xuICAgICAgICBwdXNoIE5vbmU7XG4gICAgICAgIEx3dC5yZXR1cm5fdW5pdCkpXG4gICAgKGZ1biBfZXhjIC0+IHB1c2ggTm9uZSk7XG4gIHNvdXJjZVxuXG5sZXQgb2Zfc2VxIHMgPVxuICBsZXQgcyA9IHJlZiBzIGluXG4gIGxldCBnZXQgKCkgPVxuICAgIG1hdGNoICFzICgpIHdpdGhcbiAgICB8IFNlcS5OaWwgLT4gTm9uZVxuICAgIHwgU2VxLkNvbnMgKGVsdCwgcycpIC0+IHMgOj0gcyc7IFNvbWUgZWx0XG4gIGluXG4gIGZyb21fZGlyZWN0IGdldFxuXG5sZXQgb2ZfbHd0X3NlcSBzID1cbiAgbGV0IHMgPSByZWYgcyBpblxuICBsZXQgZ2V0ICgpID1cbiAgICAhcyAoKSA+fD0gZnVuY3Rpb25cbiAgICB8IEx3dF9zZXEuTmlsIC0+IE5vbmVcbiAgICB8IEx3dF9zZXEuQ29ucyAoZWx0LCBzJykgLT4gcyA6PSBzJzsgU29tZSBlbHRcbiAgaW5cbiAgZnJvbSBnZXRcblxuXG5sZXQgY3JlYXRlICgpID1cbiAgbGV0IHNvdXJjZSwgcHVzaCwgXyA9IGNyZWF0ZV93aXRoX3JlZmVyZW5jZSAoKSBpblxuICAoc291cmNlLCBwdXNoKVxuXG5sZXQgb2ZfaXRlciBpdGVyIGkgPVxuICBsZXQgc3RyZWFtLCBwdXNoID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgKGZ1biB4IC0+IHB1c2ggKFNvbWUgeCkpIGk7XG4gIHB1c2ggTm9uZTtcbiAgc3RyZWFtXG5cbmxldCBvZl9saXN0IGwgPVxuICBvZl9pdGVyIExpc3QuaXRlciBsXG5cbmxldCBvZl9hcnJheSBhID1cbiAgb2ZfaXRlciBBcnJheS5pdGVyIGFcblxubGV0IG9mX3N0cmluZyBzID1cbiAgb2ZfaXRlciBTdHJpbmcuaXRlciBzXG5cbigqIEFkZCB0aGUgcGVuZGluZyBlbGVtZW50IHRvIHRoZSBxdWV1ZSBhbmQgbm90aWZ5IHRoZSBibG9ja2VkIHB1c2hlZC5cblxuICAgUHJlY29uZGl0aW9uOiBpbmZvLnB1c2hiX3BlbmRpbmcgPSBTb21lIF9cblxuICAgVGhpcyBkb2VzIG5vdCBtb2RpZnkgaW5mby5wdXNoYl9jb3VudC4gKilcbmxldCBub3RpZnlfcHVzaGVyIGluZm8gbGFzdCA9XG4gICgqIFB1c2ggdGhlIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgcXVldWUuICopXG4gIGVucXVldWUnIGluZm8ucHVzaGJfcGVuZGluZyBsYXN0O1xuICAoKiBDbGVhciBwZW5kaW5nIGVsZW1lbnQuICopXG4gIGluZm8ucHVzaGJfcGVuZGluZyA8LSBOb25lO1xuICAoKiBXYWtldXAgdGhlIHB1c2hlci4gKilcbiAgbGV0IG9sZF93YWtlbmVyID0gaW5mby5wdXNoYl9wdXNoX3dha2VuZXIgaW5cbiAgbGV0IHdhaXRlciwgd2FrZW5lciA9IEx3dC50YXNrICgpIGluXG4gIGluZm8ucHVzaGJfcHVzaF93YWl0ZXIgPC0gd2FpdGVyO1xuICBpbmZvLnB1c2hiX3B1c2hfd2FrZW5lciA8LSB3YWtlbmVyO1xuICBMd3Qud2FrZXVwX2xhdGVyIG9sZF93YWtlbmVyICgpXG5cbmNsYXNzIFsnYV0gYm91bmRlZF9wdXNoX2ltcGwgKGluZm8gOiAnYSBwdXNoX2JvdW5kZWQpIHdha2VuZXJfY2VsbCBsYXN0IGNsb3NlID0gb2JqZWN0XG4gIHZhbCBtdXRhYmxlIGNsb3NlZCA9IGZhbHNlXG5cbiAgbWV0aG9kIHNpemUgPVxuICAgIGluZm8ucHVzaGJfc2l6ZVxuXG4gIG1ldGhvZCByZXNpemUgc2l6ZSA9XG4gICAgaWYgc2l6ZSA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkx3dF9zdHJlYW0uYm91bmRlZF9wdXNoI3Jlc2l6ZVwiO1xuICAgIGluZm8ucHVzaGJfc2l6ZSA8LSBzaXplO1xuICAgIGlmIGluZm8ucHVzaGJfY291bnQgPCBpbmZvLnB1c2hiX3NpemUgJiYgaW5mby5wdXNoYl9wZW5kaW5nIDw+IE5vbmUgdGhlbiBiZWdpblxuICAgICAgaW5mby5wdXNoYl9jb3VudCA8LSBpbmZvLnB1c2hiX2NvdW50ICsgMTtcbiAgICAgIG5vdGlmeV9wdXNoZXIgaW5mbyBsYXN0XG4gICAgZW5kXG5cbiAgbWV0aG9kIHB1c2ggeCA9XG4gICAgaWYgY2xvc2VkIHRoZW5cbiAgICAgIEx3dC5mYWlsIENsb3NlZFxuICAgIGVsc2UgaWYgaW5mby5wdXNoYl9wZW5kaW5nIDw+IE5vbmUgdGhlblxuICAgICAgTHd0LmZhaWwgRnVsbFxuICAgIGVsc2UgaWYgaW5mby5wdXNoYl9jb3VudCA+PSBpbmZvLnB1c2hiX3NpemUgdGhlbiBiZWdpblxuICAgICAgaW5mby5wdXNoYl9wZW5kaW5nIDwtIFNvbWUgeDtcbiAgICAgIEx3dC5jYXRjaFxuICAgICAgICAoZnVuICgpIC0+IGluZm8ucHVzaGJfcHVzaF93YWl0ZXIpXG4gICAgICAgIChmdW4gZXhuIC0+XG4gICAgICAgICAgIG1hdGNoIGV4biB3aXRoXG4gICAgICAgICAgIHwgTHd0LkNhbmNlbGVkIC0+XG4gICAgICAgICAgICAgaW5mby5wdXNoYl9wZW5kaW5nIDwtIE5vbmU7XG4gICAgICAgICAgICAgbGV0IHdhaXRlciwgd2FrZW5lciA9IEx3dC50YXNrICgpIGluXG4gICAgICAgICAgICAgaW5mby5wdXNoYl9wdXNoX3dhaXRlciA8LSB3YWl0ZXI7XG4gICAgICAgICAgICAgaW5mby5wdXNoYl9wdXNoX3dha2VuZXIgPC0gd2FrZW5lcjtcbiAgICAgICAgICAgICBMd3QucmVyYWlzZSBleG5cbiAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgTHd0LnJlcmFpc2UgZXhuKVxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAoKiBQdXNoIHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIHF1ZXVlLiAqKVxuICAgICAgZW5xdWV1ZScgKFNvbWUgeCkgbGFzdDtcbiAgICAgIGluZm8ucHVzaGJfY291bnQgPC0gaW5mby5wdXNoYl9jb3VudCArIDE7XG4gICAgICAoKiBTZW5kIGEgc2lnbmFsIGlmIGF0IGxlYXN0IG9uZSB0aHJlYWQgaXMgd2FpdGluZyBmb3IgYSBuZXdcbiAgICAgICAgIGVsZW1lbnQuICopXG4gICAgICBpZiBpbmZvLnB1c2hiX3dhaXRpbmcgdGhlbiBiZWdpblxuICAgICAgICBpbmZvLnB1c2hiX3dhaXRpbmcgPC0gZmFsc2U7XG4gICAgICAgICgqIFVwZGF0ZSB0aHJlYWRzLiAqKVxuICAgICAgICBsZXQgb2xkX3dha2VuZXIgPSAhd2FrZW5lcl9jZWxsIGluXG4gICAgICAgIGxldCBuZXdfd2FpdGVyLCBuZXdfd2FrZW5lciA9IEx3dC53YWl0ICgpIGluXG4gICAgICAgIGluZm8ucHVzaGJfc2lnbmFsIDwtIG5ld193YWl0ZXI7XG4gICAgICAgIHdha2VuZXJfY2VsbCA6PSBuZXdfd2FrZW5lcjtcbiAgICAgICAgKCogU2lnbmFsIHRoYXQgYSBuZXcgdmFsdWUgaGFzIGJlZW4gcmVjZWl2ZWQuICopXG4gICAgICAgIEx3dC53YWtldXBfbGF0ZXIgb2xkX3dha2VuZXIgKClcbiAgICAgIGVuZDtcbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgIGVuZFxuXG4gIG1ldGhvZCBjbG9zZSA9XG4gICAgaWYgbm90IGNsb3NlZCB0aGVuIGJlZ2luXG4gICAgICBjbG9zZWQgPC0gdHJ1ZTtcbiAgICAgIGxldCBub2RlID0gIWxhc3QgYW5kIG5ld19sYXN0ID0gbmV3X25vZGUgKCkgaW5cbiAgICAgIG5vZGUuZGF0YSA8LSBOb25lO1xuICAgICAgbm9kZS5uZXh0IDwtIG5ld19sYXN0O1xuICAgICAgbGFzdCA6PSBuZXdfbGFzdDtcbiAgICAgIGlmIGluZm8ucHVzaGJfcGVuZGluZyA8PiBOb25lIHRoZW4gYmVnaW5cbiAgICAgICAgaW5mby5wdXNoYl9wZW5kaW5nIDwtIE5vbmU7XG4gICAgICAgIEx3dC53YWtldXBfbGF0ZXJfZXhuIGluZm8ucHVzaGJfcHVzaF93YWtlbmVyIENsb3NlZFxuICAgICAgZW5kO1xuICAgICAgKCogU2VuZCBhIHNpZ25hbCBpZiBhdCBsZWFzdCBvbmUgdGhyZWFkIGlzIHdhaXRpbmcgZm9yIGEgbmV3XG4gICAgICAgICBlbGVtZW50LiAqKVxuICAgICAgaWYgaW5mby5wdXNoYl93YWl0aW5nIHRoZW4gYmVnaW5cbiAgICAgICAgaW5mby5wdXNoYl93YWl0aW5nIDwtIGZhbHNlO1xuICAgICAgICBsZXQgb2xkX3dha2VuZXIgPSAhd2FrZW5lcl9jZWxsIGluXG4gICAgICAgICgqIFNpZ25hbCB0aGF0IGEgbmV3IHZhbHVlIGhhcyBiZWVuIHJlY2VpdmVkLiAqKVxuICAgICAgICBMd3Qud2FrZXVwX2xhdGVyIG9sZF93YWtlbmVyICgpXG4gICAgICBlbmQ7XG4gICAgICBMd3Qud2FrZXVwIGNsb3NlICgpO1xuICAgIGVuZFxuXG4gIG1ldGhvZCBjb3VudCA9XG4gICAgaW5mby5wdXNoYl9jb3VudFxuXG4gIG1ldGhvZCBibG9ja2VkID1cbiAgICBpbmZvLnB1c2hiX3BlbmRpbmcgPD4gTm9uZVxuXG4gIG1ldGhvZCBjbG9zZWQgPVxuICAgIGNsb3NlZFxuXG4gIG1ldGhvZCBzZXRfcmVmZXJlbmNlIDogJ2EuICdhIC0+IHVuaXQgPVxuICAgIGZ1biB4IC0+IGluZm8ucHVzaGJfZXh0ZXJuYWwgPC0gT2JqLnJlcHIgeFxuZW5kXG5cbmxldCBjcmVhdGVfYm91bmRlZCBzaXplID1cbiAgaWYgc2l6ZSA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkx3dF9zdHJlYW0uY3JlYXRlX2JvdW5kZWRcIjtcbiAgKCogQ3JlYXRlIHRoZSBzb3VyY2UgZm9yIG5vdGlmaWNhdGlvbnMgb2YgbmV3IGVsZW1lbnRzLiAqKVxuICBsZXQgaW5mbywgd2FrZW5lcl9jZWxsID1cbiAgICBsZXQgd2FpdGVyLCB3YWtlbmVyID0gTHd0LndhaXQgKCkgaW5cbiAgICBsZXQgcHVzaF93YWl0ZXIsIHB1c2hfd2FrZW5lciA9IEx3dC50YXNrICgpIGluXG4gICAgKHsgcHVzaGJfc2lnbmFsID0gd2FpdGVyO1xuICAgICAgIHB1c2hiX3dhaXRpbmcgPSBmYWxzZTtcbiAgICAgICBwdXNoYl9zaXplID0gc2l6ZTtcbiAgICAgICBwdXNoYl9jb3VudCA9IDA7XG4gICAgICAgcHVzaGJfcGVuZGluZyA9IE5vbmU7XG4gICAgICAgcHVzaGJfcHVzaF93YWl0ZXIgPSBwdXNoX3dhaXRlcjtcbiAgICAgICBwdXNoYl9wdXNoX3dha2VuZXIgPSBwdXNoX3dha2VuZXI7XG4gICAgICAgcHVzaGJfZXh0ZXJuYWwgPSBPYmoucmVwciAoKSB9LFxuICAgICByZWYgd2FrZW5lcilcbiAgaW5cbiAgbGV0IHQgPSBmcm9tX3NvdXJjZSAoUHVzaF9ib3VuZGVkIGluZm8pIGluXG4gICh0LCBuZXcgYm91bmRlZF9wdXNoX2ltcGwgaW5mbyB3YWtlbmVyX2NlbGwgdC5sYXN0IHQuY2xvc2UpXG5cbigqIFdhaXQgZm9yIGEgbmV3IGVsZW1lbnQgdG8gYmUgYWRkZWQgdG8gdGhlIHF1ZXVlIG9mIHBlbmRpbmcgZWxlbWVudFxuICAgb2YgdGhlIHN0cmVhbS4gKilcbmxldCBmZWVkIHMgPVxuICBtYXRjaCBzLnNvdXJjZSB3aXRoXG4gIHwgRnJvbSBmcm9tIC0+XG4gICAgKCogVGhlcmUgaXMgYWxyZWFkeSBhIHRocmVhZCBzdGFydGVkIHRvIGNyZWF0ZSBhIG5ldyBlbGVtZW50LFxuICAgICAgIHdhaXQgZm9yIHRoaXMgb25lIHRvIHRlcm1pbmF0ZS4gKilcbiAgICBpZiBMd3QuaXNfc2xlZXBpbmcgZnJvbS5mcm9tX3RocmVhZCB0aGVuXG4gICAgICBMd3QucHJvdGVjdGVkIGZyb20uZnJvbV90aHJlYWRcbiAgICBlbHNlIGJlZ2luXG4gICAgICAoKiBPdGhlcndpc2UgcmVxdWVzdCBhIG5ldyBlbGVtZW50LiAqKVxuICAgICAgbGV0IHRocmVhZCA9XG4gICAgICAgICgqIFRoZSBmdW5jdGlvbiBbZnJvbV9jcmVhdGVdIGNhbiByYWlzZSBhbiBleGNlcHRpb24gKHdpdGhcbiAgICAgICAgICAgW3JhaXNlXSwgcmF0aGVyIHRoYW4gcmV0dXJuaW5nIGEgZmFpbGVkIHByb21pc2Ugd2l0aFxuICAgICAgICAgICBbTHd0LmZhaWxdKS4gSW4gdGhpcyBjYXNlLCB3ZSBoYXZlIHRvIGNhdGNoIHRoZSBleGNlcHRpb25cbiAgICAgICAgICAgYW5kIHR1cm4gaXQgaW50byBhIHNhZmUgZmFpbGVkIHByb21pc2UuICopXG4gICAgICAgIEx3dC5jYXRjaFxuICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgIGZyb20uZnJvbV9jcmVhdGUgKCkgPj49IGZ1biB4IC0+XG4gICAgICAgICAgICAoKiBQdXNoIHRoZSBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlLiAqKVxuICAgICAgICAgICAgZW5xdWV1ZSB4IHM7XG4gICAgICAgICAgICBpZiB4ID0gTm9uZSB0aGVuIEx3dC53YWtldXAgcy5jbG9zZSAoKTtcbiAgICAgICAgICAgIEx3dC5yZXR1cm5fdW5pdClcbiAgICAgICAgICBMd3QucmVyYWlzZVxuICAgICAgaW5cbiAgICAgICgqIEFsbG93IG90aGVyIHRocmVhZHMgdG8gYWNjZXNzIHRoaXMgdGhyZWFkLiAqKVxuICAgICAgZnJvbS5mcm9tX3RocmVhZCA8LSB0aHJlYWQ7XG4gICAgICBMd3QucHJvdGVjdGVkIHRocmVhZFxuICAgIGVuZFxuICB8IEZyb21fZGlyZWN0IGYgLT5cbiAgICBsZXQgeCA9IGYgKCkgaW5cbiAgICAoKiBQdXNoIHRoZSBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlLiAqKVxuICAgIGVucXVldWUgeCBzO1xuICAgIGlmIHggPSBOb25lIHRoZW4gTHd0Lndha2V1cCBzLmNsb3NlICgpO1xuICAgIEx3dC5yZXR1cm5fdW5pdFxuICB8IFB1c2ggcHVzaCAtPlxuICAgIHB1c2gucHVzaF93YWl0aW5nIDwtIHRydWU7XG4gICAgTHd0LnByb3RlY3RlZCBwdXNoLnB1c2hfc2lnbmFsXG4gIHwgUHVzaF9ib3VuZGVkIHB1c2ggLT5cbiAgICBwdXNoLnB1c2hiX3dhaXRpbmcgPC0gdHJ1ZTtcbiAgICBMd3QucHJvdGVjdGVkIHB1c2gucHVzaGJfc2lnbmFsXG5cbigqIFJlbW92ZSBbbm9kZV0gZnJvbSB0aGUgdG9wIG9mIHRoZSBxdWV1ZSwgb3IgZG8gbm90aGluZyBpZiBpdCB3YXNcbiAgIGFscmVhZHkgY29uc3VtZWQuXG5cbiAgIFByZWNvbmRpdGlvbjogbm9kZS5kYXRhIDw+IE5vbmVcbiopXG5sZXQgY29uc3VtZSBzIG5vZGUgPVxuICBpZiBub2RlID09IHMubm9kZSB0aGVuIGJlZ2luXG4gICAgcy5ub2RlIDwtIG5vZGUubmV4dDtcbiAgICBtYXRjaCBzLnNvdXJjZSB3aXRoXG4gICAgfCBQdXNoX2JvdW5kZWQgaW5mbyAtPlxuICAgICAgaWYgaW5mby5wdXNoYl9wZW5kaW5nID0gTm9uZSB0aGVuXG4gICAgICAgIGluZm8ucHVzaGJfY291bnQgPC0gaW5mby5wdXNoYl9jb3VudCAtIDFcbiAgICAgIGVsc2VcbiAgICAgICAgbm90aWZ5X3B1c2hlciBpbmZvIHMubGFzdFxuICAgIHwgRnJvbSBfIHwgRnJvbV9kaXJlY3QgXyB8IFB1c2ggXyAtPlxuICAgICAgKClcbiAgZW5kXG5cbmxldCByZWMgcGVla19yZWMgcyBub2RlID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IHBlZWtfcmVjIHMgbm9kZVxuICBlbHNlXG4gICAgTHd0LnJldHVybiBub2RlLmRhdGFcblxubGV0IHBlZWsgcyA9IHBlZWtfcmVjIHMgcy5ub2RlXG5cbmxldCByZWMgbnBlZWtfcmVjIG5vZGUgYWNjIG4gcyA9XG4gIGlmIG4gPD0gMCB0aGVuXG4gICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuICBlbHNlIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBucGVla19yZWMgbm9kZSBhY2MgbiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBucGVla19yZWMgbm9kZS5uZXh0ICh4IDo6IGFjYykgKG4gLSAxKSBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MpXG5cbmxldCBucGVlayBuIHMgPSBucGVla19yZWMgcy5ub2RlIFtdIG4gc1xuXG5sZXQgcmVjIGdldF9yZWMgcyBub2RlID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGdldF9yZWMgcyBub2RlXG4gIGVsc2UgYmVnaW5cbiAgICBpZiBub2RlLmRhdGEgPD4gTm9uZSB0aGVuIGNvbnN1bWUgcyBub2RlO1xuICAgIEx3dC5yZXR1cm4gbm9kZS5kYXRhXG4gIGVuZFxuXG5sZXQgZ2V0IHMgPSBnZXRfcmVjIHMgcy5ub2RlXG5cbmxldCByZWMgZ2V0X2V4bl9yZWMgcyBub2RlID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIEx3dC50cnlfYmluZFxuICAgICAgKGZ1biAoKSAtPiBmZWVkIHMpXG4gICAgICAoZnVuICgpIC0+IGdldF9leG5fcmVjIHMgbm9kZSlcbiAgICAgIChmdW4gZXhuIC0+IEx3dC5yZXR1cm4gKFNvbWUgKFJlc3VsdC5FcnJvciBleG4pKSlcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHZhbHVlIC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIEx3dC5yZXR1cm4gKFNvbWUgKFJlc3VsdC5PayB2YWx1ZSkpXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcblxubGV0IHdyYXBfZXhuIHMgPSBmcm9tIChmdW4gKCkgLT4gZ2V0X2V4bl9yZWMgcyBzLm5vZGUpXG5cbmxldCByZWMgbmdldF9yZWMgbm9kZSBhY2MgbiBzID1cbiAgaWYgbiA8PSAwIHRoZW5cbiAgICBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MpXG4gIGVsc2UgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IG5nZXRfcmVjIG5vZGUgYWNjIG4gc1xuICBlbHNlXG4gICAgbWF0Y2ggcy5ub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIG5nZXRfcmVjIG5vZGUubmV4dCAoeCA6OiBhY2MpIChuIC0gMSkgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuXG5sZXQgbmdldCBuIHMgPSBuZ2V0X3JlYyBzLm5vZGUgW10gbiBzXG5cbmxldCByZWMgZ2V0X3doaWxlX3JlYyBub2RlIGFjYyBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZ2V0X3doaWxlX3JlYyBub2RlIGFjYyBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGxldCB0ZXN0ID0gZiB4IGluXG4gICAgICBpZiB0ZXN0IHRoZW4gYmVnaW5cbiAgICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICAgIGdldF93aGlsZV9yZWMgbm9kZS5uZXh0ICh4IDo6IGFjYykgZiBzXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MpXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MpXG5cbmxldCBnZXRfd2hpbGUgZiBzID0gZ2V0X3doaWxlX3JlYyBzLm5vZGUgW10gZiBzXG5cbmxldCByZWMgZ2V0X3doaWxlX3NfcmVjIG5vZGUgYWNjIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBnZXRfd2hpbGVfc19yZWMgbm9kZSBhY2MgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+IGJlZ2luXG4gICAgICAgIGYgeCA+Pj0gZnVuY3Rpb25cbiAgICAgICAgfCB0cnVlIC0+XG4gICAgICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICAgICAgZ2V0X3doaWxlX3NfcmVjIG5vZGUubmV4dCAoeCA6OiBhY2MpIGYgc1xuICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuICAgICAgZW5kXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MpXG5cbmxldCBnZXRfd2hpbGVfcyBmIHMgPSBnZXRfd2hpbGVfc19yZWMgcy5ub2RlIFtdIGYgc1xuXG5sZXQgcmVjIG5leHRfcmVjIHMgbm9kZSA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBuZXh0X3JlYyBzIG5vZGVcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgTHd0LnJldHVybiB4XG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QuZmFpbCBFbXB0eVxuXG5sZXQgbmV4dCBzID0gbmV4dF9yZWMgcyBzLm5vZGVcblxubGV0IHJlYyBsYXN0X25ld19yZWMgbm9kZSB4IHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgbGV0IHRocmVhZCA9IGZlZWQgcyBpblxuICAgIG1hdGNoIEx3dC5zdGF0ZSB0aHJlYWQgd2l0aFxuICAgIHwgTHd0LlJldHVybiBfIC0+XG4gICAgICBsYXN0X25ld19yZWMgbm9kZSB4IHNcbiAgICB8IEx3dC5GYWlsIGV4biAtPlxuICAgICAgTHd0LmZhaWwgZXhuXG4gICAgfCBMd3QuU2xlZXAgLT5cbiAgICAgIEx3dC5yZXR1cm4geFxuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBsYXN0X25ld19yZWMgbm9kZS5uZXh0IHggc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiB4XG5cbmxldCBsYXN0X25ldyBzID1cbiAgbGV0IG5vZGUgPSBzLm5vZGUgaW5cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGxldCB0aHJlYWQgPSBuZXh0IHMgaW5cbiAgICBtYXRjaCBMd3Quc3RhdGUgdGhyZWFkIHdpdGhcbiAgICB8IEx3dC5SZXR1cm4geCAtPlxuICAgICAgbGFzdF9uZXdfcmVjIG5vZGUgeCBzXG4gICAgfCBMd3QuRmFpbCBfIHwgTHd0LlNsZWVwIC0+XG4gICAgICB0aHJlYWRcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbGFzdF9uZXdfcmVjIG5vZGUubmV4dCB4IHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5mYWlsIEVtcHR5XG5cbmxldCByZWMgdG9fbGlzdF9yZWMgbm9kZSBhY2MgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiB0b19saXN0X3JlYyBub2RlIGFjYyBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIHRvX2xpc3RfcmVjIG5vZGUubmV4dCAoeCA6OiBhY2MpIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcblxubGV0IHRvX2xpc3QgcyA9IHRvX2xpc3RfcmVjIHMubm9kZSBbXSBzXG5cbmxldCByZWMgdG9fc3RyaW5nX3JlYyBub2RlIGJ1ZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IHRvX3N0cmluZ19yZWMgbm9kZSBidWYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmIHg7XG4gICAgICB0b19zdHJpbmdfcmVjIG5vZGUubmV4dCBidWYgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiAoQnVmZmVyLmNvbnRlbnRzIGJ1ZilcblxubGV0IHRvX3N0cmluZyBzID0gdG9fc3RyaW5nX3JlYyBzLm5vZGUgKEJ1ZmZlci5jcmVhdGUgMTI4KSBzXG5cbmxldCBqdW5rIHMgPVxuICBsZXQgbm9kZSA9IHMubm9kZSBpblxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuIGJlZ2luXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT5cbiAgICBpZiBub2RlLmRhdGEgPD4gTm9uZSB0aGVuIGNvbnN1bWUgcyBub2RlO1xuICAgIEx3dC5yZXR1cm5fdW5pdFxuICBlbmQgZWxzZSBiZWdpblxuICAgIGlmIG5vZGUuZGF0YSA8PiBOb25lIHRoZW4gY29uc3VtZSBzIG5vZGU7XG4gICAgTHd0LnJldHVybl91bml0XG4gIGVuZFxuXG5sZXQgcmVjIG5qdW5rX3JlYyBub2RlIG4gcyA9XG4gIGlmIG4gPD0gMCB0aGVuXG4gICAgTHd0LnJldHVybl91bml0XG4gIGVsc2UgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IG5qdW5rX3JlYyBub2RlIG4gc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgXyAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBuanVua19yZWMgbm9kZS5uZXh0IChuIC0gMSkgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl91bml0XG5cbmxldCBuanVuayBuIHMgPSBuanVua19yZWMgcy5ub2RlIG4gc1xuXG5sZXQgcmVjIGp1bmtfd2hpbGVfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGp1bmtfd2hpbGVfcmVjIG5vZGUgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBsZXQgdGVzdCA9IGYgeCBpblxuICAgICAgaWYgdGVzdCB0aGVuIGJlZ2luXG4gICAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgICBqdW5rX3doaWxlX3JlYyBub2RlLm5leHQgZiBzXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuXG5sZXQganVua193aGlsZSBmIHMgPSBqdW5rX3doaWxlX3JlYyBzLm5vZGUgZiBzXG5cbmxldCByZWMganVua193aGlsZV9zX3JlYyBub2RlIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBqdW5rX3doaWxlX3NfcmVjIG5vZGUgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+IGJlZ2luXG4gICAgICAgIGYgeCA+Pj0gZnVuY3Rpb25cbiAgICAgICAgfCB0cnVlIC0+XG4gICAgICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICAgICAganVua193aGlsZV9zX3JlYyBub2RlLm5leHQgZiBzXG4gICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICAgIGVuZFxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl91bml0XG5cbmxldCBqdW5rX3doaWxlX3MgZiBzID0ganVua193aGlsZV9zX3JlYyBzLm5vZGUgZiBzXG5cbmxldCByZWMganVua19hdmFpbGFibGVfcmVjIG5vZGUgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBsZXQgdGhyZWFkID0gZmVlZCBzIGluXG4gICAgbWF0Y2ggTHd0LnN0YXRlIHRocmVhZCB3aXRoXG4gICAgfCBMd3QuUmV0dXJuIF8gLT5cbiAgICAgIGp1bmtfYXZhaWxhYmxlX3JlYyBub2RlIHNcbiAgICB8IEx3dC5GYWlsIGV4biAtPlxuICAgICAgcmFpc2UgZXhuXG4gICAgfCBMd3QuU2xlZXAgLT5cbiAgICAgICgpXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSBfIC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGp1bmtfYXZhaWxhYmxlX3JlYyBub2RlLm5leHQgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgKClcblxubGV0IGp1bmtfYXZhaWxhYmxlIHMgPSBqdW5rX2F2YWlsYWJsZV9yZWMgcy5ub2RlIHNcblxubGV0IGp1bmtfb2xkIHMgPSBMd3QucmV0dXJuIChqdW5rX2F2YWlsYWJsZSBzKVxuXG5sZXQgcmVjIGdldF9hdmFpbGFibGVfcmVjIG5vZGUgYWNjIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgbGV0IHRocmVhZCA9IGZlZWQgcyBpblxuICAgIG1hdGNoIEx3dC5zdGF0ZSB0aHJlYWQgd2l0aFxuICAgIHwgTHd0LlJldHVybiBfIC0+XG4gICAgICBnZXRfYXZhaWxhYmxlX3JlYyBub2RlIGFjYyBzXG4gICAgfCBMd3QuRmFpbCBleG4gLT5cbiAgICAgIHJhaXNlIGV4blxuICAgIHwgTHd0LlNsZWVwIC0+XG4gICAgICBMaXN0LnJldiBhY2NcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgZ2V0X2F2YWlsYWJsZV9yZWMgbm9kZS5uZXh0ICh4IDo6IGFjYykgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTGlzdC5yZXYgYWNjXG5cbmxldCBnZXRfYXZhaWxhYmxlIHMgPSBnZXRfYXZhaWxhYmxlX3JlYyBzLm5vZGUgW10gc1xuXG5sZXQgcmVjIGdldF9hdmFpbGFibGVfdXBfdG9fcmVjIG5vZGUgYWNjIG4gcyA9XG4gIGlmIG4gPD0gMCB0aGVuXG4gICAgTGlzdC5yZXYgYWNjXG4gIGVsc2UgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGxldCB0aHJlYWQgPSBmZWVkIHMgaW5cbiAgICBtYXRjaCBMd3Quc3RhdGUgdGhyZWFkIHdpdGhcbiAgICB8IEx3dC5SZXR1cm4gXyAtPlxuICAgICAgZ2V0X2F2YWlsYWJsZV91cF90b19yZWMgbm9kZSBhY2MgbiBzXG4gICAgfCBMd3QuRmFpbCBleG4gLT5cbiAgICAgIHJhaXNlIGV4blxuICAgIHwgTHd0LlNsZWVwIC0+XG4gICAgICBMaXN0LnJldiBhY2NcbiAgZWxzZVxuICAgIG1hdGNoIHMubm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBnZXRfYXZhaWxhYmxlX3VwX3RvX3JlYyBub2RlLm5leHQgKHggOjogYWNjKSAobiAtIDEpIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIExpc3QucmV2IGFjY1xuXG5sZXQgZ2V0X2F2YWlsYWJsZV91cF90byBuIHMgPSBnZXRfYXZhaWxhYmxlX3VwX3RvX3JlYyBzLm5vZGUgW10gbiBzXG5cbmxldCByZWMgaXNfZW1wdHkgcyA9XG4gIGlmIHMubm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGlzX2VtcHR5IHNcbiAgZWxzZVxuICAgIEx3dC5yZXR1cm4gKHMubm9kZS5kYXRhID0gTm9uZSlcblxubGV0IG1hcCBmIHMgPVxuICBmcm9tIChmdW4gKCkgLT4gZ2V0IHMgPnw9IGZ1bmN0aW9uXG4gIHwgU29tZSB4IC0+XG4gICAgbGV0IHggPSBmIHggaW5cbiAgICBTb21lIHhcbiAgfCBOb25lIC0+XG4gICAgTm9uZSlcblxubGV0IG1hcF9zIGYgcyA9XG4gIGZyb20gKGZ1biAoKSAtPiBnZXQgcyA+Pj0gZnVuY3Rpb25cbiAgfCBTb21lIHggLT5cbiAgICBmIHggPnw9IChmdW4geCAtPiBTb21lIHgpXG4gIHwgTm9uZSAtPlxuICAgIEx3dC5yZXR1cm5fbm9uZSlcblxubGV0IGZpbHRlciBmIHMgPVxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIGxldCB0ID0gZ2V0IHMgaW5cbiAgICB0ID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSB4IC0+XG4gICAgICBsZXQgdGVzdCA9IGYgeCBpblxuICAgICAgaWYgdGVzdCB0aGVuXG4gICAgICAgIHRcbiAgICAgIGVsc2VcbiAgICAgICAgbmV4dCAoKVxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgZmlsdGVyX3MgZiBzID1cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBsZXQgdCA9IGdldCBzIGluXG4gICAgdCA+Pj0gZnVuY3Rpb25cbiAgICB8IFNvbWUgeCAtPiBiZWdpblxuICAgICAgICBmIHggPj49IGZ1bmN0aW9uXG4gICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgIHRcbiAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgIG5leHQgKClcbiAgICAgIGVuZFxuICAgIHwgTm9uZSAtPlxuICAgICAgdFxuICBpblxuICBmcm9tIG5leHRcblxubGV0IGZpbHRlcl9tYXAgZiBzID1cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBnZXQgcyA+Pj0gZnVuY3Rpb25cbiAgICB8IFNvbWUgeCAtPlxuICAgICAgbGV0IHggPSBmIHggaW5cbiAgICAgIChtYXRjaCB4IHdpdGhcbiAgICAgICB8IFNvbWUgXyAtPlxuICAgICAgICAgTHd0LnJldHVybiB4XG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBuZXh0ICgpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgZmlsdGVyX21hcF9zIGYgcyA9XG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgZ2V0IHMgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGxldCB0ID0gZiB4IGluXG4gICAgICAodCA+Pj0gZnVuY3Rpb25cbiAgICAgICB8IFNvbWUgXyAtPlxuICAgICAgICAgdFxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgbmV4dCAoKSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuICBpblxuICBmcm9tIG5leHRcblxubGV0IG1hcF9saXN0IGYgcyA9XG4gIGxldCBwZW5kaW5ncyA9IHJlZiBbXSBpblxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIG1hdGNoICFwZW5kaW5ncyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgKGdldCBzID4+PSBmdW5jdGlvblxuICAgICAgIHwgU29tZSB4IC0+XG4gICAgICAgICBsZXQgbCA9IGYgeCBpblxuICAgICAgICAgcGVuZGluZ3MgOj0gbDtcbiAgICAgICAgIG5leHQgKClcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIEx3dC5yZXR1cm5fbm9uZSlcbiAgICB8IHggOjogbCAtPlxuICAgICAgcGVuZGluZ3MgOj0gbDtcbiAgICAgIEx3dC5yZXR1cm4gKFNvbWUgeClcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBtYXBfbGlzdF9zIGYgcyA9XG4gIGxldCBwZW5kaW5ncyA9IHJlZiBbXSBpblxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIG1hdGNoICFwZW5kaW5ncyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgKGdldCBzID4+PSBmdW5jdGlvblxuICAgICAgIHwgU29tZSB4IC0+XG4gICAgICAgICBmIHggPj49IGZ1biBsIC0+XG4gICAgICAgICBwZW5kaW5ncyA6PSBsO1xuICAgICAgICAgbmV4dCAoKVxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgTHd0LnJldHVybl9ub25lKVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICBwZW5kaW5ncyA6PSBsO1xuICAgICAgTHd0LnJldHVybiAoU29tZSB4KVxuICBpblxuICBmcm9tIG5leHRcblxubGV0IGZsYXR0ZW4gcyA9XG4gIG1hcF9saXN0IChmdW4gbCAtPiBsKSBzXG5cbmxldCByZWMgZm9sZF9yZWMgbm9kZSBmIHMgYWNjID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGZvbGRfcmVjIG5vZGUgZiBzIGFjY1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBsZXQgYWNjID0gZiB4IGFjYyBpblxuICAgICAgZm9sZF9yZWMgbm9kZS5uZXh0IGYgcyBhY2NcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4gYWNjXG5cbmxldCBmb2xkIGYgcyBhY2MgPSBmb2xkX3JlYyBzLm5vZGUgZiBzIGFjY1xuXG5sZXQgcmVjIGZvbGRfc19yZWMgbm9kZSBmIHMgYWNjID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGZvbGRfc19yZWMgbm9kZSBmIHMgYWNjXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGYgeCBhY2MgPj49IGZ1biBhY2MgLT5cbiAgICAgIGZvbGRfc19yZWMgbm9kZS5uZXh0IGYgcyBhY2NcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4gYWNjXG5cbmxldCBmb2xkX3MgZiBzIGFjYyA9IGZvbGRfc19yZWMgcy5ub2RlIGYgcyBhY2NcblxubGV0IHJlYyBpdGVyX3JlYyBub2RlIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBpdGVyX3JlYyBub2RlIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBsZXQgKCkgPSBmIHggaW5cbiAgICAgIGl0ZXJfcmVjIG5vZGUubmV4dCBmIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuXG5sZXQgaXRlciBmIHMgPSBpdGVyX3JlYyBzLm5vZGUgZiBzXG5cbmxldCByZWMgaXRlcl9zX3JlYyBub2RlIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBpdGVyX3NfcmVjIG5vZGUgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGYgeCA+Pj0gZnVuICgpIC0+XG4gICAgICBpdGVyX3NfcmVjIG5vZGUubmV4dCBmIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuXG5sZXQgaXRlcl9zIGYgcyA9IGl0ZXJfc19yZWMgcy5ub2RlIGYgc1xuXG5sZXQgcmVjIGl0ZXJfcF9yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gaXRlcl9wX3JlYyBub2RlIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBsZXQgcmVzID0gZiB4IGluXG4gICAgICBsZXQgcmVzdCA9IGl0ZXJfcF9yZWMgbm9kZS5uZXh0IGYgcyBpblxuICAgICAgcmVzID4+PSBmdW4gKCkgLT4gcmVzdFxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl91bml0XG5cbmxldCBpdGVyX3AgZiBzID0gaXRlcl9wX3JlYyBzLm5vZGUgZiBzXG5cbmxldCBpdGVyX24gPyhtYXhfY29uY3VycmVuY3kgPSAxKSBmIHN0cmVhbSA9XG4gIGJlZ2luXG4gICAgaWYgbWF4X2NvbmN1cnJlbmN5IDw9IDAgdGhlblxuICAgICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgICBQcmludGYuc3ByaW50ZlxuICAgICAgICAgIFwiTHd0X3N0cmVhbS5pdGVyX246IG1heF9jb25jdXJyZW5jeSBtdXN0IGJlID4gMCwgJWQgZ2l2ZW5cIlxuICAgICAgICAgIG1heF9jb25jdXJyZW5jeVxuICAgICAgaW5cbiAgICAgIGludmFsaWRfYXJnIG1lc3NhZ2VcbiAgZW5kO1xuICBsZXQgcmVjIGxvb3AgcnVubmluZyBhdmFpbGFibGUgPVxuICAgIGJlZ2luXG4gICAgICBpZiBhdmFpbGFibGUgPiAwIHRoZW4gKFxuICAgICAgICBMd3QucmV0dXJuIChydW5uaW5nLCBhdmFpbGFibGUpXG4gICAgICApXG4gICAgICBlbHNlIChcbiAgICAgICAgTHd0Lm5jaG9vc2Vfc3BsaXQgcnVubmluZyA+Pj0gZnVuIChjb21wbGV0ZSwgcnVubmluZykgLT5cbiAgICAgICAgTHd0LnJldHVybiAocnVubmluZywgYXZhaWxhYmxlICsgTGlzdC5sZW5ndGggY29tcGxldGUpXG4gICAgICApXG4gICAgZW5kID4+PSBmdW4gKHJ1bm5pbmcsIGF2YWlsYWJsZSkgLT5cbiAgICBnZXQgc3RyZWFtID4+PSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LmpvaW4gcnVubmluZ1xuICAgIHwgU29tZSBlbHQgLT5cbiAgICAgIGxvb3AgKGYgZWx0IDo6IHJ1bm5pbmcpIChwcmVkIGF2YWlsYWJsZSlcbiAgaW5cbiAgbG9vcCBbXSBtYXhfY29uY3VycmVuY3lcblxubGV0IHJlYyBmaW5kX3JlYyBub2RlIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBmaW5kX3JlYyBub2RlIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCBhcyBvcHQgLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbGV0IHRlc3QgPSBmIHggaW5cbiAgICAgIGlmIHRlc3QgdGhlblxuICAgICAgICBMd3QucmV0dXJuIG9wdFxuICAgICAgZWxzZVxuICAgICAgICBmaW5kX3JlYyBub2RlLm5leHQgZiBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcblxubGV0IGZpbmQgZiBzID0gZmluZF9yZWMgcy5ub2RlIGYgc1xuXG5sZXQgcmVjIGZpbmRfc19yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZmluZF9zX3JlYyBub2RlIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCBhcyBvcHQgLT4gYmVnaW5cbiAgICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICAgIGYgeCA+Pj0gZnVuY3Rpb25cbiAgICAgICAgfCB0cnVlIC0+XG4gICAgICAgICAgTHd0LnJldHVybiBvcHRcbiAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgIGZpbmRfc19yZWMgbm9kZS5uZXh0IGYgc1xuICAgICAgZW5kXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcblxubGV0IGZpbmRfcyBmIHMgPSBmaW5kX3NfcmVjIHMubm9kZSBmIHNcblxubGV0IHJlYyBmaW5kX21hcF9yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZmluZF9tYXBfcmVjIG5vZGUgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGxldCB4ID0gZiB4IGluXG4gICAgICBpZiB4ID0gTm9uZSB0aGVuXG4gICAgICAgIGZpbmRfbWFwX3JlYyBub2RlLm5leHQgZiBzXG4gICAgICBlbHNlXG4gICAgICAgIEx3dC5yZXR1cm4geFxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG5cbmxldCBmaW5kX21hcCBmIHMgPSBmaW5kX21hcF9yZWMgcy5ub2RlIGYgc1xuXG5sZXQgcmVjIGZpbmRfbWFwX3NfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGZpbmRfbWFwX3NfcmVjIG5vZGUgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGxldCB0ID0gZiB4IGluXG4gICAgICAodCA+Pj0gZnVuY3Rpb25cbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIGZpbmRfbWFwX3NfcmVjIG5vZGUubmV4dCBmIHNcbiAgICAgICB8IFNvbWUgXyAtPlxuICAgICAgICAgdClcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuXG5sZXQgZmluZF9tYXBfcyBmIHMgPSBmaW5kX21hcF9zX3JlYyBzLm5vZGUgZiBzXG5cbmxldCBjb21iaW5lIHMxIHMyID1cbiAgbGV0IG5leHQgKCkgPVxuICAgIGxldCB0MSA9IGdldCBzMSBhbmQgdDIgPSBnZXQgczIgaW5cbiAgICB0MSA+Pj0gZnVuIG4xIC0+XG4gICAgdDIgPj49IGZ1biBuMiAtPlxuICAgIG1hdGNoIG4xLCBuMiB3aXRoXG4gICAgfCBTb21lIHgxLCBTb21lIHgyIC0+XG4gICAgICBMd3QucmV0dXJuIChTb21lKHgxLCB4MikpXG4gICAgfCBfIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBhcHBlbmQgczEgczIgPVxuICBsZXQgY3VycmVudF9zID0gcmVmIHMxIGluXG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgbGV0IHQgPSBnZXQgIWN1cnJlbnRfcyBpblxuICAgIHQgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lIF8gLT5cbiAgICAgIHRcbiAgICB8IE5vbmUgLT5cbiAgICAgIGlmICFjdXJyZW50X3MgPT0gczIgdGhlblxuICAgICAgICBMd3QucmV0dXJuX25vbmVcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgY3VycmVudF9zIDo9IHMyO1xuICAgICAgICBuZXh0ICgpXG4gICAgICBlbmRcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBjb25jYXQgc190b3AgPVxuICBsZXQgY3VycmVudF9zID0gcmVmIChmcm9tIChmdW4gKCkgLT4gTHd0LnJldHVybl9ub25lKSkgaW5cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBsZXQgdCA9IGdldCAhY3VycmVudF9zIGluXG4gICAgdCA+Pj0gZnVuY3Rpb25cbiAgICB8IFNvbWUgXyAtPlxuICAgICAgdFxuICAgIHwgTm9uZSAtPlxuICAgICAgZ2V0IHNfdG9wID4+PSBmdW5jdGlvblxuICAgICAgfCBTb21lIHMgLT5cbiAgICAgICAgY3VycmVudF9zIDo9IHM7XG4gICAgICAgIG5leHQgKClcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBMd3QucmV0dXJuX25vbmVcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBjaG9vc2Ugc3RyZWFtcyA9XG4gIGxldCBzb3VyY2UgcyA9IChzLCBnZXQgcyA+fD0gZnVuIHggLT4gKHMsIHgpKSBpblxuICBsZXQgc3RyZWFtcyA9IHJlZiAoTGlzdC5tYXAgc291cmNlIHN0cmVhbXMpIGluXG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgbWF0Y2ggIXN0cmVhbXMgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuICAgIHwgbCAtPlxuICAgICAgTHd0LmNob29zZSAoTGlzdC5tYXAgc25kIGwpID4+PSBmdW4gKHMsIHgpIC0+XG4gICAgICBsZXQgbCA9IExpc3QucmVtb3ZlX2Fzc3EgcyBsIGluXG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgIHN0cmVhbXMgOj0gc291cmNlIHMgOjogbDtcbiAgICAgICAgTHd0LnJldHVybiB4XG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgc3RyZWFtcyA6PSBsO1xuICAgICAgICBuZXh0ICgpXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgcGFyc2UgcyBmID1cbiAgKG1hdGNoIHMuc291cmNlIHdpdGhcbiAgIHwgUHVzaF9ib3VuZGVkIF8gLT4gaW52YWxpZF9hcmcgXCJMd3Rfc3RyZWFtLnBhcnNlXCJcbiAgIHwgRnJvbSBfIHwgRnJvbV9kaXJlY3QgXyB8IFB1c2ggXyAtPiAoKSk7XG4gIGxldCBub2RlID0gcy5ub2RlIGluXG4gIEx3dC5jYXRjaFxuICAgIChmdW4gKCkgLT4gZiBzKVxuICAgIChmdW4gZXhuIC0+XG4gICAgICAgcy5ub2RlIDwtIG5vZGU7XG4gICAgICAgTHd0LnJlcmFpc2UgZXhuKVxuXG5sZXQgaGV4ZHVtcCBzdHJlYW0gPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSA4MCBhbmQgbnVtID0gcmVmIDAgaW5cbiAgZnJvbSBiZWdpbiBmdW4gXyAtPlxuICAgIG5nZXQgMTYgc3RyZWFtID4+PSBmdW5jdGlvblxuICAgIHwgW10gLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuICAgIHwgbCAtPlxuICAgICAgQnVmZmVyLmNsZWFyIGJ1ZjtcbiAgICAgIFByaW50Zi5icHJpbnRmIGJ1ZiBcIiUwOHh8ICBcIiAhbnVtO1xuICAgICAgbnVtIDo9ICFudW0gKyAxNjtcbiAgICAgIGxldCByZWMgYnl0ZXMgcG9zID0gZnVuY3Rpb25cbiAgICAgICAgfCBbXSAtPlxuICAgICAgICAgIGJsYW5rcyBwb3NcbiAgICAgICAgfCB4IDo6IGwgLT5cbiAgICAgICAgICBpZiBwb3MgPSA4IHRoZW4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnICc7XG4gICAgICAgICAgUHJpbnRmLmJwcmludGYgYnVmIFwiJTAyeCBcIiAoQ2hhci5jb2RlIHgpO1xuICAgICAgICAgIGJ5dGVzIChwb3MgKyAxKSBsXG4gICAgICBhbmQgYmxhbmtzIHBvcyA9XG4gICAgICAgIGlmIHBvcyA8IDE2IHRoZW4gYmVnaW5cbiAgICAgICAgICBpZiBwb3MgPSA4IHRoZW5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBcIiAgICBcIlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBcIiAgIFwiO1xuICAgICAgICAgIGJsYW5rcyAocG9zICsgMSlcbiAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgYnl0ZXMgMCBsO1xuICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiIHxcIjtcbiAgICAgIExpc3QuaXRlciAoZnVuIGNoIC0+IEJ1ZmZlci5hZGRfY2hhciBidWYgKGlmIGNoID49ICdcXHgyMCcgJiYgY2ggPD0gJ1xceDdlJyB0aGVuIGNoIGVsc2UgJy4nKSkgbDtcbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJ3wnO1xuICAgICAgTHd0LnJldHVybiAoU29tZShCdWZmZXIuY29udGVudHMgYnVmKSlcbiAgZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDQzNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkx3dCIsIkFzc2VydF9mYWlsdXJlIiwicmV0dXJuIiwieCIsImZhaWwiLCJlIiwibGlmdCIsIm9rIiwieSIsImVycm9yIiwibWFwIiwicGFyYW0iLCJtYXBfZXJyb3IiLCJtYXBfZXJyIiwiY2F0Y2giLCJnZXRfZXhuIiwic3ltYm9sX2JpbmQiLCJiaW5kX2Vycm9yIiwiYmluZF9sd3QiLCJiaW5kX3Jlc3VsdCIsImJpbmRfbHd0X2Vycm9yIiwiYmluZF9sd3RfZXJyIiwiYm90aCIsImEiLCJiIiwicyIsInNldF9vbmNlIiwibWF0Y2giLCJpdGVyIiwiciIsIml0ZXJfZXJyb3IiLCJzeW1ib2wiLCJ0IiwiYmluZCIsIk9wZW5fb25fcmhzIiwiTGV0X3N5bnRheCIsImxldCIsIlN5bnRheCIsIkx3dF9yZXN1bHQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2pzZW8vLm9wYW0vNC4xMy4xL2xpYi9sd3QvbHd0X3Jlc3VsdC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsWUFBQUMsU0FBQUMsR0NTZSxpQ0FBaUI7QUFBQSxZQUFBQyxLQUFBQyxH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aEI7QUFBQTtBQUFBO0FBQUEsc0JBQUFsQjtBQUFBQSxjQUNFLG1CQUVlO0FBQUEsa0JBQUFSLElBRmY7QUFBQSxjQUNZLHVCQUNtQjtBQUFBO0FBQUE7QUFBQSxZQUFBMkIsV0FBQW5DLEdBQUFrQztBQUFBQSxJQUdqQztBQUFBO0FBQUE7QUFBQSxzQkFBQWxCO0FBQUFBLGNBQ0UsbUJBRVk7QUFBQSxrQkFBQU4sSUFGWjtBQUFBLGNBQ2UsdUJBQ2E7QUFBQTtBQUFBO0FBQUEsWUFBQTBCLE9BQUExQixHQUFBVixHQUlkLGdCQUFPO0FBQUEsWUFBQWUsTUFBQXNCLEdBQUFyQyxHQU1OLGdCQUFPO0FBQUEsWUFBQXNDLEtBQUFELEdBQUFyQyxHQUNOLHdCQUFRO0FBQUE7QUFBQSxJQUFBdUMsY0RuSDVCO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFBLGVBQUE7QUFBQSxZQUFBQyxNQUFBakMsR0FBQVIsR0M4SG1CLGdCQUFPO0FBQUE7QUFBQSxJQUFBMEMsU0Q5SDFCO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cbigqKiBNb2R1bGUgW0x3dF9yZXN1bHRdOiBleHBsaWNpdCBlcnJvciBoYW5kbGluZyAqKVxuXG5vcGVuIFJlc3VsdFxuXG50eXBlICgrJ2EsICsnYikgdCA9ICgnYSwgJ2IpIFJlc3VsdC50IEx3dC50XG5cbmxldCByZXR1cm4geCA9IEx3dC5yZXR1cm4gKE9rIHgpXG5sZXQgZmFpbCBlID0gTHd0LnJldHVybiAoRXJyb3IgZSlcblxubGV0IGxpZnQgPSBMd3QucmV0dXJuXG5sZXQgb2sgeCA9IEx3dC5tYXAgKGZ1biB5IC0+IE9rIHkpIHhcbmxldCBlcnJvciB4ID0gTHd0Lm1hcCAoZnVuIHkgLT4gRXJyb3IgeSkgeFxuXG5sZXQgbWFwIGYgZSA9XG4gIEx3dC5tYXBcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRXJyb3IgZSAtPiBFcnJvciBlXG4gICAgICB8IE9rIHggLT4gT2sgKGYgeCkpXG4gICAgZVxuXG5sZXQgbWFwX2Vycm9yIGYgZSA9XG4gIEx3dC5tYXBcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRXJyb3IgZSAtPiBFcnJvciAoZiBlKVxuICAgICAgfCBPayB4IC0+IE9rIHgpXG4gICAgZVxubGV0IG1hcF9lcnIgZiBlID0gbWFwX2Vycm9yIGYgZVxuXG5sZXQgY2F0Y2ggZSA9XG4gIEx3dC5jYXRjaFxuICAgIChmdW4gKCkgLT4gb2sgKGUgKCkpKVxuICAgIGZhaWxcblxubGV0IGdldF9leG4gZSA9XG4gIEx3dC5iaW5kIGVcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgT2sgeCAtPiBMd3QucmV0dXJuIHhcbiAgICAgIHwgRXJyb3IgZSAtPiBMd3QuZmFpbCBlKVxuXG5sZXQgYmluZCBlIGYgPVxuICBMd3QuYmluZCBlXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIGUgLT4gTHd0LnJldHVybiAoRXJyb3IgZSlcbiAgICAgIHwgT2sgeCAtPiBmIHgpXG4gICAgICBcbmxldCBiaW5kX2Vycm9yIGUgZiA9XG4gIEx3dC5iaW5kIGVcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRXJyb3IgZSAtPiBmIGVcbiAgICAgIHwgT2sgeCAtPiBMd3QucmV0dXJuIChPayB4KSlcbiAgICAgIFxubGV0IGJpbmRfbHd0IGUgZiA9XG4gIEx3dC5iaW5kIGVcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgT2sgeCAtPiBvayAoZiB4KVxuICAgICAgfCBFcnJvciBlIC0+IGZhaWwgZSlcblxubGV0IGJpbmRfcmVzdWx0IGUgZiA9XG4gIEx3dC5tYXBcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRXJyb3IgZSAtPiBFcnJvciBlXG4gICAgICB8IE9rIHggLT4gZiB4KVxuICAgIGVcblxubGV0IGJpbmRfbHd0X2Vycm9yIGUgZiA9XG4gIEx3dC5iaW5kIGVcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRXJyb3IgZSAtPiBMd3QuYmluZCAoZiBlKSBmYWlsXG4gICAgICB8IE9rIHggLT4gcmV0dXJuIHgpXG5sZXQgYmluZF9sd3RfZXJyIGUgZiA9IGJpbmRfbHd0X2Vycm9yIGUgZlxuXG5sZXQgYm90aCBhIGIgPVxuICBsZXQgcyA9IHJlZiBOb25lIGluXG4gIGxldCBzZXRfb25jZSBlID1cbiAgICBtYXRjaCAhcyB3aXRoXG4gICAgfCBOb25lIC0+IHM6PSBTb21lIGVcbiAgICB8IFNvbWUgXyAtPiAoKVxuICBpblxuICBsZXQgKGEsYikgPSBtYXBfZXJyb3Igc2V0X29uY2UgYSxtYXBfZXJyb3Igc2V0X29uY2UgYiBpblxuICBsZXQgc29tZV9hc3NlcnQgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IFNvbWUgZSAtPiBFcnJvciBlXG4gIGluXG4gIEx3dC5tYXBcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgT2sgeCwgT2sgeSAtPiBPayAoeCx5KVxuICAgICAgfCBFcnJvciBfLCBPayBfXG4gICAgICB8IE9rIF8sRXJyb3IgX1xuICAgICAgfCBFcnJvciBfLCBFcnJvciBfIC0+IHNvbWVfYXNzZXJ0ICFzKVxuICAgIChMd3QuYm90aCBhIGIpXG5cbmxldCBpdGVyIGYgciA9XG4gIEx3dC5iaW5kIHJcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgT2sgeCAtPiBmIHhcbiAgICAgIHwgRXJyb3IgXyAtPiBMd3QucmV0dXJuX3VuaXQpXG5cbmxldCBpdGVyX2Vycm9yIGYgciA9XG4gIEx3dC5iaW5kIHJcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRXJyb3IgZSAtPiBmIGVcbiAgICAgIHwgT2sgXyAtPiBMd3QucmV0dXJuX3VuaXQpXG5cbm1vZHVsZSBJbmZpeCA9IHN0cnVjdFxuICBsZXQgKD4+PSkgPSBiaW5kXG4gIGxldCAoPnw9KSBlIGYgPSBtYXAgZiBlXG5lbmRcblxubW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IG1hcCB0IH5mID0gbWFwIGYgdFxuICAgIGxldCBiaW5kIHQgfmYgPSBiaW5kIHQgZlxuICAgIGxldCBib3RoID0gYm90aFxuICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgU3ludGF4ID0gc3RydWN0XG4gIGxldCAobGV0KikgPSBiaW5kXG4gIGxldCAoYW5kKikgPSBib3RoXG5cbiAgbGV0IChsZXQrKSB4IGYgPSBtYXAgZiB4XG4gIGxldCAoYW5kKykgPSBib3RoXG5lbmRcblxuaW5jbHVkZSBJbmZpeFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ2NDUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHd0LmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJBc3NlcnRfZmFpbHVyZSIsIlN0ZGxpYl9MaXN0IiwiTWFrZSIsIk9yZCIsImxpbmsiLCJ0MSIsInQyIiwiYzIiLCJyMiIsIngyIiwiYzEiLCJyMSIsIngxIiwiYyIsImlucyIsInQiLCJ0cyIsInIiLCJpc19lbXB0eSIsImFkZCIsIngiLCJ1bmlvbiIsInRzMiIsInRzMSIsImZpbmRfbWluIiwicGFyYW0iLCJsb29rdXBfbWluIiwicmVzdWx0IiwiZ2V0X21pbiIsIm1hdGNoIiwicmVtb3ZlX21pbiIsInNpemUiLCJsIiwicyIsInRsIiwiTHd0X3BxdWV1ZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvanNlby8ub3BhbS80LjEzLjEvbGliL2x3dC9sd3RfcHF1ZXVlLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBO0FBQUEsWUFBQUMsS0FBQUM7QUFBQUEsYUFBQUMsS0FBQUMsSUFBQUM7QUFBQUE7QUFBQUEsTUFBQUMsS0NrQ1c7QUFBQSxNQUFBQyxLQUFBO0FBQUEsTUFBQUMsS0FBQTtBQUFBLE1BQUFDLEtBQUE7QUFBQSxNQUFBQyxLQUFBO0FBQUEsTUFBQUMsS0FBQTtBQUFBLE1BQUFDLElBQ0M7QUFBQSxLQUNSO0FBQUE7QUFBQSwrQ0FBc0U7QUFBQTtBQUFBLGFBQUFDLElBQUFDLEdBQUFDO0FBQUFBLFNBQUFELE1BQzVELEdBQUFDLE9BQUE7QUFBQTtBQUFBLGlCQUdSO0FBQUEsVUFBQUQsTUFIUSxTQUFBRSxNQUpILFFBQUFBLElBQUE7QUFBQSxNQVFvQixZQUN6QjtBQUFBLFVBQUFELE9BRHlCLFNBQUFELE1BR3JCO0FBQUEsTUFBVztBQUFBO0FBQUE7QUFBQSxJQUFHO0FBQUEsYUFBQUcsU0FBQUYsSUFHSix3QkFBTztBQUFBLGFBQUFHLElBQUFDLEdBQUFKLElBQ1YsNEJBQXdCO0FBQUEsYUFBQUssTUFBQUwsTUFBQUE7QUFBQUEsS0FFckMsV0FDYTtBQUFBLEtBRGIsU0FFYTtBQUFBO0FBQUEsTUFBQU0sTUFGYjtBQUFBLE1BQUFoQixLQUFBO0FBQUEsTUFBQWlCLE1BQUE7QUFBQSxNQUFBbEIsS0FBQTtBQUFBLE1BQUFZLElBakJPO0FBQUEsTUFBQUEsTUFBQTtBQUFBLEtBcUJLLFlBQXNCLHdDQUFtQjtBQUFBLFNBQUFBLE1BckI5QyxPQUFBQSxNQUFBO0FBQUEsS0FzQlUsY0FBc0Isd0NBQW1CO0FBQUEsZUFDbEM7QUFBQSxLQUFiLE9BQVksSUFBWixrQkFBNEI7QUFBQTtBQUFBLGFBQUFPLFNBQUFDO0FBQUFBLEtBR3ZDLFlBQ1c7QUFBQSxTQUFBVixJQURYO0FBQUEsd0JBQUFLLE1BM0JPLE1BQW1CO0FBQUE7QUFBQSxNQUFBSixLQTJCMUI7QUFBQSxNQUFBSSxJQUlVO0FBQUEsTUFBQUEsTUEvQkg7QUFBQSxNQUFBUCxJQWdDRztBQUFBLEtBQ1IsV0FBMEI7QUFBQSxTQUFBTyxNQWpDckI7QUFBQSxLQUFtQjtBQUFBLElBaUNHO0FBQUEsYUFBQU0sV0FBQUQ7QUFBQUEsS0FHN0IsWUFDVztBQUFBLFNBQUFWLElBRFg7QUFBQSx3QkFBQUssTUFwQ08sTUFzQ2lCO0FBQUEsU0FBQUosS0FGeEIsVUFBQVcsU0FJUTtBQUFBLEtBQWEsYUFDVDtBQUFBLFNBQUFQLElBRFMsV0FBQUEsTUF4Q2QsTUFBQVAsSUEyQ0s7QUFBQSxLQUNSLFdBQWlDO0FBQUEsU0FBQU8sTUE1QzlCO0FBQUEsS0E0Q3dCO0FBQUEsSUFBWTtBQUFBLGFBQUFRLFFBQUFIO0FBQUFBLEtBRzNDO0FBQUEsTUFDVztBQUFBLFNBQUFWLElBRFg7QUFBQSxvQkFFVztBQUFBO0FBQUEsTUFBQUMsS0FGWDtBQUFBLE1BQUFhLFFBSWtCO0FBQUEsTUFBQWIsT0FBVTtBQUFBLE1BQUFELE1BQUE7QUFBQSxNQUFBSyxJQW5EckI7QUFBQSxNQUFBQSxNQUFBO0FBQUEsTUFBQVAsSUFvREc7QUFBQSxLQUNSLG1EQUF1QztBQUFBO0FBQUEsYUFBQWlCLFdBQUFkO0FBQUFBLEtBR3pDLFNBQ1E7QUFBQSxlQUVxQixhQUFBQSxPQUFVLFFBQUFILElBQUE7QUFBQSxLQUMvQixPQUFZLE1BQVosb0NBQWU7QUFBQTtBQUFBLGFBQUFrQixLQUFBQztBQUFBQSxLQUl2QjtBQUFBO0FBQUEsdUJBQUFDLEdBQUFsQjtBQUFBQSxtQkFBQW1CLEtBRGE7QUFBQSxlQUFzQixpQ0FDTTtBQUFBO0FBQUE7QUFBQSxnQkFBSztBQUFBO0FBQUEsSURoR2xEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FBQUMsYUFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG5zaWdcbiAgdHlwZSB0XG4gIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG5lbmRcblxubW9kdWxlIHR5cGUgUyA9XG5zaWdcbiAgdHlwZSBlbHRcbiAgdHlwZSB0XG4gIHZhbCBlbXB0eTogdFxuICB2YWwgaXNfZW1wdHk6IHQgLT4gYm9vbFxuICB2YWwgYWRkOiBlbHQgLT4gdCAtPiB0XG4gIHZhbCB1bmlvbjogdCAtPiB0IC0+IHRcbiAgdmFsIGZpbmRfbWluOiB0IC0+IGVsdFxuICB2YWwgbG9va3VwX21pbjogdCAtPiBlbHQgb3B0aW9uXG4gIHZhbCByZW1vdmVfbWluOiB0IC0+IHRcbiAgdmFsIHNpemU6IHQgLT4gaW50XG5lbmRcblxubW9kdWxlIE1ha2UoT3JkOiBPcmRlcmVkVHlwZSkgOiAoUyB3aXRoIHR5cGUgZWx0ID0gT3JkLnQpID1cbnN0cnVjdFxuICB0eXBlIGVsdCA9IE9yZC50XG5cbiAgdHlwZSB0ID0gdHJlZSBsaXN0XG4gIGFuZCB0cmVlID0gTm9kZSBvZiBlbHQgKiBpbnQgKiB0cmVlIGxpc3RcblxuICBsZXQgcm9vdCAoTm9kZSAoeCwgXywgXykpID0geFxuICBsZXQgcmFuayAoTm9kZSAoXywgciwgXykpID0gclxuICBsZXQgbGluayAoTm9kZSAoeDEsIHIxLCBjMSkgYXMgdDEpIChOb2RlICh4MiwgcjIsIGMyKSBhcyB0MikgPVxuICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeDEgeDIgaW5cbiAgICBpZiBjIDw9IDAgdGhlbiBOb2RlICh4MSwgcjEgKyAxLCB0Mjo6YzEpIGVsc2UgTm9kZSh4MiwgcjIgKyAxLCB0MTo6YzIpXG4gIGxldCByZWMgaW5zIHQgPVxuICAgIGZ1bmN0aW9uXG4gICAgICBbXSAgICAgLT5cbiAgICAgIFt0XVxuICAgIHwgKHQnOjpfKSBhcyB0cyB3aGVuIHJhbmsgdCA8IHJhbmsgdCcgLT5cbiAgICAgIHQ6OnRzXG4gICAgfCB0Jzo6dHMgLT5cbiAgICAgIGlucyAobGluayB0IHQnKSB0c1xuXG4gIGxldCBlbXB0eSA9IFtdXG4gIGxldCBpc19lbXB0eSB0cyA9IHRzID0gW11cbiAgbGV0IGFkZCB4IHRzID0gaW5zIChOb2RlICh4LCAwLCBbXSkpIHRzXG4gIGxldCByZWMgdW5pb24gdHMgdHMnID1cbiAgICBtYXRjaCB0cywgdHMnIHdpdGhcbiAgICAgIChbXSwgXykgLT4gdHMnXG4gICAgfCAoXywgW10pIC0+IHRzXG4gICAgfCAodDE6OnRzMSwgdDI6OnRzMikgIC0+XG4gICAgICBpZiByYW5rIHQxIDwgcmFuayB0MiB0aGVuIHQxIDo6IHVuaW9uIHRzMSAodDI6OnRzMilcbiAgICAgIGVsc2UgaWYgcmFuayB0MiA8IHJhbmsgdDEgdGhlbiB0MiA6OiB1bmlvbiAodDE6OnRzMSkgdHMyXG4gICAgICBlbHNlIGlucyAobGluayB0MSB0MikgKHVuaW9uIHRzMSB0czIpXG5cbiAgbGV0IHJlYyBmaW5kX21pbiA9XG4gICAgZnVuY3Rpb25cbiAgICAgIFtdICAgIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgIHwgW3RdICAgLT4gcm9vdCB0XG4gICAgfCB0Ojp0cyAtPlxuICAgICAgbGV0IHggPSBmaW5kX21pbiB0cyBpblxuICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSAocm9vdCB0KSB4IGluXG4gICAgICBpZiBjIDwgMCB0aGVuIHJvb3QgdCBlbHNlIHhcblxuICBsZXQgcmVjIGxvb2t1cF9taW4gPVxuICAgIGZ1bmN0aW9uXG4gICAgfCBbXSAgICAtPiBOb25lXG4gICAgfCBbdF0gICAtPiBTb21lIChyb290IHQpXG4gICAgfCB0Ojp0cyAtPlxuICAgICAgbWF0Y2ggbG9va3VwX21pbiB0cyB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHggYXMgcmVzdWx0IC0+XG4gICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgKHJvb3QgdCkgeCBpblxuICAgICAgICBpZiBjIDwgMCB0aGVuIFNvbWUgKHJvb3QgdCkgZWxzZSByZXN1bHRcblxuICBsZXQgcmVjIGdldF9taW4gPVxuICAgIGZ1bmN0aW9uXG4gICAgICBbXSAgICAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IFt0XSAgIC0+ICh0LCBbXSlcbiAgICB8IHQ6OnRzIC0+XG4gICAgICBsZXQgKHQnLCB0cycpID0gZ2V0X21pbiB0cyBpblxuICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSAocm9vdCB0KSAocm9vdCB0JykgaW5cbiAgICAgIGlmIGMgPCAwIHRoZW4gKHQsIHRzKSBlbHNlICh0JywgdDo6dHMnKVxuXG4gIGxldCByZW1vdmVfbWluID1cbiAgICBmdW5jdGlvblxuICAgICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgfCB0cyAtPlxuICAgICAgbGV0IChOb2RlIChfLCBfLCBjKSwgdHMpID0gZ2V0X21pbiB0cyBpblxuICAgICAgdW5pb24gKExpc3QucmV2IGMpIHRzXG5cbiAgbGV0IHJlYyBzaXplIGwgPVxuICAgIGxldCBzaXpldHJlZSAoTm9kZSAoXyxfLHRsKSkgPSAxICsgc2l6ZSB0bCBpblxuICAgIExpc3QuZm9sZF9sZWZ0IChmdW4gcyB0IC0+IHMgKyBzaXpldHJlZSB0KSAwIGxcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ3ODYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHd0LmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJMd3QiLCJTdGRsaWIiLCJTdGRsaWJfTGlzdCIsInRhaWxfcmVjdXJzaXZlX21hcCIsImwiLCJ0YWlsX3JlY3Vyc2l2ZV9tYXBpX3JldiIsImFjYyIsImkiLCJwYXJhbSIsInRsIiwiaGQiLCJpdGVyX3MiLCJ4IiwiaXRlcl9wIiwidHMiLCJpdGVyaV9zIiwiaXRlcmlfcCIsIm1hcF9zIiwiaW5uZXIiLCJyIiwiY29sbGVjdF9yZXYiLCJ0IiwibWFwX3AiLCJmaWx0ZXJfbWFwX3MiLCJ2IiwiZmlsdGVyX21hcF9wIiwiY29sbGVjdF9vcHRpb25hbF9yZXYiLCJtYXBpX3MiLCJtYXBpX3AiLCJyZXZfbWFwX2FwcGVuZF9zIiwicmV2X21hcF9zIiwicmV2X21hcF9wIiwiZm9sZF9sZWZ0X3MiLCJmb2xkX3JpZ2h0X3MiLCJhIiwiZm9yX2FsbF9zIiwiZm9yX2FsbF9wIiwiYmwiLCJleGlzdHNfcyIsImV4aXN0c19wIiwiZmluZF9zIiwib3B0aW9uYWxpemUiLCJiIiwiZmlsdGVyX3MiLCJmaWx0ZXJfcCIsInBhcnRpdGlvbl9zIiwiYWNjMSIsImFjYzIiLCJwYXJ0aXRpb25fcCIsImciLCJncm91cDEiLCJncm91cDIiLCJMd3RfbGlzdCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvanNlby8ub3BhbS80LjEzLjEvbGliL2x3dC9sd3RfbGlzdC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFB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LFdBQVUsb0NBQXdDO0FBQUE7QUFBQSxZQUFBQyxTQUFBaEQsR0FBQVM7QUFBQUEsSUFHdEMsa0NBQWhCLGdDQUFrQjtBQUFBO0FBQUEsWUFBQXdDLFNBQUFqRCxHQUFBUztBQUFBQSxJQUdELGtDQUFoQixnQ0FBa0I7QUFBQTtBQUFBLFlBQUF5QyxZQUFBbEQsR0FBQVM7QUFBQUEsYUFBQWMsTUFBQTRCLE1BQUFDLE1BQUF2QztBQUFBQSxLQUdsQjtBQUFBLFVBQUFDLEtBQUEsVUFBQUMsS0FBQSxnQkFFQTtBQUFBLE1BQWM7QUFBQTtBQUFBO0FBQUEsd0JBQUFnQztBQUFBQSxnQkFDdEI7QUFBQSwwQkFDRTtBQUFBLDBCQUVBLDhCQUF3QjtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBTFM7QUFBQSxZQUFmO0FBQUEsS0FBYSw4QkFLUDtBQUFBO0FBQUEsSUFFaEMscUJBQWE7QUFBQTtBQUFBLFlBQUFNLFlBQUFyRCxHQUFBUztBQUFBQSxhQUFBNkMsRUFBQXJDO0FBQUFBLFNBQUEsTUFHSDtBQUFBLEtBQWE7QUFBQTtBQUFBO0FBQUEsdUJBQUE4QixHQUFjLG9DQUFpQjtBQUFBO0FBQUEsY0FDdEQ7QUFBQSxJQUFTO0FBQUE7QUFBQTtBQUFBLHNCQUFBakM7QUFBQUE7QUFBQUEsZUFBQXlDO0FBQUFBLGlCQUNJO0FBQUEsaUNEOU1mO0FBQUEsbUJDOE15QztBQUFBLG9ERDlNekM7QUFBQSxlQUFBQztBQUFBQSxpQkNnTkk7QUFBQSxpQ0RoTko7QUFBQSxtQkNnTjhCO0FBQUEsK0NBQUF2QyxHQUFzQixnQkFBWTtBQUFBLGNBQzlELDhDQUEyQjtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUF3QztBQUFBQSxNRGpON0IiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5cblxuKCogQSBzdXJ2ZXkgYW5kIG1lYXN1cmVtZW50cyBvZiBtb3JlIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbnMgY2FuIGJlIGZvdW5kIGF0OlxuXG4gICAgaHR0cHM6Ly9qc3Rob21hcy5naXRodWIuaW8vbWFwLWNvbXBhcmlzb24uaHRtbFxuXG4gICBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvcHVsbC8zNDcuICopXG5sZXQgdGFpbF9yZWN1cnNpdmVfbWFwIGYgbCA9XG4gIExpc3QucmV2IChMaXN0LnJldl9tYXAgZiBsKVxuXG5sZXQgdGFpbF9yZWN1cnNpdmVfbWFwaV9yZXYgZiBsID1cbiAgbGV0IHJlYyBpbm5lciBhY2MgaSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IGhkOjp0bCAtPiAoaW5uZXIgW0BvY2FtbC50YWlsY2FsbF0pICgoZiBpIGhkKTo6YWNjKSAoaSArIDEpIHRsXG4gIGluXG4gIGlubmVyIFtdIDAgbFxuXG5vcGVuIEx3dC5JbmZpeFxuXG5sZXQgcmVjIGl0ZXJfcyBmIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIEx3dC5yZXR1cm5fdW5pdFxuICB8IHggOjogbCAtPlxuICAgIEx3dC5hcHBseSBmIHggPj49IGZ1biAoKSAtPlxuICAgIGl0ZXJfcyBmIGxcblxubGV0IGl0ZXJfcCBmIGwgPVxuICBsZXQgdHMgPSBMaXN0LnJldl9tYXAgKEx3dC5hcHBseSBmKSBsIGluXG4gIEx3dC5qb2luIHRzXG5cbmxldCByZWMgaXRlcmlfcyBpIGYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgTHd0LnJldHVybl91bml0XG4gIHwgeCA6OiBsIC0+XG4gICAgTHd0LmFwcGx5IChmIGkpIHggPj49IGZ1biAoKSAtPlxuICAgIGl0ZXJpX3MgKGkgKyAxKSBmIGxcblxubGV0IGl0ZXJpX3MgZiBsID0gaXRlcmlfcyAwIGYgbFxuXG5sZXQgaXRlcmlfcCBmIGwgPVxuICBsZXQgZicgaSA9IEx3dC5hcHBseSAoZiBpKSBpblxuICBsZXQgdHMgPSB0YWlsX3JlY3Vyc2l2ZV9tYXBpX3JldiBmJyBsIGluXG4gIEx3dC5qb2luIHRzXG5cbmxldCBtYXBfcyBmIGwgPVxuICBsZXQgcmVjIGlubmVyIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBMaXN0LnJldiBhY2MgfD4gTHd0LnJldHVyblxuICAgIHwgaGQ6OnRsIC0+XG4gICAgICBMd3QuYXBwbHkgZiBoZCA+Pj0gZnVuIHIgLT5cbiAgICAgIChpbm5lciBbQG9jYW1sLnRhaWxjYWxsXSkgKHI6OmFjYykgdGxcbiAgaW5cbiAgaW5uZXIgW10gbFxuXG5sZXQgcmVjIF9jb2xsZWN0X3JldiBhY2MgPSBmdW5jdGlvblxuICB8IFtdIC0+XG4gICAgTHd0LnJldHVybiBhY2NcbiAgfCB0Ojp0cyAtPlxuICAgIHQgPj49IGZ1biBpIC0+XG4gICAgKF9jb2xsZWN0X3JldiBbQG9jYW1sLnRhaWxjYWxsXSkgKGk6OmFjYykgdHNcblxubGV0IG1hcF9wIGYgbCA9XG4gIGxldCB0cyA9IExpc3QucmV2X21hcCAoTHd0LmFwcGx5IGYpIGwgaW5cbiAgX2NvbGxlY3RfcmV2IFtdIHRzXG5cbmxldCBmaWx0ZXJfbWFwX3MgZiBsID1cbiAgbGV0IHJlYyBpbm5lciBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gICAgIC0+IExpc3QucmV2IGFjYyB8PiBMd3QucmV0dXJuXG4gICAgfCBoZDo6dGwgLT5cbiAgICAgIEx3dC5hcHBseSBmIGhkID4+PSBmdW5jdGlvblxuICAgICAgfCBTb21lIHYgLT4gKGlubmVyIFtAb2NhbWwudGFpbGNhbGxdKSAodjo6YWNjKSB0bFxuICAgICAgfCBOb25lIC0+IChpbm5lciBbQG9jYW1sLnRhaWxjYWxsXSkgYWNjIHRsXG4gIGluXG4gIGlubmVyIFtdIGxcblxubGV0IGZpbHRlcl9tYXBfcCBmIGwgPVxuICBsZXQgcmVjIF9jb2xsZWN0X29wdGlvbmFsX3JldiBhY2MgPSBmdW5jdGlvblxuICB8IFtdICAgIC0+IEx3dC5yZXR1cm4gYWNjXG4gIHwgdDo6dHMgLT5cbiAgICB0ID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSB2IC0+IChfY29sbGVjdF9vcHRpb25hbF9yZXYgW0BvY2FtbC50YWlsY2FsbF0pICh2OjphY2MpIHRzXG4gICAgfCBOb25lIC0+IChfY29sbGVjdF9vcHRpb25hbF9yZXYgW0BvY2FtbC50YWlsY2FsbF0pIGFjYyB0c1xuICBpblxuICBsZXQgdHMgPSBMaXN0LnJldl9tYXAgKEx3dC5hcHBseSBmKSBsIGluXG4gIF9jb2xsZWN0X29wdGlvbmFsX3JldiBbXSB0c1xuXG5sZXQgbWFwaV9zIGYgbCA9XG4gIGxldCByZWMgaW5uZXIgYWNjIGkgPSBmdW5jdGlvblxuICAgIHwgW10gICAgIC0+IExpc3QucmV2IGFjYyB8PiBMd3QucmV0dXJuXG4gICAgfCBoZDo6dGwgLT5cbiAgICAgIEx3dC5hcHBseSAoZiBpKSBoZCA+Pj0gZnVuIHYgLT5cbiAgICAgIChpbm5lciBbQG9jYW1sLnRhaWxjYWxsXSkgKHY6OmFjYykgKGkrMSkgdGxcbiAgaW5cbiAgaW5uZXIgW10gMCBsXG5cbmxldCBtYXBpX3AgZiBsID1cbiAgbGV0IGYnIGkgPSBMd3QuYXBwbHkgKGYgaSkgaW5cbiAgbGV0IHRzID0gdGFpbF9yZWN1cnNpdmVfbWFwaV9yZXYgZicgbCBpblxuICBfY29sbGVjdF9yZXYgW10gdHNcblxubGV0IHJlYyByZXZfbWFwX2FwcGVuZF9zIGFjYyBmIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIEx3dC5yZXR1cm4gYWNjXG4gIHwgeCA6OiBsIC0+XG4gICAgTHd0LmFwcGx5IGYgeCA+Pj0gZnVuIHggLT5cbiAgICByZXZfbWFwX2FwcGVuZF9zICh4IDo6IGFjYykgZiBsXG5cbmxldCByZXZfbWFwX3MgZiBsID1cbiAgcmV2X21hcF9hcHBlbmRfcyBbXSBmIGxcblxubGV0IHJlYyByZXZfbWFwX2FwcGVuZF9wIGFjYyBmIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIGFjY1xuICB8IHggOjogbCAtPlxuICAgIHJldl9tYXBfYXBwZW5kX3BcbiAgICAgIChMd3QuYXBwbHkgZiB4ID4+PSBmdW4geCAtPlxuICAgICAgIGFjYyA+fD0gZnVuIGwgLT5cbiAgICAgICB4IDo6IGwpIGYgbFxuXG5sZXQgcmV2X21hcF9wIGYgbCA9XG4gIHJldl9tYXBfYXBwZW5kX3AgTHd0LnJldHVybl9uaWwgZiBsXG5cbmxldCByZWMgZm9sZF9sZWZ0X3MgZiBhY2MgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgTHd0LnJldHVybiBhY2NcbiAgfCB4IDo6IGwgLT5cbiAgICBMd3QuYXBwbHkgKGYgYWNjKSB4ID4+PSBmdW4gYWNjIC0+XG4gICAgKGZvbGRfbGVmdF9zIFtAb2NhbWwudGFpbGNhbGxdKSBmIGFjYyBsXG5cbmxldCBmb2xkX3JpZ2h0X3MgZiBsIGFjYyA9XG4gIGxldCByZWMgaW5uZXIgZiBhID0gZnVuY3Rpb25cbiAgICB8IFtdICAgICAtPiBMd3QucmV0dXJuIGFcbiAgICB8IGhkOjp0bCAtPiAoTHd0LmFwcGx5IChmIGhkKSBhKSA+Pj0gZnVuIGEnIC0+XG4gICAgICAoaW5uZXIgW0BvY2FtbC50YWlsY2FsbF0pIGYgYScgdGxcbiAgaW5cbiAgaW5uZXIgZiBhY2MgKExpc3QucmV2IGwpXG5cbmxldCByZWMgZm9yX2FsbF9zIGYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgTHd0LnJldHVybl90cnVlXG4gIHwgeCA6OiBsIC0+XG4gICAgTHd0LmFwcGx5IGYgeCA+Pj0gZnVuY3Rpb25cbiAgICB8IHRydWUgLT5cbiAgICAgIChmb3JfYWxsX3MgW0BvY2FtbC50YWlsY2FsbF0pIGYgbFxuICAgIHwgZmFsc2UgLT5cbiAgICAgIEx3dC5yZXR1cm5fZmFsc2VcblxubGV0IGZvcl9hbGxfcCBmIGwgPVxuICBtYXBfcCBmIGwgPj49IGZ1biBibCAtPiBMaXN0LmZvcl9hbGwgKGZ1biB4IC0+IHgpIGJsIHw+IEx3dC5yZXR1cm5cblxubGV0IHJlYyBleGlzdHNfcyBmIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIEx3dC5yZXR1cm5fZmFsc2VcbiAgfCB4IDo6IGwgLT5cbiAgICBMd3QuYXBwbHkgZiB4ID4+PSBmdW5jdGlvblxuICAgIHwgdHJ1ZSAtPlxuICAgICAgTHd0LnJldHVybl90cnVlXG4gICAgfCBmYWxzZSAtPlxuICAgICAgKGV4aXN0c19zIFtAb2NhbWwudGFpbGNhbGxdKSBmIGxcblxubGV0IGV4aXN0c19wIGYgbCA9XG4gIG1hcF9wIGYgbCA+Pj0gZnVuIGJsIC0+IExpc3QuZXhpc3RzIChmdW4geCAtPiB4KSBibCB8PiBMd3QucmV0dXJuXG5cbmxldCByZWMgZmluZF9zIGYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgTHd0LmZhaWwgTm90X2ZvdW5kXG4gIHwgeCA6OiBsIC0+XG4gICAgTHd0LmFwcGx5IGYgeCA+Pj0gZnVuY3Rpb25cbiAgICB8IHRydWUgLT5cbiAgICAgIEx3dC5yZXR1cm4geFxuICAgIHwgZmFsc2UgLT5cbiAgICAgIChmaW5kX3MgW0BvY2FtbC50YWlsY2FsbF0pIGYgbFxuXG5sZXQgX29wdGlvbmFsaXplIGYgeCA9XG4gIGYgeCA+Pj0gZnVuIGIgLT4gaWYgYiB0aGVuIEx3dC5yZXR1cm4gKFNvbWUgeCkgZWxzZSBMd3QucmV0dXJuX25vbmVcblxubGV0IGZpbHRlcl9zIGYgbCA9XG4gIGZpbHRlcl9tYXBfcyAoX29wdGlvbmFsaXplIGYpIGxcblxubGV0IGZpbHRlcl9wIGYgbCA9XG4gICBmaWx0ZXJfbWFwX3AgKF9vcHRpb25hbGl6ZSBmKSBsXG5cbmxldCBwYXJ0aXRpb25fcyBmIGwgPVxuICBsZXQgcmVjIGlubmVyIGFjYzEgYWNjMiA9IGZ1bmN0aW9uXG4gICAgfCBbXSAgICAgLT4gTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjMSwgTGlzdC5yZXYgYWNjMilcbiAgICB8IGhkOjp0bCAtPiBMd3QuYXBwbHkgZiBoZCA+Pj0gZnVuIGIgLT5cbiAgICAgICAgaWYgYiB0aGVuXG4gICAgICAgICAgaW5uZXIgKGhkOjphY2MxKSBhY2MyIHRsXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpbm5lciBhY2MxIChoZDo6YWNjMikgdGxcbiAgaW5cbiAgaW5uZXIgW10gW10gbFxuXG5sZXQgcGFydGl0aW9uX3AgZiBsID1cbiAgbGV0IGcgeCA9IEx3dC5hcHBseSBmIHggPj49IGZ1biBiIC0+IEx3dC5yZXR1cm4gKGIsIHgpIGluXG4gIG1hcF9wIGcgbCA+Pj0gZnVuIHRsIC0+XG4gIGxldCBncm91cDEgPSB0YWlsX3JlY3Vyc2l2ZV9tYXAgc25kIEBAIExpc3QuZmlsdGVyIGZzdCB0bCBpblxuICBsZXQgZ3JvdXAyID1cbiAgICB0YWlsX3JlY3Vyc2l2ZV9tYXAgc25kIEBAIExpc3QuZmlsdGVyIChmdW4geCAtPiBub3QgQEAgZnN0IHgpIHRsIGluXG4gIEx3dC5yZXR1cm4gKGdyb3VwMSwgZ3JvdXAyKVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjUxMzMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHd0LmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJMd3Rfc2VxdWVuY2UiLCJTdGRsaWJfUXVldWUiLCJMd3RfbGlzdCIsIkx3dCIsImNyZWF0ZSIsIm0iLCJvcHQiLCJzdGgiLCJ2YWxpZGF0ZSIsInBhcmFtIiwiY2hlY2siLCJkaXNwb3NlIiwiY3JlYXRlX21lbWJlciIsInAiLCJleG4iLCJyZWxlYXNlIiwiYyIsIm1hdGNoIiwid2FrZW5lciIsInZhbGlkYXRlX2FuZF9yZXR1cm4iLCJlIiwidXNlIiwiY2xlYXJlZCIsInByb21pc2UiLCJvayIsInJlc3VsdCIsImNsZWFyIiwiZWxlbWVudHMiLCJsIiwiZWxlbWVudCIsIm9sZF9jbGVhcmVkIiwid2FpdF9xdWV1ZV9sZW5ndGgiLCJMd3RfcG9vbCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvanNlby8ub3BhbS80LjEzLjEvbGliL2x3dC9sd3RfcG9vbC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxZQUFBQyxPQUFBQyxHQUFBQyxLQUFBLFVBQUFGO0FBQUFBLElDc0NFO0FBQUEsU0FBQUcsTUFBQSxRQUFBQyxXQUR3QjtBQUFBO0FBQUEsU0FBQUEsV0FBQSxTQUFBQyxPQUFTLGVBQWU7QUFBQSxJQUNoRDtBQUFBLFNBQUFGLFFBQUEsUUFBQUcsUUFENEQ7QUFBQTtBQUFBLFNBQUFBLFFBQUEsU0FBQUQsT0FBQWhCLEdBQVcsdUJBQU07QUFBQSxJQUM3RTtBQUFBLFNBQUFjLFFBQUEsUUFBQUksVUFEMkY7QUFBQTtBQUFBLFNBQUFBLFVBQUEsU0FBQUYsT0FBUyxlQUFlO0FBQUEsY0FTdkc7QUFBQSxJQURIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFlO0FBQUEsR0FDWTtBQUFBLFlBQUFHLGNBQUFDO0FBQUFBLElBSXBDO0FBQUE7QUFBQSxzQkFBQUosT0FJSyxxQkFDQSwwQkFBVztBQUFBLHNCQUFBSztBQUFBQSxjQUdYO0FBQUEsY0FDQSw4QkFBWTtBQUFBLGVBQUM7QUFBQTtBQUFBLFlBQUFDLFFBQUFGLEdBQUFHO0FBQUFBLFFBQUFDLFFBSVo7QUFBQSxJQUFpQyxZQU1yQywyQ0FBbUI7QUFBQSxRQUFBQyxVQU5rQjtBQUFBLElBR3JDLHFDQUdtQjtBQUFBO0FBQUEsWUFBQVAsUUFBQUUsR0FBQUc7QUFBQUEsUUFBQSxNQUlyQjtBQUFBLElBQVc7QUFBQTtBQUFBO0FBQUEsc0JBQUFQLE9BQ1gscUJBQ0EsZUFBZTtBQUFBO0FBQUEsWUFBQVUsb0JBQUFOLEdBQUFHO0FBQUFBLElBb0JmO0FBQUE7QUFBQSxzQkFBQVAsT0FFTywwQkFBWTtBQUFBLHNCQUFBQTtBQUFBQSxjQUNmLFVBRUksNEJBSWdCO0FBQUEsd0JBRGhCO0FBQUEsY0FBVztBQUFBLGlEQUFBQSxPQUNYLHVCQUFlLEdBQUM7QUFBQTtBQUFBLHNCQUFBVztBQUFBQSxrQkFBQSxNQUlqQjtBQUFBLGNBQVc7QUFBQTtBQUFBO0FBQUEsZ0NBQUFYO0FBQUFBLDRCQUFBUSxRQTdCWjtBQUFBLHdCQUFpQztBQUFBLDZCQUFBQyxVQUFBLGdCQU9uQztBQUFBLHlCQUF1QjtBQUFBO0FBQUE7QUFBQSxvQ0FBQUYsR0FFcEIscUNBQTBCO0FBQUEsb0NBQUFGLEtBRzFCLHVDQUFnQztBQUFBO0FBQUEsd0JBa0JkO0FBQUEsdUJBQ0w7QUFBQSxlQUFDO0FBQUE7QUFBQSxZQUFBTyxJQUFBUixHQUFBcEI7QUFBQUEsYUFBQSxJQUFBdUI7QUFBQUE7QUFBQUEsTUFBQU0sVUFvQ3JCO0FBQUEsTUFBQUM7QUFBQUEsUUFFRTtBQUFBO0FBQUEsbUJBQUFkLE9BQ2EsdUJBQUc7QUFBQSxtQkFBQVc7QUFBQUEsZUFBQUUsWUFFWCxZQUFBRSxLQXJCUDtBQUFBLFdBQ0EsNkJBQUFDLFFBQXlCLHlCQUFZO0FBQUE7QUFBQTtBQUFBLHNCQUFDLFNBQUFoQixPQXFCL0IsNEJBQVU7QUFBQSxZQXJCcUI7QUFBQSxhQU9wQztBQUFBLHVCQUFXO0FBQUE7QUFBQTtBQUFBLHNCQU5jO0FBQUE7QUFBQSxXQW1CVSx1Q0FDcEI7QUFBQTtBQUFBLEtBRWpCO0FBQUE7QUFBQTtBQUFBLHVCQUFBQTtBQUFBQSxlQUNBO0FBQUEsMEJBRUU7QUFBQSxnQkFBVztBQUFBLG1EQUFBQSxPQUNYLGVBQU8sRUFLUjtBQUFBO0FBQUEsZUFGQztBQUFBLGVBQVc7QUFBQSxjQUVaO0FBQUE7QUFBQSxJQWpERTtBQUFBLEtBRUQ7QUFBQSxnQkFFRTtBQUFBO0FBQUE7QUFBQSxhQUdBO0FBQUE7QUFBQSxTQUFnRDtBQUFBO0FBQUE7QUFBQSx5QkFBSztBQUFBO0FBQUE7QUFBQSxNQUFBTyxJQUcvQztBQUFBLFlBQ1I7QUFBQSxJQWtCTyx1Q0FvQlI7QUFBQTtBQUFBLFlBQUFVLE1BQUFiO0FBQUFBO0FBQUFBLEtBQUFjO0FBQUFBLE9BR2M7QUFBQTtBQUFBLGtCQUFBQyxHQUFBQyxTQUE2Qix1QkFBWTtBQUFBO0FBQUE7QUFBQSxJQUN4RDtBQUFBLFFBQUFDLGNBQWtCO0FBQUEsSUFHbEI7QUFBQSxJQUNBO0FBQUEsSUFDMkI7QUFBQSx3Q0FBWCxtQ0FBb0I7QUFBQTtBQUFBLFlBQUFDLGtCQUFBbEIsR0FFWix3Q0FBNkI7QUFBQSxPQUFBbUIsV0Q5S3ZEIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbigqIFtMd3Rfc2VxdWVuY2VdIGlzIGRlcHJlY2F0ZWQg4oCTIHdlIGRvbid0IHdhbnQgdXNlcnMgb3V0c2lkZSBMd3QgdXNpbmcgaXQuXG4gICBIb3dldmVyLCBpdCBpcyBzdGlsbCB1c2VkIGludGVybmFsbHkgYnkgTHd0LiBTbywgYnJpZWZseSBkaXNhYmxlIHdhcm5pbmcgM1xuICAgKFwiZGVwcmVjYXRlZFwiKSwgYW5kIGNyZWF0ZSBhIGxvY2FsLCBub24tZGVwcmVjYXRlZCBhbGlhcyBmb3JcbiAgIFtMd3Rfc2VxdWVuY2VdIHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGJ5IHRoZSByZXN0IG9mIHRoZSBjb2RlIGluIHRoaXNcbiAgIG1vZHVsZSB3aXRob3V0IHRyaWdnZXJpbmcgYW55IG1vcmUgd2FybmluZ3MuICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5tb2R1bGUgTHd0X3NlcXVlbmNlID0gTHd0X3NlcXVlbmNlXG5bQEBAb2NhbWwud2FybmluZyBcIiszXCJdXG5cbm9wZW4gTHd0LkluZml4XG5cbnR5cGUgJ2EgdCA9IHtcbiAgY3JlYXRlIDogdW5pdCAtPiAnYSBMd3QudDtcbiAgKCogQ3JlYXRlIGEgbmV3IHBvb2wgbWVtYmVyLiAqKVxuICBjaGVjayA6ICdhIC0+IChib29sIC0+IHVuaXQpIC0+IHVuaXQ7XG4gICgqIENoZWNrIHZhbGlkaXR5IG9mIGEgcG9vbCBtZW1iZXIgd2hlbiB1c2UgcmVzdWx0ZWQgaW4gZmFpbGVkIHByb21pc2UuICopXG4gIHZhbGlkYXRlIDogJ2EgLT4gYm9vbCBMd3QudDtcbiAgKCogVmFsaWRhdGUgYW4gZXhpc3RpbmcgZnJlZSBwb29sIG1lbWJlciBiZWZvcmUgdXNlLiAqKVxuICBkaXNwb3NlIDogJ2EgLT4gdW5pdCBMd3QudDtcbiAgKCogRGlzcG9zZSBvZiBhIHBvb2wgbWVtYmVyLiAqKVxuICBjbGVhcmVkIDogYm9vbCByZWYgcmVmO1xuICAoKiBIYXZlIHRoZSBjdXJyZW50IHBvb2wgZWxlbWVudHMgYmVlbiBjbGVhcmVkIG91dD8gKilcbiAgbWF4IDogaW50O1xuICAoKiBTaXplIG9mIHRoZSBwb29sLiAqKVxuICBtdXRhYmxlIGNvdW50IDogaW50O1xuICAoKiBOdW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHBvb2wuICopXG4gIGxpc3QgOiAnYSBRdWV1ZS50O1xuICAoKiBBdmFpbGFibGUgcG9vbCBtZW1iZXJzLiAqKVxuICB3YWl0ZXJzIDogJ2EgTHd0LnUgTHd0X3NlcXVlbmNlLnQ7XG4gICgqIFByb21pc2UgcmVzb2x2ZXJzIHdhaXRpbmcgZm9yIGEgZnJlZSBtZW1iZXIuICopXG59XG5cbmxldCBjcmVhdGUgbSA/KHZhbGlkYXRlID0gZnVuIF8gLT4gTHd0LnJldHVybl90cnVlKSA/KGNoZWNrID0gZnVuIF8gZiAtPiBmIHRydWUpID8oZGlzcG9zZSA9IGZ1biBfIC0+IEx3dC5yZXR1cm5fdW5pdCkgY3JlYXRlID1cbiAgeyBtYXggPSBtO1xuICAgIGNyZWF0ZSA9IGNyZWF0ZTtcbiAgICB2YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgIGNoZWNrID0gY2hlY2s7XG4gICAgZGlzcG9zZSA9IGRpc3Bvc2U7XG4gICAgY2xlYXJlZCA9IHJlZiAocmVmIGZhbHNlKTtcbiAgICBjb3VudCA9IDA7XG4gICAgbGlzdCA9IFF1ZXVlLmNyZWF0ZSAoKTtcbiAgICB3YWl0ZXJzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKSB9XG5cbigqIENyZWF0ZSBhIHBvb2wgbWVtYmVyLiAqKVxubGV0IGNyZWF0ZV9tZW1iZXIgcCA9XG4gIEx3dC5jYXRjaFxuICAgIChmdW4gKCkgLT5cbiAgICAgICAoKiBNdXN0IGJlIGRvbmUgYmVmb3JlIHAuY3JlYXRlIHRvIHByZXZlbnQgb3RoZXIgcmVzb2x2ZXJzIGZyb21cbiAgICAgICAgICBjcmVhdGluZyBuZXcgbWVtYmVycyBpZiB0aGUgbGltaXQgaXMgcmVhY2hlZC4gKilcbiAgICAgICBwLmNvdW50IDwtIHAuY291bnQgKyAxO1xuICAgICAgIHAuY3JlYXRlICgpKVxuICAgIChmdW4gZXhuIC0+XG4gICAgICAgKCogQ3JlYXRpb24gZmFpbGVkLCBzbyBkb24ndCBpbmNyZW1lbnQgY291bnQuICopXG4gICAgICAgcC5jb3VudCA8LSBwLmNvdW50IC0gMTtcbiAgICAgICBMd3QuZmFpbCBleG4pXG5cbigqIFJlbGVhc2UgYSBwb29sIG1lbWJlci4gKilcbmxldCByZWxlYXNlIHAgYyA9XG4gIG1hdGNoIEx3dF9zZXF1ZW5jZS50YWtlX29wdF9sIHAud2FpdGVycyB3aXRoXG4gIHwgU29tZSB3YWtlbmVyIC0+XG4gICAgKCogQSBwcm9taXNlIHJlc29sdmVyIGlzIHdhaXRpbmcsIGdpdmUgaXQgdGhlIHBvb2wgbWVtYmVyLiAqKVxuICAgIEx3dC53YWtldXBfbGF0ZXIgd2FrZW5lciBjXG4gIHwgTm9uZSAtPlxuICAgICgqIE5vIG9uZSBpcyB3YWl0aW5nLCBxdWV1ZSBpdC4gKilcbiAgICBRdWV1ZS5wdXNoIGMgcC5saXN0XG5cbigqIERpc3Bvc2Ugb2YgYSBwb29sIG1lbWJlci4gKilcbmxldCBkaXNwb3NlIHAgYyA9XG4gIHAuZGlzcG9zZSBjID4+PSBmdW4gKCkgLT5cbiAgcC5jb3VudCA8LSBwLmNvdW50IC0gMTtcbiAgTHd0LnJldHVybl91bml0XG5cbigqIENyZWF0ZSBhIG5ldyBtZW1iZXIgd2hlbiBvbmUgaXMgdGhyb3duIGF3YXkuICopXG5sZXQgcmVwbGFjZV9kaXNwb3NlZCBwID1cbiAgbWF0Y2ggTHd0X3NlcXVlbmNlLnRha2Vfb3B0X2wgcC53YWl0ZXJzIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgKCogTm8gb25lIGlzIHdhaXRpbmcsIGRvIG5vdCBjcmVhdGUgYSBuZXcgbWVtYmVyIHRvIGF2b2lkXG4gICAgICAgbG9zaW5nIGFuIGVycm9yIGlmIGNyZWF0aW9uIGZhaWxzLiAqKVxuICAgICgpXG4gIHwgU29tZSB3YWtlbmVyIC0+XG4gICAgTHd0Lm9uX2FueVxuICAgICAgKEx3dC5hcHBseSBwLmNyZWF0ZSAoKSlcbiAgICAgIChmdW4gYyAtPlxuICAgICAgICAgTHd0Lndha2V1cF9sYXRlciB3YWtlbmVyIGMpXG4gICAgICAoZnVuIGV4biAtPlxuICAgICAgICAgKCogQ3JlYXRpb24gZmFpbGVkLCBub3RpZnkgdGhlIHdhaXRlciBvZiB0aGUgZmFpbHVyZS4gKilcbiAgICAgICAgIEx3dC53YWtldXBfbGF0ZXJfZXhuIHdha2VuZXIgZXhuKVxuXG4oKiBWZXJpZnkgYSBtZW1iZXIgaXMgc3RpbGwgdmFsaWQgYmVmb3JlIHVzaW5nIGl0LiAqKVxubGV0IHZhbGlkYXRlX2FuZF9yZXR1cm4gcCBjID1cbiAgTHd0LnRyeV9iaW5kXG4gICAgICAoZnVuICgpIC0+XG4gICAgICAgICBwLnZhbGlkYXRlIGMpXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCB0cnVlIC0+XG4gICAgICAgICAgTHd0LnJldHVybiBjXG4gICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICAoKiBSZW1vdmUgdGhpcyBtZW1iZXIgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuICopXG4gICAgICAgICAgZGlzcG9zZSBwIGMgPj49IGZ1biAoKSAtPlxuICAgICAgICAgIGNyZWF0ZV9tZW1iZXIgcClcbiAgICAgIChmdW4gZSAtPlxuICAgICAgICAgKCogVmFsaWRhdGlvbiBmYWlsZWQ6IGNyZWF0ZSBhIG5ldyBtZW1iZXIgaWYgYXQgbGVhc3Qgb25lXG4gICAgICAgICAgICByZXNvbHZlciBpcyB3YWl0aW5nLiAqKVxuICAgICAgICAgZGlzcG9zZSBwIGMgPj49IGZ1biAoKSAtPlxuICAgICAgICAgcmVwbGFjZV9kaXNwb3NlZCBwO1xuICAgICAgICAgTHd0LnJlcmFpc2UgZSlcblxuKCogQWNxdWlyZSBhIHBvb2wgbWVtYmVyLiAqKVxubGV0IGFjcXVpcmUgcCA9XG4gIGlmIFF1ZXVlLmlzX2VtcHR5IHAubGlzdCB0aGVuXG4gICAgKCogTm8gbW9yZSBhdmFpbGFibGUgbWVtYmVyLiAqKVxuICAgIGlmIHAuY291bnQgPCBwLm1heCB0aGVuXG4gICAgICAoKiBMaW1pdCBub3QgcmVhY2hlZDogY3JlYXRlIGEgbmV3IG9uZS4gKilcbiAgICAgIGNyZWF0ZV9tZW1iZXIgcFxuICAgIGVsc2VcbiAgICAgICgqIExpbWl0IHJlYWNoZWQ6IHdhaXQgZm9yIGEgZnJlZSBvbmUuICopXG4gICAgICAoTHd0LmFkZF90YXNrX3IgW0BvY2FtbC53YXJuaW5nIFwiLTNcIl0pIHAud2FpdGVycyA+Pj0gdmFsaWRhdGVfYW5kX3JldHVybiBwXG4gIGVsc2VcbiAgICAoKiBUYWtlIHRoZSBmaXJzdCBmcmVlIG1lbWJlciBhbmQgdmFsaWRhdGUgaXQuICopXG4gICAgbGV0IGMgPSBRdWV1ZS50YWtlIHAubGlzdCBpblxuICAgIHZhbGlkYXRlX2FuZF9yZXR1cm4gcCBjXG5cbigqIFJlbGVhc2UgYSBtZW1iZXIgd2hlbiB1c2UgcmVzdWx0ZWQgaW4gZmFpbGVkIHByb21pc2UgaWYgdGhlIG1lbWJlclxuICAgaXMgc3RpbGwgdmFsaWQuICopXG5sZXQgY2hlY2tfYW5kX3JlbGVhc2UgcCBjIGNsZWFyZWQgPVxuICBsZXQgb2sgPSByZWYgZmFsc2UgaW5cbiAgcC5jaGVjayBjIChmdW4gcmVzdWx0IC0+IG9rIDo9IHJlc3VsdCk7XG4gIGlmIGNsZWFyZWQgfHwgbm90ICFvayB0aGVuIChcbiAgICAoKiBFbGVtZW50IGlzIG5vdCBvayBvciB0aGUgcG9vbCB3YXMgY2xlYXJlZCAtIGRpc3Bvc2Ugb2YgaXQgKilcbiAgICBkaXNwb3NlIHAgY1xuICApXG4gIGVsc2UgKFxuICAgICgqIEVsZW1lbnQgaXMgb2sgLSByZWxlYXNlIGl0IGJhY2sgdG8gdGhlIHBvb2wgKilcbiAgICByZWxlYXNlIHAgYztcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgKVxuXG5sZXQgdXNlIHAgZiA9XG4gIGFjcXVpcmUgcCA+Pj0gZnVuIGMgLT5cbiAgKCogQ2FwdHVyZSB0aGUgY3VycmVudCBjbGVhcmVkIHN0YXRlIHNvIHdlIGNhbiBzZWUgaWYgaXQgY2hhbmdlcyB3aGlsZSB0aGlzXG4gICAgIGVsZW1lbnQgaXMgaW4gdXNlICopXG4gIGxldCBjbGVhcmVkID0gIShwLmNsZWFyZWQpIGluXG4gIGxldCBwcm9taXNlID1cbiAgICBMd3QuY2F0Y2hcbiAgICAgIChmdW4gKCkgLT4gZiBjKVxuICAgICAgKGZ1biBlIC0+XG4gICAgICAgICBjaGVja19hbmRfcmVsZWFzZSBwIGMgIWNsZWFyZWQgPj49IGZ1biAoKSAtPlxuICAgICAgICAgTHd0LmZhaWwgZSlcbiAgaW5cbiAgcHJvbWlzZSA+Pj0gZnVuIF8gLT5cbiAgaWYgIWNsZWFyZWQgdGhlbiAoXG4gICAgKCogcCB3YXMgY2xlYXJlZCB3aGlsZSBwcm9taXNlIHdhcyByZXNvbHZpbmcgLSBkaXNwb3NlIG9mIHRoaXMgZWxlbWVudCAqKVxuICAgIGRpc3Bvc2UgcCBjID4+PSBmdW4gKCkgLT5cbiAgICBwcm9taXNlXG4gIClcbiAgZWxzZSAoXG4gICAgcmVsZWFzZSBwIGM7XG4gICAgcHJvbWlzZVxuICApXG5cbmxldCBjbGVhciBwID1cbiAgbGV0IGVsZW1lbnRzID0gUXVldWUuZm9sZCAoZnVuIGwgZWxlbWVudCAtPiBlbGVtZW50IDo6IGwpIFtdIHAubGlzdCBpblxuICBRdWV1ZS5jbGVhciBwLmxpc3Q7XG4gICgqIEluZGljYXRlIHRvIGFueSBjdXJyZW50bHkgaW4tdXNlIGVsZW1lbnRzIHRoYXQgd2UgY2xlYXJlZCB0aGUgcG9vbCAqKVxuICBsZXQgb2xkX2NsZWFyZWQgPSAhKHAuY2xlYXJlZCkgaW5cbiAgb2xkX2NsZWFyZWQgOj0gdHJ1ZTtcbiAgcC5jbGVhcmVkIDo9IHJlZiBmYWxzZTtcbiAgTHd0X2xpc3QuaXRlcl9zIChkaXNwb3NlIHApIGVsZW1lbnRzXG5cbmxldCB3YWl0X3F1ZXVlX2xlbmd0aCBwID0gTHd0X3NlcXVlbmNlLmxlbmd0aCBwLndhaXRlcnNcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo1MzEyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Imx3dC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiTHd0IiwiTHd0X3NlcXVlbmNlIiwiY3JlYXRlX2VtcHR5IiwicGFyYW0iLCJjcmVhdGUiLCJ2IiwicHV0IiwibXZhciIsIm1hdGNoIiwidyIsInJlcyIsIm5vZGUiLCJ0YWtlX2F2YWlsYWJsZSIsInRha2UiLCJpc19lbXB0eSIsIkx3dF9tdmFyIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9qc2VvLy5vcGFtLzQuMTMuMS9saWIvbHd0L2x3dF9tdmFyLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxhQUFBQztBQUFBQSxRQUFBLE1Dc0RjO0FBQUEsSUFEQSxrREFBc0I7QUFBQSxHQUNFO0FBQUEsWUFBQUMsT0FBQUM7QUFBQUEsUUFBQSxNQUt4QjtBQUFBLElBREEsdURBQXNCO0FBQUEsR0FDRTtBQUFBLFlBQUFDLElBQUFDLE1BQUFGO0FBQUFBLElBR3BDO0FBQUE7QUFBQSxNQUFBRyxRQVVpQjtBQUFBLE1BQUFDLElBQVc7QUFBQSxNQUFBQyxNQUFBO0FBQUEsTUFBQUMsT0FDZjtBQUFBLEtBQ1g7QUFBQTtBQUFBO0FBQUEsZ0JBQUFSLE9BQTRCLHdDQUF3QjtBQUFBLEtBQUM7QUFBQTtBQUFBLFFBQUFLLFVBVnpDO0FBQUEsSUFBb0M7QUFBQSxTQUFBQyxNQUFBO0FBQUEsS0FJNUM7QUFBQTtBQUFBO0FBQUEsS0FGQTtBQUFBLElBSUo7QUFBQSxHQUtHO0FBQUEsWUFBQUcsZUFBQUw7QUFBQUEsUUFBQUMsVUFXTDtBQUFBLGtCQUtFO0FBQUEsUUFBQUgsTUFMRixZQUFBRyxRQVJNO0FBQUEsSUFBb0M7QUFBQSxTQUFBQSxVQUFBLFVBQUFDLElBQUEsWUFBQUosSUFBQTtBQUFBLEtBRXhDO0FBQUEsS0FDQTtBQUFBO0FBQUE7QUFBQSxLQUVBO0FBQUEsSUFLZ0I7QUFBQSxHQUdaO0FBQUEsWUFBQVEsS0FBQU47QUFBQUEsUUFBQUMsUUFHQTtBQUFBLElBQW1CLFlBRWYsbUNBQW1EO0FBQUEsUUFBQUgsSUFGcEM7QUFBQSxJQUNiLDRCQUNpRDtBQUFBO0FBQUEsWUFBQVMsU0FBQVAsTUFHN0Qsc0JBRWM7QUFBQTtBQUFBLElBQUFRLFdEckdoQiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogT0NhbWwgcHJvbWlzZSBsaWJyYXJ5XG4gKiBodHRwczovL29jc2lnZW4ub3JnL2x3dFxuICogQ29weXJpZ2h0IChjKSAyMDA5LCBNZXRhd2ViIFRlY2hub2xvZ2llcywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogYXJlIG1ldDpcbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBNRVRBV0VCIFRFQ0hOT0xPR0lFUyBgYEFTIElTJycgQU5EIEFOWVxuICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICogUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgTUVUQVdFQiBURUNITk9MT0dJRVMgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1JcbiAqIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0VcbiAqIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU5cbiAqIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICopXG5cbigqIFRoaXMgY29kZSBpcyBhZGFwdGVkIGZyb21cbiAgIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMTAwMTIxNTQyNS9odHRwOi8vZWlnZW5jbGFzcy5vcmc6ODAvaGlraS9saWdodHdlaWdodC10aHJlYWRzLXdpdGgtbHd0LiAqKVxuXG4oKiBbTHd0X3NlcXVlbmNlXSBpcyBkZXByZWNhdGVkIOKAkyB3ZSBkb24ndCB3YW50IHVzZXJzIG91dHNpZGUgTHd0IHVzaW5nIGl0LlxuICAgSG93ZXZlciwgaXQgaXMgc3RpbGwgdXNlZCBpbnRlcm5hbGx5IGJ5IEx3dC4gU28sIGJyaWVmbHkgZGlzYWJsZSB3YXJuaW5nIDNcbiAgIChcImRlcHJlY2F0ZWRcIiksIGFuZCBjcmVhdGUgYSBsb2NhbCwgbm9uLWRlcHJlY2F0ZWQgYWxpYXMgZm9yXG4gICBbTHd0X3NlcXVlbmNlXSB0aGF0IGNhbiBiZSByZWZlcnJlZCB0byBieSB0aGUgcmVzdCBvZiB0aGUgY29kZSBpbiB0aGlzXG4gICBtb2R1bGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFueSBtb3JlIHdhcm5pbmdzLiAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubW9kdWxlIEx3dF9zZXF1ZW5jZSA9IEx3dF9zZXF1ZW5jZVxuW0BAQG9jYW1sLndhcm5pbmcgXCIrM1wiXVxuXG50eXBlICdhIHQgPSB7XG4gIG11dGFibGUgbXZhcl9jb250ZW50cyA6ICdhIG9wdGlvbjtcbiAgKCogQ3VycmVudCBjb250ZW50cyAqKVxuXG4gIHdyaXRlcnMgOiAoJ2EgKiB1bml0IEx3dC51KSBMd3Rfc2VxdWVuY2UudDtcbiAgKCogVGhyZWFkcyB3YWl0aW5nIHRvIHB1dCBhIHZhbHVlICopXG5cbiAgcmVhZGVycyA6ICdhIEx3dC51IEx3dF9zZXF1ZW5jZS50O1xuICAoKiBUaHJlYWRzIHdhaXRpbmcgZm9yIGEgdmFsdWUgKilcbn1cblxubGV0IGNyZWF0ZV9lbXB0eSAoKSA9XG4gIHsgbXZhcl9jb250ZW50cyA9IE5vbmU7XG4gICAgd3JpdGVycyA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCk7XG4gICAgcmVhZGVycyA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCkgfVxuXG5sZXQgY3JlYXRlIHYgPVxuICB7IG12YXJfY29udGVudHMgPSBTb21lIHY7XG4gICAgd3JpdGVycyA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCk7XG4gICAgcmVhZGVycyA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCkgfVxuXG5sZXQgcHV0IG12YXIgdiA9XG4gIG1hdGNoIG12YXIubXZhcl9jb250ZW50cyB3aXRoXG4gIHwgTm9uZSAtPlxuICAgIGJlZ2luIG1hdGNoIEx3dF9zZXF1ZW5jZS50YWtlX29wdF9sIG12YXIucmVhZGVycyB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgbXZhci5tdmFyX2NvbnRlbnRzIDwtIFNvbWUgdlxuICAgICAgfCBTb21lIHcgLT5cbiAgICAgICAgTHd0Lndha2V1cF9sYXRlciB3IHZcbiAgICBlbmQ7XG4gICAgTHd0LnJldHVybl91bml0XG4gIHwgU29tZSBfIC0+XG4gICAgbGV0IChyZXMsIHcpID0gTHd0LnRhc2sgKCkgaW5cbiAgICBsZXQgbm9kZSA9IEx3dF9zZXF1ZW5jZS5hZGRfciAodiwgdykgbXZhci53cml0ZXJzIGluXG4gICAgTHd0Lm9uX2NhbmNlbCByZXMgKGZ1biBfIC0+IEx3dF9zZXF1ZW5jZS5yZW1vdmUgbm9kZSk7XG4gICAgcmVzXG5cbmxldCBuZXh0X3dyaXRlciBtdmFyID1cbiAgbWF0Y2ggTHd0X3NlcXVlbmNlLnRha2Vfb3B0X2wgbXZhci53cml0ZXJzIHdpdGhcbiAgfCBTb21lKHYnLCB3KSAtPlxuICAgIG12YXIubXZhcl9jb250ZW50cyA8LSBTb21lIHYnO1xuICAgIEx3dC53YWtldXBfbGF0ZXIgdyAoKVxuICB8IE5vbmUgLT5cbiAgICBtdmFyLm12YXJfY29udGVudHMgPC0gTm9uZVxuXG5sZXQgdGFrZV9hdmFpbGFibGUgbXZhciA9XG4gIG1hdGNoIG12YXIubXZhcl9jb250ZW50cyB3aXRoXG4gIHwgU29tZSB2IC0+XG4gICAgbmV4dF93cml0ZXIgbXZhcjtcbiAgICBTb21lIHZcbiAgfCBOb25lIC0+XG4gICAgTm9uZVxuXG5sZXQgdGFrZSBtdmFyID1cbiAgbWF0Y2ggdGFrZV9hdmFpbGFibGUgbXZhciB3aXRoXG4gIHwgU29tZSB2IC0+IEx3dC5yZXR1cm4gdlxuICB8IE5vbmUgLT4gKEx3dC5hZGRfdGFza19yIFtAb2NhbWwud2FybmluZyBcIi0zXCJdKSBtdmFyLnJlYWRlcnNcblxubGV0IGlzX2VtcHR5IG12YXIgPVxuICBtYXRjaCBtdmFyLm12YXJfY29udGVudHMgd2l0aFxuICB8IFNvbWUgXyAtPiBmYWxzZVxuICB8IE5vbmUgLT4gdHJ1ZVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjUzODksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHd0LmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJMd3Rfc2VxdWVuY2UiLCJMd3QiLCJjcmVhdGUiLCJwYXJhbSIsImxvY2siLCJtIiwidW5sb2NrIiwid2l0aF9sb2NrIiwiaXNfbG9ja2VkIiwiaXNfZW1wdHkiLCJMd3RfbXV0ZXgiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2pzZW8vLm9wYW0vNC4xMy4xL2xpYi9sd3QvbHd0X211dGV4Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxZQUFBQyxPQUFBQyxPQ2tCNEMsNkNBQXNCLENBQUU7QUFBQSxZQUFBQyxLQUFBQztBQUFBQSxJQUdsRSxjQUNFLCtDQUlDO0FBQUE7QUFBQSxZQUFBQyxPQUFBRDtBQUFBQSxRQUFBLE1BR0g7QUFBQTtBQUFBLElBQ0ssc0NBQ0Q7QUFBQSxjQUlpQjtBQUFBLElBQStCLGlDQUNqRDtBQUFBO0FBQUEsWUFBQUUsVUFBQUYsR0FBQVY7QUFBQUEsUUFBQSxNQUdIO0FBQUEsSUFBTTtBQUFBO0FBQUE7QUFBQSxzQkFBQVE7QUFBQUEsY0FDTjtBQUFBLDJDQUFBQSxPQUEwQixXQUFRLGVBQWlCLEVBQUM7QUFBQTtBQUFBO0FBQUEsWUFBQUssVUFBQUgsR0FFcEMsWUFBUTtBQUFBLFlBQUFJLFNBQUFKLEdBQ1Qsd0NBQStCO0FBQUEsT0FBQUssWUQzQ2hEIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbigqIFtMd3Rfc2VxdWVuY2VdIGlzIGRlcHJlY2F0ZWQg4oCTIHdlIGRvbid0IHdhbnQgdXNlcnMgb3V0c2lkZSBMd3QgdXNpbmcgaXQuXG4gICBIb3dldmVyLCBpdCBpcyBzdGlsbCB1c2VkIGludGVybmFsbHkgYnkgTHd0LiBTbywgYnJpZWZseSBkaXNhYmxlIHdhcm5pbmcgM1xuICAgKFwiZGVwcmVjYXRlZFwiKSwgYW5kIGNyZWF0ZSBhIGxvY2FsLCBub24tZGVwcmVjYXRlZCBhbGlhcyBmb3JcbiAgIFtMd3Rfc2VxdWVuY2VdIHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGJ5IHRoZSByZXN0IG9mIHRoZSBjb2RlIGluIHRoaXNcbiAgIG1vZHVsZSB3aXRob3V0IHRyaWdnZXJpbmcgYW55IG1vcmUgd2FybmluZ3MuICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5tb2R1bGUgTHd0X3NlcXVlbmNlID0gTHd0X3NlcXVlbmNlXG5bQEBAb2NhbWwud2FybmluZyBcIiszXCJdXG5cbm9wZW4gTHd0LkluZml4XG5cbnR5cGUgdCA9IHsgbXV0YWJsZSBsb2NrZWQgOiBib29sOyB3YWl0ZXJzIDogdW5pdCBMd3QudSBMd3Rfc2VxdWVuY2UudCAgfVxuXG5sZXQgY3JlYXRlICgpID0geyBsb2NrZWQgPSBmYWxzZTsgd2FpdGVycyA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCkgfVxuXG5sZXQgbG9jayBtID1cbiAgaWYgbS5sb2NrZWQgdGhlblxuICAgIChMd3QuYWRkX3Rhc2tfciBbQG9jYW1sLndhcm5pbmcgXCItM1wiXSkgbS53YWl0ZXJzXG4gIGVsc2UgYmVnaW5cbiAgICBtLmxvY2tlZCA8LSB0cnVlO1xuICAgIEx3dC5yZXR1cm5fdW5pdFxuICBlbmRcblxubGV0IHVubG9jayBtID1cbiAgaWYgbS5sb2NrZWQgdGhlbiBiZWdpblxuICAgIGlmIEx3dF9zZXF1ZW5jZS5pc19lbXB0eSBtLndhaXRlcnMgdGhlblxuICAgICAgbS5sb2NrZWQgPC0gZmFsc2VcbiAgICBlbHNlXG4gICAgICAoKiBXZSBkbyBub3QgdXNlIFtMd3Qud2FrZXVwXSBoZXJlIHRvIGF2b2lkIGEgc3RhY2sgb3ZlcmZsb3dcbiAgICAgICAgIHdoZW4gdW5sb2NraW5nIGEgbG90IG9mIHRocmVhZHMuICopXG4gICAgICBMd3Qud2FrZXVwX2xhdGVyIChMd3Rfc2VxdWVuY2UudGFrZV9sIG0ud2FpdGVycykgKClcbiAgZW5kXG5cbmxldCB3aXRoX2xvY2sgbSBmID1cbiAgbG9jayBtID4+PSBmdW4gKCkgLT5cbiAgTHd0LmZpbmFsaXplIGYgKGZ1biAoKSAtPiB1bmxvY2sgbTsgTHd0LnJldHVybl91bml0KVxuXG5sZXQgaXNfbG9ja2VkIG0gPSBtLmxvY2tlZFxubGV0IGlzX2VtcHR5IG0gPSBMd3Rfc2VxdWVuY2UuaXNfZW1wdHkgbS53YWl0ZXJzXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NTQzOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJMd3QiLCJMd3Rfc2VxdWVuY2UiLCJTdGRsaWJfTGlzdCIsIkx3dF9tdXRleCIsImNyZWF0ZSIsIndhaXQiLCJtdXRleCIsImN2YXIiLCJ3YWl0ZXIiLCJtIiwicGFyYW0iLCJzaWduYWwiLCJhcmciLCJicm9hZGNhc3QiLCJ3YWtlbmVycyIsIngiLCJsIiwid2FrZW5lciIsImJyb2FkY2FzdF9leG4iLCJleG4iLCJMd3RfY29uZGl0aW9uIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9qc2VvLy5vcGFtLzQuMTMuMS9saWIvbHd0L2x3dF9jb25kaXRpb24ubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsWUFBQUMsS0FBQUMsT0FBQUM7QUFBQUEsUUFBQUMsU0MwQ2U7QUFBQSxJQUNiLGNBQUFDLElBQUEsVUFFYztBQUFBLElBR2Q7QUFBQTtBQUFBLHNCQUFBQyxPQUNhLGNBQU07QUFBQSxzQkFBQUE7QUFBQUEsY0FFZCxZQUVVO0FBQUEsa0JBQUFELElBRlY7QUFBQSxjQUNZLGtDQUNhO0FBQUEsZUFBQztBQUFBO0FBQUEsWUFBQUUsT0FBQUosTUFBQUs7QUFBQUEsSUFHL0I7QUFBQTtBQUFBLFlBQ21CO0FBQUEsWUFBakI7QUFBQTtBQUFBO0FBQUE7QUFBQSxlRHpESjtBQUFBLGtDQzJESTtBQUFBLEtEM0RKO0FBQUE7QUFBQSxHQzJETTtBQUFBLFlBQUFDLFVBQUFOLE1BQUFLO0FBQUFBO0FBQUFBLEtBQUFFO0FBQUFBLE9BR1c7QUFBQSxvQ0FBQUMsR0FBQUMsR0FBZ0MsaUJBQU07QUFBQSxJQUNyRDtBQUFBLElBQWlEO0FBQUE7QUFBQSxzQkFBQUMsU0FDdkIsdUNBQTRCO0FBQUEsc0JBQVU7QUFBQTtBQUFBLFlBQUFDLGNBQUFYLE1BQUFZO0FBQUFBO0FBQUFBLEtBQUFMO0FBQUFBLE9BR2pEO0FBQUEsb0NBQUFDLEdBQUFDLEdBQWdDLGlCQUFNO0FBQUEsSUFDckQ7QUFBQSxJQUFpRDtBQUFBO0FBQUEsc0JBQUFDLFNBQ3ZCLHVDQUFnQztBQUFBLHNCQUFVO0FBQUE7QUFBQSxPQUFBRyxnQkRyRXRFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBPQ2FtbCBwcm9taXNlIGxpYnJhcnlcbiAqIGh0dHBzOi8vb2NzaWdlbi5vcmcvbHd0XG4gKiBDb3B5cmlnaHQgKGMpIDIwMDksIE1ldGF3ZWIgVGVjaG5vbG9naWVzLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICogICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIE1FVEFXRUIgVEVDSE5PTE9HSUVTIGBgQVMgSVMnJyBBTkQgQU5ZXG4gKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gKiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBNRVRBV0VCIFRFQ0hOT0xPR0lFUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUlxuICogQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRVxuICogT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTlxuICogSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKilcblxuKCogW0x3dF9zZXF1ZW5jZV0gaXMgZGVwcmVjYXRlZCDigJMgd2UgZG9uJ3Qgd2FudCB1c2VycyBvdXRzaWRlIEx3dCB1c2luZyBpdC5cbiAgIEhvd2V2ZXIsIGl0IGlzIHN0aWxsIHVzZWQgaW50ZXJuYWxseSBieSBMd3QuIFNvLCBicmllZmx5IGRpc2FibGUgd2FybmluZyAzXG4gICAoXCJkZXByZWNhdGVkXCIpLCBhbmQgY3JlYXRlIGEgbG9jYWwsIG5vbi1kZXByZWNhdGVkIGFsaWFzIGZvclxuICAgW0x3dF9zZXF1ZW5jZV0gdGhhdCBjYW4gYmUgcmVmZXJyZWQgdG8gYnkgdGhlIHJlc3Qgb2YgdGhlIGNvZGUgaW4gdGhpc1xuICAgbW9kdWxlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbnkgbW9yZSB3YXJuaW5ncy4gKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbm1vZHVsZSBMd3Rfc2VxdWVuY2UgPSBMd3Rfc2VxdWVuY2VcbltAQEBvY2FtbC53YXJuaW5nIFwiKzNcIl1cblxudHlwZSAnYSB0ID0gJ2EgTHd0LnUgTHd0X3NlcXVlbmNlLnRcblxubGV0IGNyZWF0ZSA9IEx3dF9zZXF1ZW5jZS5jcmVhdGVcblxubGV0IHdhaXQgP211dGV4IGN2YXIgPVxuICBsZXQgd2FpdGVyID0gKEx3dC5hZGRfdGFza19yIFtAb2NhbWwud2FybmluZyBcIi0zXCJdKSBjdmFyIGluXG4gIGxldCAoKSA9XG4gICAgbWF0Y2ggbXV0ZXggd2l0aFxuICAgIHwgU29tZSBtIC0+IEx3dF9tdXRleC51bmxvY2sgbVxuICAgIHwgTm9uZSAtPiAoKVxuICBpblxuICBMd3QuZmluYWxpemVcbiAgICAoZnVuICgpIC0+IHdhaXRlcilcbiAgICAoZnVuICgpIC0+XG4gICAgICAgbWF0Y2ggbXV0ZXggd2l0aFxuICAgICAgIHwgU29tZSBtIC0+IEx3dF9tdXRleC5sb2NrIG1cbiAgICAgICB8IE5vbmUgLT4gTHd0LnJldHVybl91bml0KVxuXG5sZXQgc2lnbmFsIGN2YXIgYXJnID1cbiAgdHJ5XG4gICAgTHd0Lndha2V1cF9sYXRlciAoTHd0X3NlcXVlbmNlLnRha2VfbCBjdmFyKSBhcmdcbiAgd2l0aCBMd3Rfc2VxdWVuY2UuRW1wdHkgLT5cbiAgICAoKVxuXG5sZXQgYnJvYWRjYXN0IGN2YXIgYXJnID1cbiAgbGV0IHdha2VuZXJzID0gTHd0X3NlcXVlbmNlLmZvbGRfciAoZnVuIHggbCAtPiB4IDo6IGwpIGN2YXIgW10gaW5cbiAgTHd0X3NlcXVlbmNlLml0ZXJfbm9kZV9sIEx3dF9zZXF1ZW5jZS5yZW1vdmUgY3ZhcjtcbiAgTGlzdC5pdGVyIChmdW4gd2FrZW5lciAtPiBMd3Qud2FrZXVwX2xhdGVyIHdha2VuZXIgYXJnKSB3YWtlbmVyc1xuXG5sZXQgYnJvYWRjYXN0X2V4biBjdmFyIGV4biA9XG4gIGxldCB3YWtlbmVycyA9IEx3dF9zZXF1ZW5jZS5mb2xkX3IgKGZ1biB4IGwgLT4geCA6OiBsKSBjdmFyIFtdIGluXG4gIEx3dF9zZXF1ZW5jZS5pdGVyX25vZGVfbCBMd3Rfc2VxdWVuY2UucmVtb3ZlIGN2YXI7XG4gIExpc3QuaXRlciAoZnVuIHdha2VuZXIgLT4gTHd0Lndha2V1cF9sYXRlcl9leG4gd2FrZW5lciBleG4pIHdha2VuZXJzXG4iXSwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
